|**
    kissAssist.mac Original Author: Maskoi.
    KissAssist v12.002 Maintained for RedGuides by Ctaylor22 10/15/2023
    Thanks to all who have Contributied.
    PetTank, PullerPetTank & HunterPetTank roles developed by TreeHuginDruid
    KISS Assist - A simple multi class macro
    Required plugins: MQ2Exchange, MQ2MoveUtils, MQ2Posse, MQ2Rez, & MQ2Medley (Bards), Extended Target Window and ninjadvloot.inc file.
    Optional plugins: MQ2Cast, MQ2Melee, MQ2Gmail, MQ2DanNet, MQ2eqbc, MQ2Nav, MQ2AdvPath, MQ2DPSAdv
    Usage - /mac kissassist assist TankName 95
    or target Main Tank and /mac kissassist assist
    For detailed Instructions go to: https://www.redguides.com/wiki/KissAssist
    This macro was written exclusively for subscribers of Redguides.com
  -------------------------------------------------------------------------------------
 **|
#warning
#turbo 120
|#DEFINE /squelch " "
#DEFINE BuffsNotAnItem ${Select[TRUE,${Bool[${Me.AltAbility[${SpellToCast}]}]},${Bool[${Me.CombatAbility[${SpellToCast}]}]},${Bool[${Me.Skill[${SpellToCast}]}]},${Bool[${Me.Book[${SpellToCast}]}]}]}
#DEFINE DEBUGN "/if (${Debug}) /echo \atDEBUG-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGBUFF "/if (${DebugBuffs}) /echo \awBUFFS-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGCAST "/if (${DebugCast}) /echo \atCAST-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGCOMBAT "/if (${DebugCombat}) /echo \arCOMBAT-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGHEALS "/if (${DebugHeals}) /echo \amHEALS-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGMOVE "/if (${DebugMove}) /echo \ayMOVE-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGMEZ "/if (${DebugMez}) /echo \ayMEZ-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGCHARM "/if (${DebugCharm}) /echo \ayCHARM-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGPET "/if (${DebugPet}) /echo \aoPET-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGPULL "/if (${DebugPull}) /echo \ayPULL-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGCHAINPULL "/if (${DebugChainP}) /echo \ayPULL-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
|---------------------------------------------------------------------------------------------------------------
#DEFINE DEBUGTIMES "/if (${DebugTime}) /echo \atDEBUGTIME START  \agL:${Macro.CurLine} TS:${Macro.RunTime} TT:${DebugTicker} ${Macro.CurSub} \aw"
#DEFINE DEBUGTIMEM "/if (${DebugTime}) /echo \atDEBUGTIME MARKER \agL:${Macro.CurLine} TS:${Macro.RunTime} TT:${DebugTicker} ${Macro.CurSub}:\aw"
#DEFINE DEBUGTIMEE "/if (${DebugTime}) /echo \atDEBUGTIME END    \agL:${Macro.CurLine} TS:${Macro.RunTime} TT:${DebugTicker} ${Macro.CurSub} \aw"
|---------------------------------------------------------------------------------------------------------------
#DEFINE BEGFORITEMS "modrod,modrodp,modrods,icenuke"
#DEFINE BEGFORAEITEMS "modrod,modrodp,modrods,icenuke"
#DEFINE BEGFORBUFFS "Symbol,Aego,Focus,Regen,Haste,Skin,Clarity,Brells,Growth,Speed,Altbuff1,Altbuff2"
|#DEFINE IGNOREGROUPV1LIST "5417,0"
#DEFINE PULLAGGROCHECK "${SpawnCount[xtarhater range ${PullRange} noalert 5]>0}"
#DEFINE DOPARSE "/varset Parse0 !${Parse0}"
#DEFINE DONOTHING "/varset Parse0 !${Parse0}"
#DEFINE XTCHECK "${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID},${Me.XTarget[14].ID},${Me.XTarget[15].ID},${Me.XTarget[16].ID},${Me.XTarget[17].ID},${Me.XTarget[18].ID},${Me.XTarget[19].ID},${Me.XTarget[20].ID}"
|---------------------------------------------------------------------------------------------------------------
| Defines to fix bracket checks in editor
#DEFINE TARGETCHECK {Target.
#DEFINE LEFTPAREN (
| ------------------------------casting events ----------------------------------------
#Event CAST_BEGIN                  "You begin casting #1#"
#Event CAST_BEGIN                  "You begin singing #1#"
#Event CAST_BEGIN                  "Your #1# begins to glow."
#Event CAST_COLLAPSE               "Your gate is too unstable, and collapses#*#"
#Event CAST_CANNOTSEE              "You cannot see your target#*#"
#Event CAST_COMPONENTS             "You are missing some required components#*#"
#Event CAST_COMPONENTS             "Your ability to use this item has been disabled because you do not have at least a gold membership#*#"
#Event CAST_DISTRACTED             "You need to play a#*#instrument for this song#*#"
#Event CAST_DISTRACTED             "You are too distracted to cast a spell now#*#"
#Event CAST_DISTRACTED             "You can't cast spells while invulnerable#*#"
#Event CAST_DISTRACTED             "You *CANNOT* cast spells, you have been silenced#*#"
#Event CAST_FAILED                 "Your ability failed.#*#"
#Event CAST_FDFAIL                 "#1# has fallen to the ground.#*#"
#Event CAST_FIZZLE                 "Your spell fizzles#*#"
#Event CAST_FIZZLE                 "Your #*#spell fizzles#*#"
#Event CAST_FIZZLE                 "You miss a note, bringing your song to a close#*#"
#Event CAST_IMMUNE                 "Your target has no mana to affect#*#"
#Event CAST_IMMUNE                 "Your target is immune to changes in its attack speed#*#"
#Event CAST_IMMUNE                 "Your target is immune to changes in its run speed#*#"
#Event CAST_IMMUNE                 "Your target is immune to snare spells#*#"
#Event CAST_IMMUNE                 "Your target is immune to the stun portion of this effect#*#"
#Event CAST_IMMUNE                 "Your target cannot be mesmerized#*#"
#Event CAST_IMMUNE                 "Your target cannot be charmed#*#"
#Event CAST_IMMUNE                 "Your target looks unaffected#*#"
#Event CAST_INTERRUPTED            "Your spell is interrupted#*#"
#Event CAST_INTERRUPTED            "Your casting has been interrupted#*#"
#Event CAST_INTERRUPTED            "Your #*# spell is interrupted."
#Event CAST_NOMOUNT                "You can only summon a mount on dry land#*#"
#Event CAST_NOMOUNT                "You need to be in a more open area to summon a mount#*#"
#Event CAST_NOMOUNT                "You can not summon a mount here#*#"
#Event CAST_NOMOUNT                "You must have both the Horse Models and your current Luclin Character Model enabled to summon a mount#*#"
#Event CAST_NOMOUNT                "You can not summon a mount in this form#*#"
#Event CAST_NOTARGET               "You must first select a target for this spell#*#"
#Event CAST_NOTARGET               "This spell only works on#*#"
#Event CAST_NOTARGET               "You must first target a group member#*#"
#Event CAST_NOTREADY               "Spell recast time not yet met#*#"
#Event CAST_OUTOFMANA              "Insufficient Mana to cast this spell#*#"
#Event CAST_OUTOFRANGE             "Your target is out of range, get closer#*#"
#Event CAST_OUTDOORS               "This spell does not work here#*#"
#Event CAST_OUTDOORS               "You can only cast this spell in the outdoors#*#"
#Event CAST_RECOVER                "You haven't recovered yet#*#"
#Event CAST_RECOVER                "Spell recovery time not yet met#*#"
#Event CAST_RESISTED               "Your target resisted the #1# spell#*#"
#Event CAST_RESISTED               "#*# resisted your #1#!"
#Event CAST_RESISTEDYOU            "You resist the #1# spell#*#"
#Event CAST_RESISTEDYOU            "You resist #*#"
#Event CAST_STANDING               "You must be standing to cast a spell#*#"
#Event CAST_STUNNED                "You can't cast spells while stunned#*#"
#Event CAST_STUNNED                "You are stunned#*#"
#Event CAST_SUCCESS                "You are already on a mount#*#"
#Event CAST_TAKEHOLD               "Your spell did not take hold#*#"
#Event CAST_TAKEHOLD               "Your #*# spell did not take hold. (Blocked by#*#"
#Event CAST_TAKEHOLD               "Your spell would not have taken hold#*#"
#Event CAST_TAKEHOLD               "Your spell is too powerfull for your intended target#*#"
#Event CAST_TAKEHOLD               "This pet may not be made invisible#*#"
|**************************************** GENERAL EVENTS ***********************************************|
#Event Camping           "#*#seconds to prepare your camp."
#Event EQBCIRC           "<#1#> #2#"
#Event FSEQBC            "#1# tells the fellowship, #2#"
#Event GUEQBC            "#1# tells the guild, #2#"
#Event GainSomething     "#*#You have gained|#1#|"
#Event GotHit            "#1# bashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# bites YOU for #*# points of damage.#*#"
#Event GotHit            "#1# crushes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# gores YOU for #*# points of damage.#*#"
#Event GotHit            "#1# hits YOU for #*# points of damage.#*#"
#Event GotHit            "#1# kicks YOU for #*# points of damage.#*#"
#Event GotHit            "#1# mauls YOU for #*# points of damage.#*#"
#Event GotHit            "#1# pierces YOU for #*# points of damage.#*#"
#Event GotHit            "#1# punches YOU for #*# points of damage.#*#"
#Event GotHit            "#1# rampages YOU for #*# points of damage.#*#"
#Event GotHit            "#1# smashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# slashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# tries to #*# YOU, but #*#"
#Event Invised           "You Vanish #*#"
#Event Joined            "#1# has joined the group."
#Event KABegCheck        "#*#KABeg for #1# #2# #3#"
#Event KTDismount        "[MQ2] KTDismount#*#"
#Event KTDoorClick       "[MQ2] KTDoorClick #1#"
#Event KTDoorClick       "[MQ2] KTDoorClick#*#"
#Event KTHail            "[MQ2] KTHail #1#"
#Event KTInvite          "[MQ2] KTInvite #1#"
#Event KTSay             "[MQ2] KTSay #1# #2#"
#Event KTTarget          "[MQ2] KTTarget #1#"
#Event CharmBackO	 	 "#*#Charm Sucessfull#*#"
#Event LeftGroup         "#1# has left the group."
#Event MezBroke          "#1# has been awakened by #2#."
|#Event CharmBroke        "Your #1# spell has worn off of #2#."
#Event Missing           "#*#You are missing some required components.#*#"
#Event Missing           "#*#You are missing#*#"
|#Event PTaunt            "#*#Taunting attackers as normal, Master.#*#"
#Event PetSusStateAdd1   "#*# tells you, 'By your command, master.#*#"
#Event PetSusStateAdd2   "#*#You cannot have more than one pet at a time.#*#"
#Event PetSusStateSub    "#*# tells you, 'I live again...'#*#"
#Event PetToysPlease     "#*#PetToysPlease #1#"
#Event TaskUpdate        "Your task |#1#| has been updated#*#"
#Event Timer             Timer1
#Event TooSteep          "The ground here is too steep to camp"
#Event WornOff           "Your #1# spell has worn off of #2#."
#Event YouGotTell        "#1# tells you, #2#"
#Event Zoned             "LOADING, PLEASE WAIT#*#"
#Event Zoned             "You have entered#*#"
#Event AskForBuffs       "#1# tells you,#*#Buffs Please!#*#"
#Event AskForBuffs       "#1# says,#*#Buffs Please!#*#"
|**************************************** COMBAT EVENTS ***********************************************|
#Event AttackCalled      "<#1#>#*#TANKING-> #*# <- ID:#2#"
#Event AttackCalled     "[ #1# (#*#) ]#*#TANKING-> #*# <- ID:#2#"
#Event CantHit           "You can't hit them from here."
#Event CantSee           "You cannot see your target."
#Event GoMOff            "The gift of magic fades."
#Event GoMOff            "Your#*#gift of#*#mana fades."
#Event GoMOn             "#*#granted#*#gift of#*#mana#*#"
#Event GoMOn             "You feel strengthened by a gift of magic."
#Event GoMOn             "You feel strengthened by magic."
#Event ImDead            "#*#Returning to Bind Location#*#"
#Event ImDead            "You died."
#Event ImDead            "You have been slain by#*#"
#Event TooClose          "Your target is too close to use a ranged weapon!"
|#Event TooFar            "Your target is too far away, get closer!"
|#Event TooFar            "Your target is out of range, get closer!"
#Event TooFar            "Your target is #*#, get closer!"
#Event MLogOff           "#*#KissAssist Debug Off Marker!"
| -------------------------------------------------------------------------------------
| New Binds to replace old Events
| -------------------------------------------------------------------------------------
#bind AddAFriend     /addfriend
#bind AddMezImmune   /addimmune
#bind AddCharmImmune   /addcimmune
#bind AddToIgnore    /addignore
|#bind CharmBackOff	 /charmbackoff
#bind AddToPull      /addpull
#bind BackOff        /backoff
#bind BuffGroup      /buffgroup
#bind Burn           /burn
#bind Campfire       /campfire
#bind ChangeVarInt   /changevarint
#bind ChaseMe        /chaseme
#bind Debug          /debug
#bind IniWrite       /iniwrite
#bind KissCast       /kisscast
#bind KissCheck      /kisscheck
#bind KissE          /kissedit
#bind MakeCampHere   /makecamphere
#bind MemMySpells    /memmyspells
#bind MyCmds         /mycmd
#bind Parse          /parse
#bind SetPullArc     /SetPullArc
#bind Settings       /kasettings
#bind StayHere       /stayhere
#bind Switch         /switchnow
#bind SwitchMA       /switchma
#bind ToggleVariable /togglevariable
#bind TooBuffList    /tbmanager
#bind TrackMeDown    /trackmedown
#bind WriteMySpells  /writespells
#bind ZoneInfo       /zoneinfo
| -------------------------------------------------------------------------------------
| SUB: Includes
| -------------------------------------------------------------------------------------
#include KAssist\KS_Events.inc
#include KAssist\KS_Pulling.inc
#include KAssist\KS_Combat.inc
#include KAssist\KS_Cast.inc
#include KAssist\KS_Heal.inc
#include KAssist\KS_Mez.inc
#include KAssist\KS_Pets.inc
#include KAssist\KS_Charm.inc
#include ninjadvloot.inc
| -------------------------------------------------------------------------------------
| SUB: Main
| -------------------------------------------------------------------------------------
Sub Main
    /doevents flush
    | Need to check for plugin MQ2Bucles and unload it. Do this ASAP so we can use /while commands from the start
    /if (${Bool[${Plugin[MQ2Bucles]}]}) {
        /squelch /plugin MQ2Bucles unload noauto
        /echo MQ2Bucles detected! This macro doesn't like it! Unloading ...
    }
| -------------------------------------------------------------------------------------
| Define needed outer variables to start pre processes
| -------------------------------------------------------------------------------------
    /call DeclareOuters pre
| -------------------------------------------------------------------------------------
| Get the zone name and fix it.
| Add an _I to the end for Instanced zones.
| -------------------------------------------------------------------------------------
    /if (${ZoneName.Find[,]} || ${ZoneName.Find[']}) {
        /echo ${ZoneName} has a comma or apostrophe in the name, setting Zone Short Name ...
        /varset ZoneName ${Zone.ShortName}
    }
    /if (${Me.InInstance}) {
        /varset ZoneName ${ZoneName}_I
    } else /if (${ZoneName.Find[_]}) {
        /varset ZoneName ${ZoneName.Left[${Math.Calc[${ZoneName.Find[_]}-1]}]}
    }
| -------------------------------------------------------------------------------------
| Process any Command Line Paramaters
| -------------------------------------------------------------------------------------
    /declare pi                     int         local       0
    /declare pj                     int         local       0
    /declare NumParams              int         local       0
    /if (${Macro.Params}) {
        |/echo There is ${Macro.Params} command line parameter(s)
        /varset NumParams ${Math.Calc[${Macro.Params}]}
        /varset pj ${Math.Calc[${NumParams}-1]}
        /for pi 0 to ${pj}
            /if (${Defined[Param${pi}]}) {
                |/echo P${pi}: ${Param${pi}}
                /declare PParam${pi} string outer ${Param${pi}}
                /if (${PParam${pi}.Equal[debug]}) {
                    /debug on log
                } else /if (${PParam${pi}.Equal[debugall]}) {
                    /debug all on log
                }
            }
        /next pi
        /call PParse 0 ${NumParams}
    }
    /deletevar pj
| -------------------------------------------------------------------------------------
| Lets open the KissAssist.ini file
| -------------------------------------------------------------------------------------
    | if Kiss finds a Kissassist_ServerName_ToonName.ini file it will use that one.
    /if (!${PIniSet}) {
        /if (${Ini[${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini,General,KissAssistVer].Length}) {
            /varset IniFileName ${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini
            /echo Server Name ini file detected using ${IniFileName}
        } else {
            /varset IniFileName ${MacroName}_${Me.CleanName}.ini
        }
    }
    /varset KissAssistVer ${Ini[${IniFileName},General,KissAssistVer]}
    DEBUGN ${IniFileName} ${KissAssistVer}
    /if (!${Ini[${IniFileName},General,KissAssistVer].Length}) /ini "${IniFileName}" "General" "KissAssistVer" "0.0"
| -------------------------------------------------------------------------------------
| Load Aliases
| -------------------------------------------------------------------------------------
    /call LoadAliases
| -------------------------------------------------------------------------------------
| Declare the Main Outer variables needed before loading ini entries
| -------------------------------------------------------------------------------------
    /call DeclareOuters main
| -------------------------------------------------------------------------------------
| If there were command line paramaters Lets Parse them to the p_vars.
| -------------------------------------------------------------------------------------
    /if (${NumParams}) /call PParse 1 ${NumParams}
| -------------------------------------------------------------------------------------
| Load Ini file settings
| -------------------------------------------------------------------------------------
    /call Bind_Settings load all 0
| -------------------------------------------------------------------------------------
| Declare the Main Outer variables that required the ini file loaded first.
| -------------------------------------------------------------------------------------
    /call DeclareOuters post
| -------------------------------------------------------------------------------------
| Declare Any Global variables. Used for PetToys Given.
| -------------------------------------------------------------------------------------
    /call DeclareOuters global
| -------------------------------------------------------------------------------------
|   ******** Clean old INI entries and move others to proper locations **|
| -------------------------------------------------------------------------------------
    /call IniCleanup
| -------------------------------------------------------------------------------------
| Lets finish setting everything up bassed off loaded information.
| -------------------------------------------------------------------------------------
    /call InitData
| -------------------------------------------------------------------------------------
| Check if required plugins are loaded and settings are set.
| -------------------------------------------------------------------------------------
    /call InitPlugins
| -------------------------------------------------------------------------------------
| Add in AdvancedLoot variables if needed
| -------------------------------------------------------------------------------------
    /if (${SubDefined[SetupAdvLootVars]}) {
        /call SetupAdvLootVars
        /if (${LootOn} && ${Defined[NALStatus]}) {
            /varset NALStatus 1
        }
    }
| -------------------------------------------------------------------------------------
| Parse DPS when Parse tag was used from command line.
| Otherwise Assign Main Tank from command line parameter or targeted player, merc or pet
| -------------------------------------------------------------------------------------
    /if (${ParseDPSTimer}>=1) {
        /target id ${Me.ID}
        /delay 10 ${Target.ID}==${Me.ID}
        /if (${DPSOn}) /varset DPSOn 2
        /if (${Select[${Me.Class.ShortName},mag,nec,bst]}) {
            /varset Role PetTank
        } else {
            /varset Role Tank
        }
        /call AssignMainAssist 0
        /call CheckRoles 1
        /call CheckBuffs ${ForceBuffs}
        /varset ForceBuffs 0
        /call Bind_Parse ${ParseDPSTimer}
        /endmacro
    }
| -------------------------------------------------------------------------------------
| Lets finish setting things up and start the main process loop
| -------------------------------------------------------------------------------------
    /call AssignMainAssist 1
    /call CheckRoles 1
    /varset WhoToChase ${MainAssist}
    /varset MyOriginalRole ${Role}
    /while (1) {
        /varset EventFlag 0
        /doevents
        /if (!${EventFlag}) /break
    }
    /call StartupCredits
    /call StartupMisc
    /call StartupCommands
    /call WinTitle
| -------------------------------------------------------------------------------------
| Main Loop
| -------------------------------------------------------------------------------------
    /while (1) {
        /while (1) {
            /varset EventFlag 0
            /doevents
            /if (!${EventFlag}) /break
        }
        /if (${ChainPull}!=2) {
            /if (!${IAmABard} && ${Me.Casting.ID} && ${CheckStuckGem}) /call CheckStuckGems
            /if (${ClickBacktoCamp}) /call CampfireBack
            /if (${CorpseRecoveryOn}==1) /call RecoverCorpses
            /if (${MiscGemRemem} && (${ReMemCast} || ${ReMemCastLW})) {
                /varset DontMoveMe 1
                /call CastReMem "${ReMemMiscSpell}" 1 mainloop
                /varset DontMoveMe 0
            }
            /if (${MezOn}) {
                /varset GoMByPass 1
                /call DoMezStuff MainLoop
                /varset GoMByPass 0
            }
			/if (${CharmOn}) {
			    /varset GoMByPass 1
                /call DoCharmStuff MainLoop
                /varset GoMByPass 0
            }
            /if (${AFKToolsOn}) /call AFKTools
            /if (${DPSOn} || ${MeleeOn}) /call CheckForCombat 0 MainLoop1 0
            /if (${AEOn}) /call AECheck ${AEDisplayMobInfo}
            /call WriteDebuffs
            /if (${CuresOn}) /call CheckCures MainLoop
            /if (${HealsOn}) /call CheckHealth MainLoop
            /if (${Me.CombatState.NotEqual[COMBAT]} && ${ReturnToCamp}) /call DoWeMove 0 mainloop
            /if (${ChaseAssist}) /call DoWeChase
            /if (${AutoRezOn}) /call RezCheck all
            /if (${CampfireOn} && ${Me.CombatState.NotEqual[COMBAT]}) /call Campfire
            /if (${Select[${Me},${Group.Leader}]}==1 && !${LooterAssigned}) /call AssignLooter
            /call DoMiscStuff
            /call CanIDoStuff
            /if (${MercOn}) /call MercsDoWhat
            /call CastMana MainLoop
            /if (${PetOn}) /call DoPetStuff
            /if (${CharmOn} && ${Me.Pet.ID}) /call DoPetStuff
            /if (${PetOn}) /call CheckPetBuffs
            /if (${PetToysOn} && ${KAPetBegActive}) /call CheckBegforPetBuffs
            /if (${Me.CombatState.NotEqual[COMBAT]} && !${DanNetOn}) {
                /call WriteBuffs
                /if (${MercOn}) /call WriteBuffsMerc
                /call WriteBuffsPet
            }
            /if (${BuffsOn}) {
                /call CheckBuffs ${ForceBuffs}
                /varset ForceBuffs 0
            }
            /if (${BuffsOn} && ${KABegActive} ) /call CheckBegforBuffs
            /if (${IAmABard}) /call DoBardStuff
            /if (${Me.CombatState.NotEqual[COMBAT]}) {
                /if (${MedOn}) /call DoWeMed 0 0 "${MedStat}" ${MedStop}
                /if (${GroupWatchOn}) /call GroupWatch
            }
        } else {
            /if (${AFKToolsOn}) /call AFKTools
        }
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
            /if (${If[${PullHoldCond},0,1]} && !${DragCorpse}) {
                /if (${Select[${PullWith},Melee,Pet]} || ${Select[TRUE,${Me.SpellReady[${PullWith}]},${Me.AltAbilityReady[${PullWith}]},${Me.CombatAbilityReady[${PullWith}]},${Me.ItemReady[${PullWith}]},${If[${PullWith.Equal[Ranged]} && ${Me.RangedReady},TRUE,FALSE]}]}) {
                    | Try and find mob and NOT force using Camp Location
                    /if (!${PullMob}) /call FindMobToPull 1 1 0
                    | If I am in Hunter mode and I didn't find a mob, then lets try using Camp Location.
                    /if (!${PullMob} && ${Select[${Role},hunter,hunterpettank]}) /call FindMobToPull 1 1 1
                    /call PullCheck
                    /varset PullMob 0
                    /if (${PullOnReturn} && ${Macro.Return.Equal[oor]}) /call FindMobOnReturn
                    /if (${DragCorpse}) /continue
                } else {
                    /if (!${SpamTimer1}) {
                        /echo Holding Pulls. PullWith ${PullWith} is not ready.
                        /varset SpamTimer1 50
                    }
                }
            } else {
                /if (!${SpamTimer1}) {
                    /if (!${DragCorpse}) {
                        /echo Holding Pulls Due to Pull Hold Condition.
                    } else {
                        /echo Holding Pulls Due to Dragging Corpse Back to Camp.
                        /if (!${SpawnCount[pccorpse ${Me} radius 89]}) {
                            /call PullReset
                            /continue
                        }
                    }
                    /varset SpamTimer1 50
                }
            }
        }
        /if (${DPSOn} || ${MeleeOn}) {
            /call CheckForCombat 0 MainLoop2 200
        } else {
            /call CheckForCombat 1 MainLoop3 0
        }
        /if (${LootOn}) /call LootStuff
        /if (${DebugHeals}) /delay 5
        /delay 1
        |End of While loop
    }
    | From here down executed when /endmacro is issued or macro crashes due to error.
:OnExit
    /if (!${MacroQuest.LastCommand.Find[/end]}) {
        /ini "${IniFileName}" "KissError"  "LastCMD:" "${MacroQuest.LastCommand}"
        /ini "${IniFileName}" "KissError"  "ErrorDateTime:" "${Time.Date} ${Time.Time24}"
        /ini "${IniFileName}" "KissError"  "ErrorMsg:" "${MacroQuest.Error}"
        /ini "${IniFileName}" "KissError"  "DataError:" "${MacroQuest.MQ2DataError}"
        /ini "${IniFileName}" "KissError"  "SyntaxError:" "${MacroQuest.SyntaxError}"
        /ini "${IniFileName}" "KissError"  "RunningTime:" "${MacroQuest.Running}"
        /ini "${IniFileName}" "KissError"  "BuildDate:" "${MacroQuest.BuildDate}"
        /ini "${IniFileName}" "KissError"  "CurrentUI:" "${EverQuest.CurrentUI}"
    }
    /if (${MQ2CastReload}) /plugin mq2cast noauto
    /if (${MQ2MeleeReload}) /plugin mq2melee noauto
    /if (${MQ2SpawnMasterReload}) /plugin mq2spawnmaster noauto
    /if (${XTSlot}) {
        /xtarget set ${XTSlot} autohater
        /ini "${IniFileName}" "General" "XTSlot" "0"
    }
    /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) /pet follow
    /endmacro
/return


| -------------------------------------------------------------------------------------
| SUB: BreakMez - Written by Trehuggindruid for KissAssist
| -------------------------------------------------------------------------------------
    Sub BreakMez
        /if (${PetBreakMezSpell.Equal[null]}) /return
        DEBUGCOMBAT BreakMez: Enter
        /declare PetBreakMezTargetID int local ${MyTargetID}
        /echo ATTEMPTING TO BREAK MEZ ON: (${Target.CleanName}) ID:(${PetBreakMezTargetID})
        /while (${Target.Mezzed.ID}) {
            DEBUGCOMBAT Break Mez with: - ${PetBreakMezSpell}
            /call CastWhat "${PetBreakMezSpell}" ${PetBreakMezTargetID} BreakMez 0 0
            |--- DO NOT CHANGE THIS CONDITION!!!!!!
            /if (${Target.Mezzed.ID}) {
                DEBUGCOMBAT Mez NOT broken, trying again!
            }
        }
        /varset PetAttack 0
        /echo + Mez broken !
        |/if (${Me.Pet.ID} && !${Me.Pet.Combat}) /pet attack
        DEBUGCOMBAT BreakMez: Leave
    /return

|**************************************************************************************|
| -------------------------------------------------------------------------------------
| SUB: Do We Move
| -------------------------------------------------------------------------------------
    Sub DoWeMove(int ForceToCamp, SentFrom)
        /if (!${ReturnToCamp} && !${ForceToCamp}) /return
        /declare StuckCount int local 0
        /declare X1 int local
        /declare Y1 int local
        /declare scatterDistance int local
        /declare CampYRandom int local
        /declare CampXRandom int local
        /while (1) {
            /varset EventFlag 0
            /doevents
            /if (!${EventFlag}) /break
        }
        /call EndMacroIf
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 30s
        /declare SpamTimerL timer local 0
        /declare LocCheckTimer timer local 0
        /declare _Y0           float local ${Math.Calc[${CampYLoc}-20]}
        /declare _Y1           float local ${Math.Calc[${CampYLoc}+20]}
        /declare MyDistance    int   local 0
        /declare DToggle       bool  local false

        /if (${Target.ID} && ${Target.Type.Equal[npc]}) {
            /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        }
        /declare circleDirection string local
        DEBUGN DoWeMove: Enter
        | - Shuts off ReturnToCamp if a toon moves a big distance defined by CampRadiusExceed ie CoH !${Pulled} || ${Pulling}
        DEBUGMOVE DoWeMove:(ReturnToCamp) My distance from camp is: (${Math.Distance[${CampYLoc},${CampXLoc}]}).
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadiusExceed} && !${Role.Find[hunter]} && ${ReturnToCamp}==1 && ${CampZone}==${Zone.ID}) {
            DEBUGMOVE DoWeMove:(ReturnToCamp) CampRadiusExceed turning off ReturnToCamp.
            /varset ReturnToCamp 0
            /echo Leashing exceeded distance of ${CampRadiusExceed} turning off ReturnToCamp
            /return
        }
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 12 && ${CampZone}==${Zone.ID}) {
            /if (${Me.Feigning}) {
                /if (${AggroOffTimer}) {
                    /while (${Me.Feigning}) {
                        /doevents Timer
                        /delay 5
                    }
                } else {
                    /doevents Timer
                    /delay 10
                    /if (${Me.Feigning}) /stand
                }
            }
            DEBUGMOVE DoWeMove:(ReturnToCamp) Distance to camp > 10 and no adds in camp. ${Math.Distance[${CampYLoc},${CampXLoc}]} ${CampRadius} ${Medding}
            | Prevent puller roles from returning to camphere spot and just pull from where they are if in camp radius.
            /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=${CampRadius} && !${ForceToCamp} && !${Medding}) /return
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                |---------------------------------------------- MQ2Nav ---------------------------------------------------------------------|
                /if (${PullMoveUse.Equal[nav]}) {
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius})  {
                        DEBUGMOVE DoWeMove:(ReturnToCamp) Distance to camp > 15, MQ2Nav return to camp.
                        /while (1) {
                            /doevents
                            /if (${IAmDead} || ${Me.Hovering}) {
                                /if (${Navigation.Active}) /nav stop
                                /return IAD
                            }
                            /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
                            /nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
                            /if (${Me.Mount.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]} <= 75) {
                                /echo MQ2Nav does not work well with mounts. Dismounting.
                                /dismount
                            }
                            /while (1) {
                                /varset X1 ${Int[${Me.X}]}
                                /varset Y1 ${Int[${Me.Y}]}
                                /if (${Pulled}) {
                                    | PullerPetTank - send in pet to attack on my way back to camp if not too far from camp.
                                    /if (${Role.Equal[pullerpettank]} || ${PullWith.Equal[pet]}) {
                                        /if (${Me.Pet.ID}) {
                                            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                                                /call CombatPet
                                            } else {
                                                /if (${Me.Pet.Combat}) /pet back off
                                                /if (${Me.Pet.Stance.NotEqual[FOLLOW]} && ${PullWith.Equal[pet]}) /pet follow
                                            }
                                        }
                                    }
                                    |if MyTargetID is not on Xtarget, and the mob is still in the zone, then the mob lost aggro.
                                    |and we need to go back and get him.
                                    /if (!${SpawnCount[id ${MyTargetID} xtarhater]} && ${Spawn[id ${MyTargetID}].ID}) {
                                        /if (!${AggroTargetID} || (${ChainPull} && !${PullAggroTargetID})) {
                                            /echo I got Here1: ${AggroTargetID} ${ChainPull} ${PullAggroTargetID} ${MyTargetID}
                                            /varset Pulled 0
                                            | if using ranged then try and pull mob again, other wise start looking for another mob.
                                            /if (${PullWith.Equal[Ranged]}) {
                                                /if (${Navigation.Active}) /nav stop
                                                /return lma
                                            } else {
                                                /continue
                                            }
                                        } else /if (!${ChainPull}) {
                                            /varset MyTargetID ${AggroTargetID}
                                        } else {
                                            /varset MyTargetID ${PullAggroTargetID}
                                        }
                                        /if (!${MyTargetID}) /varset Pulled 0
                                    }
                                    /if ((${Me.Running} && !${SpawnCount[xtarhater radius 300]}) || (!${Me.Running} && ${SpawnCount[xtarhater radius 200]})) /nomodkey /keypress RUN_WALK
                                } else {
                                    | Added for finding mob to pull when running back to camp after a failed pull.
                                    /if (${CheckOnReturn} && ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${Math.Calc[${MaxRadius}*.90]}) {
                                        /call FindMobToPull 0 1 0
                                        /if (${Macro.Return}>0) {
                                            /varset MyTargetID 0
                                            /if (${Navigation.Active}) /nav stop
                                            /return
                                        }
                                    }
                                }
                                /delay 5
                                /if (${Me.Hovering}) {
                                    /break
                                } else /if (!${Me.Stunned} && !${Me.Feigning}) {
                                    | Check for getting stuck on geometry
                                    /if (${Int[${Me.X}]}==${X1} && ${Int[${Me.Y}]}==${Y1}) {
                                        /varcalc StuckCount (${StuckCount})+1
                                        /if (${StuckCount}>=3) {
                                            /if (${Navigation.Active}) /nav stop
                                            /call Stuck DoWeMove
                                            /varset StuckCount 0
                                            /break
                                        }
                                    }
                                } else /if (${Me.Stunned}) {
                                    /while (${Me.Stunned}) {
                                        /delay 2
                                    }
                                    /break
                                }
                                DEBUGMOVE DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} >= ${CampRadius} Timer: ${DWMTimer}
                                /if (${Navigation.Active}) {
                                    /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) {
                                        /if (!${DWMTimer}) /varset DWMTimer 5s
                                    }
                                }
                                /if (!${Navigation.Active} || !${DWMTimer}) /break
                            }
                            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < 16) {
                                /if (!${CampZLoc}) /varset CampZLoc ${Me.Z}
                                /break
                            }
                        }
                    }
                |---------------------------------------------- MQ2AdvPath ---------------------------------------------------------------------|
                } else /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                    /if (${MoveTo.Moving}) /moveto off
                    /play ${PullPath} reverse nodoor smart
                    DEBUGMOVE DoWeMove: /play ${PullPath} reverse nodoor smart
                    /while (1) {
                        /doevents
                        /if (${IAmDead} || ${Me.Hovering}) {
                            /if (${AdvPath.State}) /play off
                            /return
                        }
                        /delay 5
                        /varset DWMWPCurrent ${AdvPath.NextWaypoint}
                        DEBUGMOVE DoWeMove: ReturnToCamp WP#: ${DWMWPCurrent} ${MoveTo.Moving}
                        /if (${AdvPath.State}==2 && ${Me.Moving} && ${DWMTimer}<10) /varset DWMTimer 10
                        /if (${DWMTimer}==0) /break
                        |This is for when you get summoned while running back to camp.
                        |AdvPath stops playing the path back to camp when summoned.
                        /if (${DWMWPCurrent}<2) {
                            /break
                        } else /if (${AdvPath.State}==0) {
                            /play ${PullPath} reverse nodoor smart
                            /varset DWMTimer 10
                        }
                        /if (${Pulled}) {
                            /if ((${Me.Running} && !${SpawnCount[xtarhater radius 300]}) || (!${Me.Running} && ${SpawnCount[xtarhater radius 200]})) /nomodkey /keypress RUN_WALK
                        }
                    }
                    /if (${AdvPath.State}) /play off
                }
            } else /if (${PullMoveUse.Equal[nav]}) {
                DEBUGMOVE DoWeMove:(ReturnToCamp) Non-Puller MQ2Nav return to camp.
                /varset DWMTimer 10s
                /doevents
                /if (${IAmDead} || ${Me.Hovering}) {
                    /if (${Navigation.Active}) /nav stop
                    /return
                }
                /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
                /nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
                /while (1) {
                    /if (${IAmDead} || ${Me.Hovering}) {
                        /if (${Navigation.Active}) /nav stop
                        /return
                    }
                    /if (!${Navigation.Active}) {
                        /break
                    } else {
                        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) {
                            /if (!${DWMTimer}) /varset DWMTimer 5s
                        } else {
                            /if (!${CampZLoc}) /varset CampZLoc ${Me.Z}
                        }
                    }
                }
            }
            |------------------------------------------------ MoveTo -----------------------------------------------------------------------|
            DEBUGMOVE DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15, MQ2MoveUtils return to camp.
            /doevents
            /if (!${Me.FeetWet}) /look 0
            /moveto dist 10
            /if (${ScatterOn}) {
                | Randomize camp x,y by +- so toons don't always retun to exact same spot and help to look less botted.
                /varcalc scatterDistance ${Math.Rand[7]}+5
                /if (${Math.Rand[2]}) {
                    /varcalc CampYRandom ${CampYLoc}-${scatterDistance}
                } else {
                    /varcalc CampYRandom ${CampYLoc}+${scatterDistance}
                }
                /if (${Math.Rand[2]}) {
                    /varcalc CampXRandom ${CampXLoc}-${scatterDistance}
                } else {
                    /varcalc CampXRandom ${CampXLoc}+${scatterDistance}
                }
            } else {
                /varset CampYRandom ${CampYLoc}
                /varset CampXRandom ${CampXLoc}
            }
            DEBUGMOVE DoWeMove: Camp Location Info: ScatterOn: ${ScatterOn} YRandom: ${CampYRandom} XRandom: ${CampXRandom} ${IAmDead} ${Me.Hovering}
            /varcalc MyDistance ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]}-4
            /varset LocCheckTimer ${LocDelayCheckUW}
            /while (1) {
                /if (${IAmDead} || ${Me.Hovering}) {
                    /moveto off
                    /return
                }
                /if (!${Me.Mount.ID} && ${Me.Sitting} && ${Math.Distance[${CampYLoc},${CampXLoc}]} >= 16) /stand
                /if (!${Me.Moving} || !${MoveTo.Moving}) {
                    /if (${Me.FeetWet}) {
                        /face loc ${CampYRandom},${CampXRandom},${CampZLoc}
                        /moveto set useback off
                        /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} mdist 15
                    } else {
                        /moveto set useback on
                        /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc}
                    }
                } else {
                    /if (!${LocCheckTimer}) {
                        /if (${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]}>${MyDistance}) {
                           |OK I am Stuck or snared. Because I am not moving or moving slowly.
                            /if (${Me.FeetWet}) {
                                /if (${MoveTo.Moving}) {
                                    /moveto off
                                    /delay 5
                                }
                                /if (${DToggle}) {
                                    /face loc ${_Y1},${CampXRandom},${CampZLoc}
                                    /delay 5
                                    /moveto loc ${_Y1} ${CampXRandom} ${CampZLoc} mdist 5
                                } else {
                                    /face loc ${_Y0},${CampXRandom},${CampZLoc}
                                    /delay 5
                                    /moveto loc ${_Y0} ${CampXRandom} ${CampZLoc} mdist 5
                                }
                                /varcalc DWMTimer ${DWMTimer}+20
                                /varset DToggle ${If[${DToggle},False,True]}
                                |/delay 5
                            }
                        } else {
                            /face loc ${CampYRandom},${CampXRandom},${CampZLoc}
                        }
                        /varcalc MyDistance ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]}-4
                        /varset LocCheckTimer ${LocDelayCheckUW}
                    }
                }
                /if (${Pulled}) {
                    /if (${Role.Equal[pullerpettank]} || ${PullWith.Equal[pet]}) {
                        /if (${Me.Pet.ID}) {
                            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                                /call CombatPet
                            } else {
                                /if (${Me.Pet.Combat}) /pet back off
                                /if (${Me.Pet.Stance.NotEqual[FOLLOW]} && ${PullWith.Equal[pet]}) /pet follow
                            }
                        }
                    }
                    /if ((${Me.Running} && !${SpawnCount[xtarhater radius 300]}) || (!${Me.Running} && ${SpawnCount[xtarhater radius 200]})) /nomodkey /keypress RUN_WALK
                }
                /delay 10
                /if ((!${MoveTo.Moving} && !${Me.Moving}) || ${DWMTimer}==0) /break
                DEBUGMOVE DoWeMove: MoveTo My distance from Camp is: ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} ${Me.FeetWet}.
                /if (!${MoveTo.Moving} || ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} < 16) /break
            }
            /if (${Me.FeetWet} && ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} >= 15) {
                /varset DWMTimer 20
                /face loc ${CampYRandom},${CampXRandom},${CampZLoc}
                /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} mdist 15
                /while (${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} > 15 && ${DWMTimer}) {
                    /delay 5
                }
                /if (${MoveTo.Moving}) /moveto off
            }
            /delay 20 !${Me.Moving}
            | Move down if Z distance more than 3 due to levitation
            /if (${Target.ID} && ${Select[${Target.Type},npc,corpse]})  /call ZAxisCheck ${ZDist} 3.1
            /if (${FaceMobOn} && !${AggroTargetID} && !${CombatStart} || ${Select[${Role},pullertank,puller,pullerpettank]}==0) /face heading ${LookForward}
            /if (!${Me.FeetWet}) /look 0
        }
        /if (${Me.FeetWet} && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} >= 15) {
            /face loc ${CampYLoc},${CampXLoc},${CampZLoc}
            /moveto loc ${CampYLoc} ${CampXLoc} ${CampZLoc} mdist 15
            /varset DWMTimer 30
            /while (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} > 15 && ${DWMTimer}) {
                /delay 5
            }
            /if (${MoveTo.Moving}) /moveto off
        }
        DEBUGMOVE DoWeMove: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Do We Chase
| -------------------------------------------------------------------------------------
    Sub DoWeChase(string SentFrom)
        /if (!${ChaseAssist}) /return
        /if (${Me.Hovering} || !${Spawn[=${WhoToChase}].ID}) /return
        /declare StuckCount int local 0
        /declare X1 int local
        /declare Y1 int local
        /declare MeshLoadedCheck bool local FALSE
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 0
        /if (${PullMoveUse.Equal[nav]}) {
            /varset MeshLoadedCheck ${Navigation.MeshLoaded}
        }
        DEBUGMOVE DoWeChase: Enter ${SentFrom}
        /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) /pet follow
        /while (${ChaseAssist}) {
            | Stop sticking if mobs are on xtarget
            /if (${ChaseAssist}==1) {
                /if (${SpawnCount[npc xtarhater]} && !${Role.Find[pull]} && !${IAmMA} && ${Spawn[=${WhoToChase}].Distance} < ${CampRadius}) {
                    /if (${Stick.Active}) {
                        DEBUGMOVE Not gonna be an idiot and move during fight cause I dont have to.
                        /stick off
                        /moveto off
                    }
                    /if (${PullMoveUse.Equal[nav]}) {
                        /if (${Navigation.Active}) /nav stop
                    }
                    /break
                }
            }
            /doevents
            /call EndMacroIf
            DEBUGMOVE DoWeChase:(ChaseAssist) My distance from (${WhoToChase}) is: (${Spawn[=${WhoToChase}].Distance}) Z: ${Spawn[=${WhoToChase}].DistanceZ}.
            | If the mesh loaded then ignore Distance and Z Distance. Just try and run the path to WhoToChase.
            /if (${JustZoned}==0) {
                /if (!${MeshLoadedCheck} && (${Spawn[=${WhoToChase}].Distance} > ${CampRadiusExceed} || ${Spawn[=${WhoToChase}].DistanceZ}>100)) {
                    /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist exceed camp check
                    /varset ChaseAssist 0
                    /echo ChaseAssist distance exceeded: Turning off ChaseAssist
                    /call BroadCast r "Hey! I got left behind please run me to " ${WhoToChase}
                    /break
                }
            } else {
                /while (!${Spawn[=${WhoToChase}].ID}) {
                    /delay 10
                    /if (!${JustZoned}) /break
                    DOPARSE
                }
            }
            /if (!${Spawn[=${WhoToChase}].ID}) /break
            /if (${Spawn[=${WhoToChase}].Distance} > ${ChaseDistance}) {
                /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist MA distance check
                /if (${MeshLoadedCheck}) {
                    /if (!${Navigation.Active}) {
                        /if (${Navigation.PathExists[id ${Spawn[=${WhoToChase}].ID}]}) {
                            /nav id ${Spawn[=${WhoToChase}].ID}
                        } else /if (${Spawn[=${WhoToChase}].LineOfSight}) {
                            /moveto id ${Spawn[=${WhoToChase}].ID} uw mdist ${ChaseDistance}
                        } else {
                            /echo Chase Failed due to ${WhoToChase} is not in Line of sight and Navigation couldn't find a path. Will try /Sticking.
                        }
                    }
                } else /if (${Spawn[=${WhoToChase}].LineOfSight}) {
                    /moveto id ${Spawn[=${WhoToChase}].ID} uw mdist ${ChaseDistance}
                }
                /delay 10 ${Me.Moving}
                /while (${Me.Moving}) {
                    /if (${Spawn[=${WhoToChase}].Distance3D}<=${ChaseDistance}) {
                        /if (${PullMoveUse.Equal[nav]}) {
                            /if (${Navigation.Active}) /nav stop
                        }
                    }
                    /delay 5
                }
            } else /if (!${Stick.Active} && !${MeshLoadedCheck}) {
                /if (${Spawn[=${WhoToChase}].Type.Equal[Pet]}) {
                    /target ${Spawn[=${WhoToChase}].Master}
                    /delay 10
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Target.ID} loose uw
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else /if ( ${Spawn[=${WhoToChase}].Type.Equal[mercenary]}) {
                    /target ${Spawn[=${WhoToChase}].Owner}
                    /delay 10
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Target.ID} loose uw
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else {
                   /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Spawn[=${WhoToChase}].ID} loose uw
                    } else {
                       /stick ${ChaseDistance} id ${Spawn[=${WhoToChase}].ID} loose
                    }
                }
                /delay 10
                /while (${Me.Moving}) {
                    /delay 10
                }
            }
            /if (!${Me.Moving} && !${Spawn[=${WhoToChase}].Moving}) /break
            /while (${ChaseAssist}==3) {
                /delay 10
            }
        }
        DEBUGMOVE DoWeChase: Leave
    /return
|-------------------------------------------------------------------------------------
| SUB: Stuck
| -------------------------------------------------------------------------------------
    Sub Stuck(string SentFrom)
        /declare strafedir string local
        | - We're stuck, back off a second, move left or right (randomly) for 1 second
        /if (${IAmDead}) /return
        /keypress back hold
        /delay 10
        /keypress back
        /if (${Math.Rand[2]}) {
            /varset strafedir STRAFE_LEFT
        } else {
            /varset strafedir STRAFE_RIGHT
        }
        /keypress ${strafedir} hold
        /delay 10
        /keypress ${strafedir}
    /return
| -------------------------------------------------------------------------------------
| SUB: DoWeMed
| -------------------------------------------------------------------------------------
    Sub DoWeMed(int p_UseFlag, int p_watchID, string p_stat, int p_resume)
        /if (!${MedOn}) /return
        /if (!${MedCombat} && ${AggroTargetID}) /return
        /if (${MedCombat} && !${Medding} && ${AggroTargetID}!=0 && ${AggroTargetID}==${MyTargetID}) /return
        DEBUGN DoWeMed Enter
        /declare Med2On       int    local 0
        /declare MedForceOn   int    local 0
        /declare MedStat1     string local ${MedStat}
        /declare j            int    local 0
        /declare MedFlag      int    local 0
        /declare SittingDown  int    local 0
        /declare IAmMedding   int    local 0
        /declare MedSingingID int    local 0
        /declare watchName    string local
        /declare MedCombatCK  int    local ${MedCombat}

        /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) {
            /varset MedStat Mana
        } else {
            |/if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
            /varset MedStat Endurance
        }
        /if (!${Me.Moving}) {
            /if (${Select[${Me.Class.ShortName},BRD,BST,PAL,RNG,SHD]} && ${Me.Pct${MedStat2}}<${MedStart} && ${Me.Pct${MedStat}}>${MedStart}) {
                /varset MedStat1 ${MedStat}
                /varset MedStat ${MedStat2}
                /varset Med2On 1
            }
            /if ((${Group.MainAssist.ID} && ${Group.MainAssist.Sitting}) || (!${Group.Member[${MainAssist}].Index} && ${Spawn[PC ${MainAssist}].Sitting})) {
                /if (!${MASitTime}) {
                    /varset MASitTime 300
                } else /if (${MASitTime}<260) {
                   /varset MedForceOn 1
                }
            } else {
                /varset MASitTime 0
            }
            /if (${Me.Pct${MedStat}}<${MedStart}) {
                /varset MedFlag 1
            } else /if (${MeddingInterrupted}) {
                /if (${MeddingInterrupted}==2 || ${MeddingInterrupted}==4) {
                    /varset p_UseFlag 1
                    /varset PullWaitTimer1 ${PullWaitRemaining}
                | Need to find the lowest of MedStat in the group and use them as who to watch.
                } else /if (${MeddingInterrupted}==3 || ${MeddingInterrupted}==5) {
                    /if (${MeddingInterrupted}==3) {
                        /call CheckGroupStats mana
                    } else {
                        /call CheckGroupStats endurance
                    }
                    /varset j ${Macro.Return}
                    /if (!${j}) {
                        /varset MeddingInterrupted 0
                        /return
                    } else {
                        /varset p_UseFlag 2
                        /varset p_watchID ${Group.Member[${j}].ID}
                        /varset watchName ${Group.Member[${j}].CleanName}
                    }
                }
                /varset MedFlag 1
            } else /if (${PullHold}==2 && ${Me.Pct${MedStat}}<98) {
                /varset MedFlag 1
            } else /if (${MedForceOn} && ${Me.Pct${MedStat}}<90 && !${Role.Find[puller]}) {
                /if (${MedCombat}) /varset MedCombatCK 0
                /varset MedFlag 1
            } else /if (${p_UseFlag}==1 && ${PullWaitTimer1}) {
                /varset MedFlag 1
            } else /if (${p_UseFlag}==2 && ${p_watchID}) {
                /varset MedFlag 1
                /varset watchName ${Spawn[id ${p_watchID}].CleanName}
            } else {
                /return
            }
            /if (${MedFlag}) {
                /if (${Target.ID}) /squelch /target clear
                /varset Medding 1
                /if (${Attacking}) /call CombatReset 0 dowemed
                | bards twisting while others fighting negate fast med
                /if (${IAmABard}) {
                    /call CastBardCheck 0
                    /squelch /medley off
                }
                /if (${Medding}) /echo Medding until ${MedStat} ${MedStop}% ${Me.Pct${MedStat}} ${MedStart}
                /if (${Me.Pct${MedStat}}<${MedStart}) {
                    /call BroadCast t "My ${MedStat} is ${Me.Pct${MedStat}}% time to med."
                } else /if (${MeddingInterrupted}) {
                    /if (${p_UseFlag}==2) {
                        |"Waiting for >> ${charname} << to med up to ${resume}% ${stat}."
                        /call BroadCast t "Medding Interrupted. Waiting for >> ${watchName} to med."
                    } else {
                        /call BroadCast t "Medding Interrupted. My ${MedStat} is ${Me.Pct${MedStat}}% time to Resume."
                    }
                }
                /if (!${MeddingInterrupted}) {
                    /if (!${p_UseFlag}) {
                        /varset MeddingInterrupted 1
                    } else /if (${p_UseFlag}==1) {
                        /if (${MedStat.Equal[mana]}) {
                            /varset MeddingInterrupted 2
                        } else {
                            /varset MeddingInterrupted 4
                        }
                    } else /if (${p_UseFlag}==2) {
                        /if (${MedStat.Equal[mana]}) {
                            /varset MeddingInterrupted 3
                        } else {
                            /varset MeddingInterrupted 5
                        }
                    }
                }
                /while (1) {
                    /doevents
                    /if (${ChaseAssist}) /call DoWeChase
                    /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                        /call DoWeMove 0 DoWeMed
                    }
                    /if (${MountOn} && !${Me.Mount.ID} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]})) /call CastMount
                    /if (!${IAmABard}) {
                        /if (!${Me.Mount.ID} && !${IAmMedding} && ${Me.Standing} && !${Me.Moving}) {
                            /sit
                            /varset SittingDown 1
                            /varset IAmMedding 1
                            /delay 10
                        } else /if (${SittingDown}==1 && ${Me.Standing}) {
                            /echo I sat you down, but you are no longer sitting.
                            /echo You have something outside of Kissassist standing you.
                            /varset SittingDown 2
                        }
                    } 
					|-- else {
                        |-- | For Bards Only.
                        |-- /if (${MedFlag}==1) {
                            |-- /if (${MedSingingID}) {
                                |-- /if (${MedSingingID}!=${Me.Casting.ID} || !${Me.Casting.ID}) {
                                    |-- /squelch /stopsong
                                    |-- /if (${Me.Sitting}) /stand
                                    |-- /delay 5
                                    |-- /cast ${TwistMed}
                                    |-- /delay 10
                                    |-- /while (${Window[CastingWindow].Open}) {
                                        |-- /delay 5
                                    |-- }
                                    |-- /varset SittingDown 0
                                    |-- /varset IAmMedding 1
                                |-- }
                            |-- }
                        |-- } else {
                            |-- /if (!${Twist} || ${Twist.List.Left[-1].NotEqual[${TwistMed}]}) {
                                |-- /call CastBardCheck 0
                                |-- /squelch /twist ${TwistMed}
                                |-- /varset IAmMedding 1
                                |-- /delay 10
                            |-- }
                        |-- }
                        |-- /if (!${Me.Mount.ID} && ${Me.Standing} && !${Twist}) {
                            |-- /if (!${SittingDown}) {
                                |-- /sit
                                |-- /varset SittingDown 1
                                |-- /varset IAmMedding 1
                                |-- /delay 10
                            |-- } else /if (${SittingDown}==1 && ${Me.Standing}) {
                                |-- /echo I sat you down, but you are no longer sitting.
                                |-- /echo You have something outside of Kissassist standing you.
                                |-- /varset SittingDown 2
                            |-- }
                        |-- }
                    |-- }
                    DEBUGN ${MedStat} ${MedStat1} ${MedStat2} ${MedFlag} ${p_UseFlag} ${MeddingInterrupted}
                    /delay 10
                    /if (!${MedCombatCK}) {
                        /doevents AttackCalled
                        DEBUGN MedCombat1 ${CalledTargetID} ${Group.Member[${MainAssist}].Index} ${IAmMA} ${Me.XTarget[${XTSlot}].TargetType}
                        /if (${CalledTargetID} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && ${Spawn[${CalledTargetID}].Type.NotEqual[PC]}) {
                            /squelch /target id ${CalledTargetID}
                            /delay 10
                            /if (${XTarAutoSet}) {
                                /xtarget set ${XTSlot} currenttarget
                                /delay 10
                            }
                            /varset CalledTargetID 0
                        }
                        /call WaitSubs ${MedOn}
                        /if (${SittingDown} && ${Me.Standing}) {
                            /echo You stood up while you were waiting. Will sit you back down!
                            /varset SittingDown 0
                            /varset IAmMedding 0
                        }
                        DEBUGN MedCombat2 ${CalledTargetID} ${Group.Member[${MainAssist}].Index} ${IAmMA} ${Me.XTarget[${XTSlot}].TargetType}
                        /if (${CalledTargetID} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && ${Spawn[${CalledTargetID}].Type.NotEqual[PC]}) {
                            /squelch /target id ${CalledTargetID}
                            /delay 10
                            /if (${XTarAutoSet}) {
                                /xtarget set ${XTSlot} currenttarget
                                /delay 10
                            }
                            /varset CalledTargetID 0
                        }
                        /if (${AggroTargetID} && (${SpawnCount[xtarhater radius 150]} || ${MeleeTwistOn}==2 || ${Int[${Me.XTarget[${XTSlot}].Distance}]}<150)) {
                            /if (!${Me.Mount.ID} && ${Me.Sitting}) {
                                /stand
                            }
                            /varset Medding 0
                            /if (${IAmABard}) {
                                /call CastBardCheck
                                /if (${MeleeTwistOn}==2) /call DoBardStuff
                            }
                            | May need to add check to call DoBardStuff to get meletwist started.
                            /if (${Med2On}) /varset MedStat ${MedStat1}
                            /return
                        }
                    } else {
                        /if (${AutoRezOn}) /call RezCheck all
                        /if (${SittingDown} && ${Me.Standing}) {
                            /echo You stood up while you were waiting. Will sit you back down!!
                            /varset SittingDown 0
                            /varset IAmMedding 0
                        }
                        DEBUGN MedCombat3 ${MedCombatCK} ${MedCombat} ${p_UseFlag} ${MedForceOn} ${MedStat} ${Me.Pct${MedStat}} ${MedStop}
                    }
                    /if (!${p_UseFlag}) {
                        /if (${MedForceOn} && (!${Group.MainAssist.ID} || !${Group.MainAssist.Sitting})) /varset MedForceOn 0
                        /if (${Me.Pct${MedStat}}>=${MedStop} && !${MedForceOn}) /break
                    } else {
                        /if (${p_UseFlag}==1) {
                            /if (!${PullWaitTimer1}) {
                                /varset PullWaitRemaining 0
                                /break
                            } else {
                                /varset PullWaitRemaining ${PullWaitTimer1}
                            }
                        } else /if (${p_UseFlag}==2 && ${p_watchID}) {
                            /if (${Spawn[id ${p_watchID}].ID} && ${Target.ID}!=${p_watchID}) {
                                /squelch /target id ${p_watchID}
                                /delay 20
                            } else /if (!${Spawn[id ${p_watchID}].ID}) {
                                /echo Character ${watchName} Left the zone. Leaving Med Routine.
                                /break
                            }
                            /if (${Target.Pct${p_stat}}>=${p_resume}) /break
                        }
                    }
                }
                | Done Medding
                /if (${Med2On}) /varset MedStat ${MedStat1}
                /if (${Me.Sitting} && ${Me.Pct${MedStat}}>=${Math.Calc[${MedStop}-5]}) {
                    /stand
                }
                /if (${IAmABard}) {
                    /call CastBardCheck
                    /if (${MedleyOn}) /squelch /medley "${MedleyName}" -quiet
                }
            }
            /varset Medding 0
            /if (${MeddingInterrupted}<6) /varset MeddingInterrupted 0
            /varset SittingDown 0
            | return if using timer or watching another character.
            /if (${p_UseFlag}) /return
            /if (${Select[${Role},pullerpettank,puller,hunter,hunterpettank]} && ${Me.PctHPs}<=50) {
                /echo Medding to 100% health
                /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    /call DoWeMove 0 dowemed
                }
                /varset Medding 1
                /if (!${Me.Mount.ID} && ${Me.Standing} && !${Me.Moving} && !${SittingDown}) {
                    /sit
                    /varset SittingDown 1
                    /delay 10
                }
                /varset MeddingInterrupted 6
                /while (1) {
                    /doevents
                    /delay 5
                    /if (!${MedCombatCK}) {
                        /call WaitSubs
                        /if (${AggroTargetID}) {
                            /if (${DPSOn} || ${MeleeOn}) {
                                /call CheckForCombat 0 DoWeMed3 0
                            } else {
                                /call CheckForCombat 1 DoWeMed4 0
                            }
                            /varset Medding 0
                            /return
                        }
                    }
                    /if  (${Me.PctHPs}>=${MedStop}) {
                        /varset Medding 0
                        /break
                    }
                }
                /varset MeddingInterrupted 0
                /if (!${Me.Mount.ID} && ${Me.Sitting}) {
                    /stand
                    /varset SittingDown 0
                }
            }
            /if (${Select[${Role},pullerpettank,hunterpettank]} && !${Me.Invis} && (${Me.Pet.PctHPs}<=50 || ${PetForceHealOnMed})) {
                | Check pet is at full health before pulling.
                /echo Waiting on pet to full health before next pull
                | Might want to add to make the pet sit to help with recovery.
                /if (${Me.Pet.ID} && ${Me.Pet.PctHPs}<${MedStop}) {
                    /while (1) {
                        /for j ${SingleHeal.Size} downto 1
                            /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /continue
                            /if (${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) {
                                DEBUGN \amDEBUG DoPetMedStuff (${SingleHeal[${j}].Arg[3,|].Find[PET]} && ${Me.Pet.PctHPs} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range})
                                /call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Med 0 0
                                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                    /call BroadCast o "${Heals[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} <<"
                                    /varcalc PetHealTimer${j} ${Spell[${SingleHeal[${j}].Arg[1,|]}].MyDuration.TotalSeconds}*10
                                }
                                /break
                            }
                        /next j
                        /if (!${Me.Pet.ID} || ${Me.Pet.PctHPs}>=${MedStop} || ${AggroTargetID}) /break
                    }
                }
            }
        }
        DEBUGN DoWeMed Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckBuffs
| -------------------------------------------------------------------------------------
    Sub CheckBuffs(int ForceGroup)
        /if (!${BuffsOn} || ${IAmDead} || ${Me.Hovering} || (${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || (${ChaseAssist} && ${Me.Moving}) || (${Me.Moving} && ${WhoToChase.Equal[${Me}]})) /return
        DEBUGBUFF CheckBuffs CheckBuffs: Enter
        /declare i                int     local 0
        /declare j                int     local 0
        /declare k                int     local 0
        /declare l                int     local 0
        /declare FullText         string  local 0
        /declare 2ndPart          string  local 0
        /declare 3rdPart          string  local 0
        /declare 4thPart          string  local 0
        /declare 5thPart          string  local 0
        /declare 6thPart          string  local 0
        /declare 7thPart          string  local 0
        /declare SpellRange       int     local 0
        /declare SpellToCast      string  local null
        /declare MATargetID       int     local 0
        /declare i_TargetID       int     local 0
        /declare BookSpellTT      string  local 0
        /declare BuffToCheck      string  local null
        /declare CondNo           int     local 0
        /declare PeersZone        string  local
        /if (${PowerSource.NotEqual[NULL]} && ${Bool[${Me.Inventory[powersource].Name.Length}]} && !${Me.Inventory[powersource].Power}) {
           /call CheckCursor CheckBuffs0 0
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /if (${Cursor.Name.Equal[${PowerSource}]}) /destroy
           /delay 5s !${Cursor.ID}
        }
        |--------- Change to add Zone.Outdoor TLO and specific Zone.Type to stop mount cast spam.
        /if (${MountOn} && !${Me.Mount.ID} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]}) && ${Me.CombatState.NotEqual[COMBAT]}) /call CastMount
        | Call Buffs Array
        /if (${Zone.ShortName.Find[_]}) {
            /varset PeersZone zone_${Zone.ShortName}
        } else {
            /varset PeersZone zone_${EverQuest.Server.Lower}_${Zone.ShortName}
        }
        /for i 1 to ${Buffs.Size}
            /if (${Me.Invis}) /return
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            /if (${CalledTargetID} && !${AggroTargetID}) /call CombatTargetCheck 0
            /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
            /if (${Buffs[${i}].Find[|0]}) /continue
            /if (${ChaseAssist} && !${CombatStart}) /call DoWeChase
            /if (${CuresOn}) {
                /call CheckCures Combat
            } else /if (${HealsOn}) {
                /if (!${LastHealCheck}) {
                    /call CheckHealth CheckBuffs
                    /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                }
            } else /if (${AutoRezOn}) {
                /call RezCheck group
            }
            | If Buffs=NULL skip to next buff
            /if (${Buffs[${i}].Equal[null]}) /continue
            | Check for combat and skip redundant subs called in combat routines.
            DEBUGBUFF CheckBuffs Buff${i}: ${Buffs[${i}]}
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to the buff
            /if (${Buffs[${i}].Arg[2,|].Length}) {
                /varset FullText ${Buffs[${i}]}
                /varset SpellToCast ${Buffs[${i}].Arg[1,|]}
                /varset 2ndPart ${Buffs[${i}].Arg[2,|]}
                /varset 3rdPart ${Buffs[${i}].Arg[3,|]}
                /varset 4thPart ${Buffs[${i}].Arg[4,|]}
                /varset 5thPart ${Buffs[${i}].Arg[5,|]}
                /if (${2ndPart.Equal[Dual]}) {
                    /if (${4thPart.Equal[MA]}) {
                        /varset 2ndPart DualMA
                    } else /if (${4thPart.Equal[melee]}) {
                        /varset 2ndPart DualMelee
                    } else /if (${4thPart.Equal[caster]}) {
                        /varset 2ndPart DualCaster
                    } else /if (${4thPart.Equal[class]}) {
                        /varset 2ndPart DualClass
                    } else /if (${4thPart.Equal[!class]}) {
                        /varset 2ndPart Dual!Class
                    } else /if (${4thPart.Equal[mgb]}) {
                        /varset 2ndPart DualMgb
                    } else /if (${4thPart.Equal[me]}) {
                        /varset 2ndPart Dualme
                    }
                } else /if (${2ndPart.Equal[class]}) {
                    /varset 5thPart ${3rdPart}
                } else /if (${2ndPart.Equal[!class]}) {
                    /varset 5thPart ${3rdPart}
                } else /if (${2ndPart.Equal[alias]}) {
                    /continue
                } else /if (${2ndPart.Left[4].Equal[cond]}) {
                    /varset 2ndPart
                }
            } else {
                /varset FullText ${Buffs[${i}]}
                /varset SpellToCast ${Buffs[${i}]}
                /varset 2ndPart
                /varset 3rdPart
                /varset 4thPart
                /varset 5thPart
            }
            /if (${Me.Subscription.NotEqual[gold]}) {
                /if (${Select[${2ndPart},Dual,DualMA,DualMelee,DualCaster,DualClass,Dual!Class,DualMgb,Dualme]}==0) {
                    /if (${SpellToCast.Find[ Rk.]}) {
                        /varset BuffToCheck ${SpellToCast.Left[${Math.Calc[${SpellToCast.Find[ Rk.]}-1]}]}
                    } else {
                        /varset BuffToCheck ${SpellToCast}
                    }
                } else {
                    /if (${3rdPart.Find[ Rk.]}) {
                        /varset BuffToCheck ${3rdPart.Left[${Math.Calc[${3rdPart.Find[ Rk.]}-1]}]}
                    } else {
                        /varset BuffToCheck ${3rdPart}
                    }
                }
            } else {
                /if (${Select[${2ndPart},Dual,DualMA,DualMelee,DualCaster,DualClass,Dual!Class,DualMgb,Dualme]}==0) {
                    /varset BuffToCheck ${SpellToCast}
                } else {
                    /varset BuffToCheck ${3rdPart}
                }
            }
            DEBUGBUFF CheckBuffs 1st:${SpellToCast} 2nd: ${2ndPart} #rd: ${3rdPart} ${BuffToCheck} 4th: ${4thPart}
            /if (${Me.Book[${SpellToCast}]}) {
                /varset BookSpellTT ${Spell[${Me.Book[${Me.Book[${SpellToCast}]}].ID}].TargetType}
            } else {
                /varset BookSpellTT 0
            }
            /if (${Int[${Spell[${SpellToCast}].Range}]}>=${Int[${Spell[${SpellToCast}].AERange}]}) {
                /varset SpellRange ${Spell[${SpellToCast}].Range}
            } else {
                /varset SpellRange ${Spell[${SpellToCast}].AERange}
            }
            /if (!${SpellRange}) /varset SpellRange 100
            DEBUGBUFF CheckBuffs ${i} 1st: ${SpellToCast} 2nd: ${2ndPart} FullText: ${Buffs[${i}]} Type: ${Spell[${SpellToCast}].TargetType} ReadBuffsTimer: ${ReadBuffsTimer} IniNextTimer: ${IniNextTimer}
            DEBUGBUFF CheckBuffs Skip if Combat: ${CombatStart}  Aggro: ${AggroTargetID} IDied: ${IAmDead} ReadBTimer: ${ReadBuffsTimer} Invised: ${Me.Invis}
            /if ((${Me.CombatState.Equal[COMBAT]} && ${AggroTargetID}) || ${CombatStart}) /return
            /if (${IAmDead} || ${Me.Invis} || ${ReadBuffsTimer}) /return
            | Conditions Check
            /if (${ConOn} && ${Buffs[${i}].Find[|cond]}) {
                /varset CondNo ${Buffs[${i}].Mid[${Math.Calc[${Buffs[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            | Check for Mana/End AA Regen on others
            DEBUGBUFF CheckBuffs Start of If Structure. ${SpellToCast} ${2ndPart} ${Spell[${SpellToCast}].Mana} ${Me.CurrentMana}
            /varset MacroReturn CAST_NO_RESULT
            /if (${Select[${2ndPart},Endgroup,Managroup]}>0) {
                /if (${Group}) {
                    /if (${2ndPart.Equal[Endgroup]}) {
                        /call RegenOther "${SpellToCast}" Endurance ${3rdPart} 0 ${CondNo}
                    } else /if (${2ndPart.Equal[Managroup]}) {
                        /call RegenOther "${SpellToCast}" Mana ${3rdPart} 0 ${CondNo}
                    }
                    /varset MacroReturn ${Macro.Return}
                    /if (${MacroReturn.Equal[TRUE]}) /varcalc Buff${i}GM0 (${Spell[${SpellToCast}].Duration.TotalSeconds})*10
                }
            } else /if (${2ndPart.Equal[mana]}) {
                /if (${Me.PctMana}>${3rdPart} || ${Me.PctHPs}<${Int[${4thPart}]}) /continue
                /call CastWhat "${SpellToCast}" ${Me.ID} Buffs ${CondNo} 0
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components. Turning off ${SpellToCast}.
                    /varset Buffs[${i}] NULL
                    /varset FullText NULL
                    /delay 10
                    /continue
                }
            | Combat check to skip all buffs but mana regen
            | Check and Cast endurance discs/AAs - 2nd wind, respite, etc
            } else /if (${2ndPart.Equal[End]}) {
                /if (${Me.PctEndurance}<=${3rdPart} && (${Me.CombatAbilityReady[${SpellToCast}]} || ${Me.AltAbilityReady[${SpellToCast}]})) /call CheckEndurance "${SpellToCast}" ${3rdPart} ${4thPart} ${CondNo}
            | Remove buff from |Remove tag
            } else /if (${2ndPart.Equal[Remove]} && (${Me.Buff[${SpellToCast}].ID} || ${Me.Song[${SpellToCast}].ID})) {
                /if (!${CondNo} || ${If[${Cond[${CondNo}]},1,0]}) {
                    /echo Removing Buff: ${SpellToCast}
                    /removebuff "${SpellToCast}"
                }
            | If buff cost more mana than I have skip it
            } else /if (${2ndPart.NotEqual[begfor]} && ${Spell[${SpellToCast}].Mana} && ${Spell[${SpellToCast}].Mana}>${Me.CurrentMana}) {
                /continue
            | Check if aura is up
            } else /if (${2ndPart.Equal[Aura]}) {
                /call CheckAura "${SpellToCast}" ${CondNo}
            | Check for |Once tag and turn buff off is cast is successful
            } else /if (${2ndPart.Equal[Once]}) {
                /call BuffOnce "${SpellToCast}" ${CondNo}
                /if (${Macro.Return.Equal[TRUE]}) {
                    /varset Buffs[${i}] ${SpellToCast}|0
                    /echo Buffing Once with ${SpellToCast}.
                }
            | Summon items ini example Buffs1=The Guardian's Pouch|Summon|Guardian Blade|200
            } else /if (${2ndPart.Equal[Summon]}) {
                /if (${FindItemCount[=${3rdPart}]}<${4thPart}) /call SummonStuff "${SpellToCast}" "${3rdPart}" ${4thPart} ${CondNo}
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components. Turning off ${SpellToCast}.
                    /varset Buffs[${i}] NULL
                    /varset FullText NULL
                }
            } else /if (${Select[${2ndPart},mgb,dualmgb]}>0 && !${Me.Buff[${BuffToCheck}].ID}) {
                /call MassGroupBuff "${SpellToCast}" ${i} ${CondNo}
            } else /if (${2ndPart.Equal[begfor]} && !${Buff${i}GM0}) {
                | this is only run for the beggar when begging.
                /if (${Int[${3rdPart}]}>0 && ${4thPart.Equal[alias]}) {
                    | Add condition check for begfor
                    /if (${CondNo} && ${If[${Cond[${CondNo}]},0,1]}) /continue
                    /if (${Select[${5thPart},BEGFORITEMS]}>0) {
                        /if (${FindItemCount["=${SpellToCast}"]}<${3rdPart}) {
                            |"#*# KABeg for #1# #2#"
                            /call BroadCast o "KABeg for ${Me.CleanName} ${5thPart} 0"
                            /varset Buff${i}GM0 900
                        }
                    } else /if (${Select[${5thPart},BEGFORBUFFS]}>0) {
                        /if (!${Me.Buff[${SpellToCast}].ID}) {
                            /call BroadCast o "KABeg for ${Me.CleanName} ${5thPart} 0"
                            /varset Buff${i}GM0 900
                        }
                    } else {
                        /echo Invalid Option ${5thPart} for Alias. Turning Option off.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                    }
                }
            | Check for Command: tag
            } else /if (${SpellToCast.Find[command:]}) {
                /varset i_TargetID ${Int[${Target.ID}]}
                /call TargetTag "${FullText}"
                /call CastWhat "${SpellToCast}" ${Macro.Return} Buffs ${CondNo} 0
                /continue
            }
            DEBUGBUFF CheckBuffs End of If Structure. ${2ndPart}
            | Everything above is for self/group only can skip to end if 2ndPart is in list below. mana and end are exceptions.
            /if (${Select[${2ndPart},Aura,Mount,Summon,Endgroup,Managroup,Once,Remove,Mana,End,mgb,dualmgb,begfor]}) /continue
            DEBUGBUFF CheckBuffs BuffSlot: !${Int[${Me.Buff[${BuffToCheck}].ID}]} SongSlot: ${Int[${Me.Song[${BuffToCheck}].ID}]} Stacks: ${Spell[${SpellToCast}].WillLand} 2nd Part: ${Select[${2ndPart},Aura,Mount,Summon,Endgroup,Managroup,Once,Remove]}<1 Tar Type: ${Spell[${SpellToCast}].TargetType}
            DEBUGBUFF CheckBuffs Find 0: ${BookSpellTT.Find[0]} Spell TT: ${Spell[${SpellToCast}].TargetType.Find[single]} BookTT: ${BookSpellTT.Find[single]} Medding: ${Medding} MedCombat: ${MedCombat}
            | Cast buffs on MA && ${Spell[${Buffs[${i}]}].TargetType.Find[self]}
            /if (${Select[${2ndPart},MA,DualMA]}) {
                DEBUGBUFF CheckBuffs MA/DualMA Tag: ${2ndPart} ${Spawn[=${MainAssist}].ID} ${Buff${i}GM7}
                /if (${Spawn[=${MainAssist}].Distance}<=${SpellRange} && ${Spawn[=${MainAssist}].ID} && ${Buff${i}GM7}==0) {
                    DEBUGBUFF Cast buffs with MA tag ${Buffs[${i}]}
                    | Check buffs in file to see if MA has buff or its blocked
                    /if (${MainAssist.NotEqual[${Me}]}) {
                        /if (!${DanNetOn}) {
                            /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Blockedbuffs"].Find[${BuffToCheck}]}) /continue
                            /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Buffs"].Find[${BuffToCheck}]}) /continue
                        } else /if (${DanNet.Peers[${PeersZone}].Find[${MainAssist}|]}) {
                            /dquery ${MainAssist} -q "Me.BlockedBuff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${MainAssist} -q "Me.Buff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                        } else {
                            /continue
                        }
                    } else {
                        /if (${Me.BlockedBuff[${BuffToCheck}].ID}) /continue
                        /if (${Me.Buff[${BuffToCheck}].ID}) /continue
                    }
                    | If its a group spell cast on mercs - owner
                    /if (${Spawn[=${MainAssist}].Type.Equal[mercenary]} && ${Spell[${SpellToCast}].TargetType.Find[group v]}) {
                        /varset MATargetID ${Spawn[=${MainAssist}].Owner.ID}
                    } else /if (${Select[${Role},hunterpettank,pettank,pullerpettank]} ) {
                        /varset MATargetID ${Me.Pet.ID}
                    } else {
                        /varset MATargetID ${Spawn[=${MainAssist}].ID}
                    }
                    /if (${Cursor.ID}) /call CheckCursor CheckBuffs1 0
                    DEBUGBUFF CheckBuffs: MA Buff CastWhat "${SpellToCast}" ${MATargetID} Buffs ${CondNo}
                    /call CastWhat "${SpellToCast}" ${MATargetID} Buffs-nomem ${CondNo} 0
                    DEBUGBUFF CheckBuffs: MA Buff MacroReturn: ${Macro.Return}
                    /if (${Macro.Return.Equal[CAST_SUCCESS]} || (!${Spawn[${MainAssistType} ${MainAssist} group].ID} && ${Macro.Return.Equal[CAST_TAKEHOLD]})) {
                        /echo Buffing MA >> ${Spawn[=${MainAssist}].CleanName} << with ${SpellToCast}.
                        /varcalc Buff${i}GM7 ${Spell[${BuffToCheck}].MyDuration.TotalSeconds}*10
                        DEBUGBUFF CheckBuffs MA Buff Timer ${Buff${i}GM7}
                        /if (${MATargetID}==${Me.ID}) {
                            /varset WriteBuffsTimer 0
                            /call WriteBuffs
                        }
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_HASBUFF]}) {
                        /varcalc Buff${i}GM7 ${HasBuffDuration}*10
                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /continue
                    }
                } else {
                    /continue
                }
            | Check if buff is up and if it stacks with existing buffs
            | What about checking the timer for the buff and not the buff. Then use DanNet to see if the buff is on the other character.
            | If not using DanNet then we could check the Buff Timer to tell if to buff or not. This will cause the caster to target all the characters to set the bufftimers the first time through
            | ${MacroQuest.InternalName.Equal[next]} or ${MacroQuest.InternalName.Equal[redguides]}
            |} else /if (BuffsNotAnItem && (${ForceGroup} || (!${Int[${Me.Buff[${BuffToCheck}].ID}]} && !${Int[${Me.Song[${BuffToCheck}].ID}]} && ${Spell[${SpellToCast}].WillLand}))) {
            } else /if (BuffsNotAnItem && (${ForceGroup} || (!${Int[${Me.Buff[${BuffToCheck}].ID}]} && !${Int[${Me.Song[${BuffToCheck}].ID}]}))) {
            |} else /if (BuffsNotAnItem) {
                DEBUGBUFF CheckBuffs -- 2nd asssigned: ${SpellToCast} TargetType: ${Spell[${SpellToCast}].TargetType} ${ForceGroup} ${DanNetOn}
                |/if (!${ForceGroup}) {
                    |/if (${DanNetOn} && ${Group}) {
                    |    /for j 1 to ${Group}
                    |        /if (${DanNet.Peers[${PeersZone}].Find[${Group.Member[${j}]}|]}) {
                    |            /dquery ${Group.Member[${j}]} -q "Me.Buff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                    |            /if (${Bool[${DNout}]}) /continue
                    |            /dquery ${Group.Member[${j}]} -q "Me.Song[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                    |            /if (${Bool[${DNout}]}) /continue
                    |            /dquery ${Group.Member[${j}]} -q "Me.BlockedBuff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                    |            /if (${Bool[${DNout}]}) /continue
                    |            /dquery ${Group.Member[${j}]} -q "Spell[${SpellToCast}].WillLand" -o DNout -t ${DanNetDelay}
                    |            /if (!${Bool[${DNout}]}) /continue
                    |            /varset Buff${i}GM${j} 0
                    |            /varset ForceGroup 1
                    |        }
                    |    /next j
                    |} else {
                    |    /if (${Int[${Me.Buff[${BuffToCheck}].ID}]} || ${Int[${Me.Song[${BuffToCheck}].ID}]} || !${Spell[${SpellToCast}].WillLand}) /continue
                    |    /if (${Group}) /varset ForceGroup 1
                    |}
                    |/if (!${ForceGroup} && ${Group}) /continue
                |}
                | If Target.Type=Group then buff self with group buff
                /if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[group v]}) || ${BookSpellTT.Find[group v]}) {
                    /if (${Cursor.ID}) /call CheckCursor CheckBuffs2 0
                    /while (1) {
                        /varset EventFlag 0
                        /doevents WornOff
                        /if (!${EventFlag}) /break
                    }
                    |Added to skip group buffs that won't land(TakeHold) on the caster.
                    /if (${Buff${i}GM0}) /continue
                    /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem ${CondNo} 0
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Buffing >> ${SpellToCast} <<
                        /doevents flush WornOff
                        /varset WriteBuffsTimer 0
                        /call WriteBuffs
                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
                        /echo Buffing >> ${SpellToCast} << TH
                        /varcalc Buff${i}GM0 ${Spell[${BuffToCheck}].MyDuration.TotalSeconds}*10
                    }
                    /if (${ForceGroup}) {
                        /while (${Me.SpellInCooldown}) {
                            /delay 5
                        }
                        /continue
                    }
                | If Target.Type=Single then buff each party member with single buff
                } else /if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[single]}) || ${BookSpellTT.Find[single]}) {
                    |/if (${Buff${i}GM0}) /varset Buff${i}GM0 0
                    /if (${Group}) {
                        |/if (${Me.CurrentMana}>=${Math.Calc[${Spell[${SpellToCast}].Mana}*${Group}]}) {
                        |/if (${Me.CurrentMana}>=${Spell[${SpellToCast}].Mana}) {
                            DEBUGBUFF CheckBuffs Single Type Group Buff
                            /for j ${Group} downto 0
                                |/echo ${j} ${Buff${i}GM${j}}
                                DEBUGBUFF CheckBuffs !${Group.Member[${j}].ID} ${Spawn[${Group.Member[${j}]}].Distance} ${SpellRange} ${2ndPart.Equal[Me]} ${j}>=1 ${2ndPart.Equal[MA]} ${Group.Member[${j}].ID}!=${Spawn[${MainAssistType} ${MainAssist}].ID} ${Buff${i}GM${j}} ${Me.Invis}
                                /if (${Me.Invis}) /break
                                | Check if party member is alive in zone and within spell range and spell timer does not exist
                                /if (!${Group.Member[${j}].ID} || ${Spawn[${Group.Member[${j}]}].Distance}>=${SpellRange} || ${Buff${i}GM${j}}) /continue
                                /if (${Select[${2ndPart},me,dualme]} && ${j}>0) /continue
                                /if (${Me.CurrentMana}<${Spell[${SpellToCast}].Mana}) /break
                                DEBUGBUFF CheckBuffs 3 ${2ndPart.Equal[caster]} ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]} ${2ndPart.Equal[Melee]} ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}
                                /if ((${Select[${2ndPart},caster,DualCaster]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${Select[${2ndPart},Melee,DualMelee]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /continue
                                /if (${Select[${2ndPart},class,dualclass]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},${5thPart}]}==0) /continue
                                /if (${Select[${2ndPart},!class,dual!class]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},${5thPart}]}>0) /continue
                                /if (${Select[${2ndPart},MA,Dualma]}>0 && ${Group.Member[${j}].ID}!=${Spawn[${MainAssistType} ${MainAssist}].ID}) /continue
                                /if (${2ndPart.Equal[!MA]} && ${Group.Member[${j}].ID}==${Spawn[${MainAssistType} ${MainAssist}].ID}) /continue
                                /if (${Cursor.ID}) /call CheckCursor CheckBuffs3 0
                                /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) {
                                    /return
                                } else /if (${Me.Gem[${SpellToCast}]}) {
                                    /if (${Me.GemTimer[${SpellToCast}].TotalSeconds}>6) /continue
                                    /while (!${Me.SpellReady[${SpellToCast}]}) {
                                        /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
                                        /delay 5
                                    }
                                }
                                /while (1) {
                                    /varset EventFlag 0
                                    /doevents WornOff
                                    /if (!${EventFlag}) /break
                                }
                                /call CastWhat "${SpellToCast}" ${Group.Member[${j}].ID} Buffs-nomem ${CondNo} 0
                                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                    /echo Buffing ${SpellToCast} on ${Group.Member[${j}].CleanName}
                                    /varcalc Buff${i}GM${j} ${Spell[${BuffToCheck}].MyDuration.TotalSeconds}*10
                                    /doevents flush WornOff
                                    /if (${j}==0) {
                                        /varset WriteBuffsTimer 0
                                        /call WriteBuffs
                                    }
                                } else /if (${Macro.Return.Equal[CAST_HASBUFF]}) {
                                    /varcalc Buff${i}GM${j} ${HasBuffDuration}*10
                                } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                                    /echo You are missing components. Turning off ${SpellToCast}.
                                    /varset Buffs[${i}] NULL
                                    /varset FullText NULL
                                    /continue
                                }
                                /if (${BuffsOn}==1) /continue
                                /if (${Select[${Group.Member[${j}].Class.ShortName},CLR,PAL,WIZ,BRD,BER,MNK,ROG,RNG,WAR]}) /continue
                                /if (${DanNetOn} && ${Group.Member[${j}].Pet.ID}) {
                                    /if (!${DanNet.Peers[${PeersZone}].Find[${Group.Member[${j}]}|]}) /continue
                                    /dquery ${Group.Member[${j}]} -q "Me.BlockedPetBuff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                                    /if (${Bool[${DNout}]}) /continue
                                    /dquery ${Group.Member[${j}]} -q "Me.Pet.Buff[${BuffToCheck}]" -o DNout -t ${DanNetDelay}
                                    /if (${Bool[${DNout}]}) /continue
                                    /dquery ${Group.Member[${j}]} -q "Spell[${BuffToCheck}].StacksPet[0]" -o DNout -t ${DanNetDelay}
                                    /if (!${Bool[${DNout}]}) /continue
                                    /dquery ${Group.Member[${j}]} -q "Me.Pet.Name" -o DNout -t ${DanNetDelay}
                                    /if (!${Bool[${DNout}]}) /continue
                                    /while (1) {
                                        /varset EventFlag 0
                                        /doevents WornOff
                                        /if (!${EventFlag}) /break
                                    }
                                    /while (${Me.SpellInCooldown}) {
                                        /delay 5
                                    }
                                    /call CastWhat "${SpellToCast}" ${DNout} Buffs-nomem ${CondNo} 0
                                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                        /echo Buffing ${SpellToCast} on ${Group.Member[${j}].CleanName} Pet ${DNout}
                                        |Have to create a different timer for group pets.
                                        /doevents flush WornOff
                                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                                        /echo You are missing components. Turning off ${SpellToCast}.
                                        /varset Buffs[${i}] NULL
                                        /varset FullText NULL
                                        /continue
                                    }
                                }
                            /next j
                        |} else {
                        |    /continue
                        |}
                    } else /if (${Select[${2ndPart},MA,Melee,Caster,DualMA,DualMelee,DualCaster,class,!class,dualclass,dual!class]}==0) {
                        DEBUGBUFF CheckBuffs 4 ${2ndPart}
                        /if (${Cursor.ID}) /call CheckCursor CheckBuffs4 0
                        /while (1) {
                            /varset EventFlag 0
                            /doevents WornOff
                            /if (!${EventFlag}) /break
                        }
                        /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem ${CondNo} 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /echo Buffing ${SpellToCast} on ${Group.Member[${j}].CleanName}
                            /varcalc Buff${i}GM0 ${Spell[${BuffToCheck}].MyDuration.TotalSeconds}*10
                            /doevents flush WornOff
                            /varset WriteBuffsTimer 0
                            /call WriteBuffs
                        } else /if (${Macro.Return.Equal[CAST_HASBUFF]}) {
                            /varcalc Buff${i}GM0 ${HasBuffDuration}*10
                        } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                            /echo You are missing components. Turning off ${SpellToCast}.
                            /varset Buffs[${i}] NULL
                            /varset FullText NULL
                            /varset SpellToCast
                            /continue
                        }
                    }
                | If Target.Type=self then buff self
                } else /if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[self]}) || ${BookSpellTT.Find[self]}) {
                    DEBUGBUFF CheckBuffs Self Buff ${Me.Buff[${BuffToCheck}].ID} ${Me.Song[${BuffToCheck}].ID} ${Spell[${BuffToCheck}].WillLand}
                    /if (${Me.Buff[${BuffToCheck}].ID} || ${Me.Song[${BuffToCheck}].ID} || !${Spell[${BuffToCheck}].WillLand}) /continue
                    /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem ${CondNo} 0
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Casting ${SpellToCast} on me.
                        /delay 10
                    }
                | Check if buff needs pet as target ie Mage's Symbiosis line of mana buffs
                } else /if (${Me.Pet.ID} && (${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[pet]} || ${Select[${Spell[${Spell[${SpellToCast}].ID}].Name.Arg[2,]},Symbiosis,Siphon,Simulacrum,Draw]})) {
                    DEBUGBUFF CheckBuffs Self Buff that targets pet ie mage mana buff line
                    /call CastWhat "${SpellToCast}" ${Me.Pet.ID} Buffs ${CondNo} 0
                }
                | If buff is an item click it
            } else /if (${FindItem[=${SpellToCast}].Spell.WillLand} && !${Int[${Me.Buff[${BuffToCheck}].ID}]} && ${Me.ItemReady[${SpellToCast}]} && ${Select[${2ndPart},Aura,Mount,Mana]}==0) {
                DEBUGBUFF CheckBuffs Items
                /if (${Me.Buff[${BuffToCheck}].ID} || ${Me.Song[${BuffToCheck}].ID}) /continue
                /if (!${Me.Invis}) {
                    | Call of the wild ear fix
                    /if (${SpellToCast.Equal[Call of the Wild]}) {
                        /useitem "Call of the Wild"
                        /delay 15
                    } else {
                        /call CastWhat "${SpellToCast}" ${Me.ID} Buffs ${CondNo} 0
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Clicking > ${SpellToCast} <
                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /continue
                    }
                }
            }
            DEBUGBUFF CheckBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${SpellToCast}]}>=1 Self:${Spell[${SpellToCast}].TargetType.Find[self]}
            | If Buff is a Mana,Aura,Mount,Me,dualme,Summon,End, an item, self buff or Spawn ID is me skip ini check because none of these are cast on others
            /if (${Select[${2ndPart},me,dualme]} || ${Me.Invis}) /continue
            /if ((${FindItemCount[=${SpellToCast}]}>=1 && ${Spell[${SpellToCast}].TargetType.Equal[self]}) || (${FindItemCount[${SpellToCast}]}>=1 && ${Spell[${BuffToCheck}].TargetType.Equal[self]}) || (${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[self]}) || ${BookSpellTT.Find[self]} || ${BookSpellTT.Find[pet]}) /continue
            /if (${Redguides} && !${IniNextTimer} && !${CombatStart}) /call CheckiniBuffs "${SpellToCast}" ${i} ${SpellRange} "${BuffToCheck}" "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" "${BookSpellTT}" ${CondNo}
            DEBUGBUFF CheckBuffs reset var ${i} ${Buffs[${i}]}
        /next i
        /if (${PowerSource.NotEqual[NULL]} && !${Bool[${Me.Inventory[powersource].Name.Length}]} && ${FindItemCount[=${PowerSource}]}) {
            /exchange "${PowerSource}" powersource
            /if (${FindItem[=${PowerSource}].Attuneable}) {
                /delay 20 ${Window[confirmationdialogbox].Open}
                /if (${Window[confirmationdialogbox].Open}) {
                    /notify confirmationdialogbox CD_Yes_Button leftmouseup
                    /delay 20 !${Window[confirmationdialogbox].Open}
                }
            }
        }
        /if (!${ReadBuffsTimer} && !${AggroTargetID}) /varset ReadBuffsTimer ${CheckBuffsTimer}s
        /if (${Macro.RunTime}>120 && !${IniNextTimer}) /varset IniNextTimer 30s
        /if (${MiscGemRemem} && (${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscSpell}]} || ${ReMemCastLW})) {
            /varset DontMoveMe 1
            /varset ReMemCast 1
            /call CastReMem "${ReMemMiscSpell}" 1 buffs
            /varset DontMoveMe 0
        }
        DEBUGBUFF CheckBuffs Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: TargetTag
| -------------------------------------------------------------------------------------
    Sub TargetTag(TargetTagText)
        /declare TagReturn string local
        /if (${TargetTagText.Find[|pet]}) {
            /varset TagReturn ${Pet.ID}
        } else /if (${TargetTagText.Find[|me]}) {
            /varset TagReturn ${Me.ID}
        } else /if (${TargetTagText.Find[|ma]}) {
            /varset TagReturn ${MainAssistID}
        } else {
            /varset TagReturn 0
        }
    /return ${TagReturn}
| -------------------------------------------------------------------------------------
| SUB: BuffOnce
| -------------------------------------------------------------------------------------
    Sub BuffOnce(OnceSpell, int CondNumber)
        /if (${Me.Invis}) /return
        /declare OnceResult string local FALSE
        /if (!${CondNumber} || ${If[${Cond[${CondNumber}]},1,0]}) {
            /call CastWhat "${OnceSpell}" ${Me.ID} BuffOnce 0 0
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /varset OnceResult TRUE
            } else {
                /varset OnceResult ${Macro.Return}
            }
        }
    /return ${OnceResult}
| -------------------------------------------------------------------------------------
| SUB: CheckAura | Check if aura is up
| -------------------------------------------------------------------------------------
    Sub CheckAura(AuraSpell, int CondNumber)
        /if (${Me.Invis}) /return
        DEBUGBUFF CheckAura Spell: ${AuraSpell} Enter
        /declare AuraName string local
        /declare TempAura string local
        /declare AuraResult string local FALSE
        | Strip the Rk II/III out of the spell to check against aura window
        /if (${AuraSpell.Find[ Rk.]}) {
            /varset AuraName ${AuraSpell.Left[${Math.Calc[${AuraSpell.Find[ Rk.]}-1]}]}
        } else {
            /varset AuraName ${AuraSpell}
        }
        /if (${AuraSpell.Find[Disciple's Aura]}) {
        | Correct typo from SOE in monks 55 level aura
            /varset AuraName Disciples Aura
        } else /if (${Me.Class.Name.Equal[cleric]} && ${AuraSpell.Find[Reverent]}) {
            | Cleric exception for Reverent Aura
            /varset AuraName Reverent Aura
	} else /if (${AuraSpell.Find[Beguiler's Aura]}) {
            | Enchanter exception for Beguiler's Aura
            /varset AuraName Beguilers Aura
        } else /if (${AuraSpell.Find[Mana Reiteration]}) {
            /varset AuraName Mana Recursion Aura
        } else /if (${AuraSpell.Find[Mana Reiterate]}) {
            /varset AuraName Mana Reiterate Aura
        } else /if (${AuraSpell.Find[Mana Reverberation]}) {
            /varset AuraName Mana Rev.
        } else /if (${AuraSpell.Find[Mana Resurgence]}) {
            /varset AuraName Mana Resurgence Aura
        } else /if (${AuraSpell.Find[Mana Repercussion Aura]}) {
            /varset AuraName Mana Rep. Aura
        } else /if (${AuraSpell.Find[Runic Radiance Aura]}) {
            /varset AuraName Runic Rad. Aura
        } else /if (${AuraSpell.Find[Arcane Distillect]}) {
            | Mage exceptions because aura is on pet not in aura window and other fucked up shit
            /varset TempAura Arcane Distillect
        } else /if (${AuraSpell.Find[Earthen Strength]}) {
            /varset TempAura Earthen Strength Effect
        } else /if (${AuraSpell.Find[Rathe's Strength]}) {
            /varset TempAura Rathe's Strength Effect
        }
        | Check if aura is up 4 parts - Mage | Everyone else | 2 auras cleric | 2 auras enchamter
        /if (${Select[${Me.Class.ShortName},CLR,ENC,MAG]}==0 && ${Me.Aura[1].Name.Find[${AuraName}]}) {
            /return ${AuraResult}
        } else /if (${Me.Class.ShortName.Equal[MAG]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<175) {
            /if (${Me.Aura[1].Name.Find[${TempAura}]}) {
                /return ${AuraResult}
            } else /if (${Me.PetBuff[${TempAura}]}) {
                /return ${AuraResult}
            }
        } else /if (${Select[${Me.Class.ShortName},CLR,ENC]} && (${Me.Aura[1].Name.Find[${AuraName}]} || ${Me.Aura[2].Name.Find[${AuraName}]})) {
            /return ${AuraResult}
        }
        DEBUGBUFF CheckAura Aura
        | - Mutant Bards do this. Not any more.
        /if (!${CondNumber} || ${If[${Cond[${CondNumber}]},1,0]}) {
            | - Normal casting
            /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]} && ${Me.CurrentEndurance}>500) {
                /disc ${AuraSpell}
                /delay 10
                /while (${Me.Casting.ID} && ${Window[CastingWindow].Open}) {
                    /delay 5
                }
                /varset AuraResult TRUE
                /return ${AuraResult}
            } else {
                /varset DontMoveMe 1
                /call CastWhat "${AuraSpell}" ${Me.ID} CheckAura 0 0
                /varset DontMoveMe 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting Aura >> ${AuraSpell} <<
                    /varset AuraResult TRUE
                } else {
                    /varset AuraResult ${Macro.Return}
                }
            }
        }
    /return ${AuraResult}
| -------------------------------------------------------------------------------------
| SUB: CheckEndurance
| -------------------------------------------------------------------------------------
    Sub CheckEndurance(ESpell,EPct,EHealth,int CondNumber)
        /if (${Me.Invis}) /return
        /declare EndResult string local FALSE
        DEBUGBUFF CheckAura Enter Spell: ${ESpell} EndPct: ${EPct} HealthPct: ${EHealth}
        /if (${EHealth.Equal[null]} || !${EHealth.Length}) /varset EHealth 0
        DEBUGBUFF CheckAura Endurance Regen
        /if (${Me.Sitting}) /stand
        /call CastWhat "${ESpell}" ${Me.ID} CheckEndurance ${CondNumber} 0
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset EndResult TRUE
            /echo Casting >> ${ESpell} << for endurance
        } else {
            /varset EndResult ${Macro.Return}
        }
        DEBUGBUFF CheckAura Leave
    /return ${EndResult}
| -------------------------------------------------------------------------------------
| SUB: CheckIniBuffs
| -------------------------------------------------------------------------------------
    Sub CheckIniBuffs(SpellName, BuffsNum, int BuffRange, BuffName, 2ndPart, 3rdPart, 4thPart, 5thPart, BookTT, int CondNumber)
        DEBUGBUFF CheckIniBuffs Enter ${SpellName} ${BuffsNum} ${BuffRange} ${BuffName} ${2ndPart} ${3rdPart} ${4thPart} ${5thPart} ${BookTT} ${CondNumber} ${Me.Invis}
        /if (${Me.Invis}) /return
        /declare k int local
        /declare l int local
        | Assign var IniIDList all the spawn ids from buff ini file 2345|2195|2391| etc
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare SearchList string local
        /declare IniIDCount int local ${IniIDList.Count[|]}
        /declare SearchCount int local 0
        /declare IniBuffCount int local 0
        /declare IniBBuffList string local
        /declare IniBuffList string local
        /declare SearchBuffList string local
        /declare IniStackCheck[50] string local
        /declare PBTimerID string local
        /declare IniTempBuff string local
        /declare skipFlag int local 0
        /declare TryToBuffID int local 0
        /declare TryToBuffName string local
        /declare MercID int local 0
        /declare MercIDList string local
        /declare WhileFlag int local 1
        /while (${WhileFlag}) {
            /if (${Me.Invis}) /break
            | Check Buffs from ini
            /if (!${DanNetOn}) {
                | 1 = Ini File, 2 = Too Buff List
                /if (${WhileFlag}==1) {
                    /varset SearchList ${Ini["KissAssist_Buffs.ini"]}
                    /varset SearchCount ${IniIDList.Count[|]}
                } else {
                    /varset SearchList ${ExtendedBuffList}
                    /varset SearchCount ${ExtendedBuffList.Count[|]}
                }
            } else {
                | 1 = Characters using DanNet, 2 = Mercenaries in the area
                | 3 = Too Buff List, 4 = Pets of Characters using DanNet
                /if (${WhileFlag}==1 || ${WhileFlag}==4) {
                    /if (${Zone.ShortName.Find[_]}) {
                        /varset SearchList ${DanNet.Peers[zone_${Zone.ShortName}]}
                    } else {
                        /varset SearchList ${DanNet.Peers[zone_${EverQuest.Server.Lower}_${Zone.ShortName}]}
                    }
                    /varset SearchCount ${SearchList.Count[|]}
                } else /if (${WhileFlag}==2) {
                    | This is for Mercenaries in other groups.
                    /if (${SpawnCount[mercenary zradius 20 radius ${BuffRange}]}>0) {
                        /varset SearchCount ${SpawnCount[mercenary zradius 20 radius ${BuffRange}]}
                        /if (${Zone.ShortName.Find[_]}) {
                            /varset SearchList ${DanNet.Peers[zone_${Zone.ShortName}]}
                        } else {
                            /varset SearchList ${DanNet.Peers[zone_${EverQuest.Server.Lower}_${Zone.ShortName}]}
                        }
                        /for l 1 to ${SearchCount}
                            /varset MercID ${NearestSpawn[${l},mercenary zradius 20 radius ${BuffRange}].ID}
                            /if (${SearchList.Find[${Spawn[id ${MercID}].Owner.CleanName}|]}) {
                                /varset MercIDList ${MercIDList}|${MercID}
                            }
                        /next SearchCount
                        /varset SearchList ${MercIDList}|
                        /varset SearchCount ${SearchList.Count[|]}
                    }
                } else {
                    /varset SearchList ${ExtendedBuffList}
                    /varset SearchCount ${ExtendedBuffList.Count[|]}
                }
            }
            /if (${Redguides}) {
                | IniIDCount = number of Char IDs counted in ini file. If 0 skip or Buff is null the the process.
                /if (${SearchCount}<=0 || ${SpellName.Equal[null]} || (${2ndPart.Equal[Dual]} && ${BuffName.Equal[null]})) /return
                | Check if invalid spell and we don't have the item
                /if (!${Spell[${SpellName}].ID} && !${FindItemCount[=${SpellName}]}) /return
                | Start scan of buffs listed on toons in ini file
                /for k 1 to ${SearchCount}
                    /if (${Me.Invis}) /break
                    /varset skipFlag 0
                    /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
                    /if (!${DanNetOn}) {
                        | 1 = Ini File, 2 = Too Buff List
                        /if (${WhileFlag}==1) {
                            /varset TryToBuffID ${Int[${SearchList.Arg[${k},|]}]}
                            /varset TryToBuffName ${Spawn[${TryToBuffID}].CleanName}
                        } else {
                            /varset TryToBuffName ${SearchList.Arg[${k},|]}
                            /varset TryToBuffID ${Int[${Spawn[=${TryToBuffName}].ID}]}
                        }
                    } else {
                        | 1 = Characters using DanNet, 2 = Mercenaries in the area
                        | 3 = Too Buff List, 4 = Pets of Characters using DanNet
                        /if (${WhileFlag}!=2) {
                            /varset TryToBuffName ${SearchList.Arg[${k},|]}
                            /varset TryToBuffID ${Int[${Spawn[=${TryToBuffName}].ID}]}
                        } else {
                            /varset TryToBuffID ${Int[${SearchList.Arg[${k},|]}]}
                            /varset TryToBuffName ${Spawn[${TryToBuffID}].CleanName}
                        }
                    }
                    |/echo ${TryToBuffID} ${TryToBuffName}
                    /if (!${TryToBuffID} || !${Spawn[id ${TryToBuffID}].ID}) /continue
                    | If the Spawn ID is not in the zone and not a PC/merc and not me skip to next ID
                    /if (${Select[${Spawn[${TryToBuffID}].Type},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,NPC,TRIGGER,TRAP,TIMER,MOUNT]} || ${TryToBuffID}==${Me.ID}) /continue
                    | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip because none of these are cast on others
                    DEBUGBUFF CheckINIBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${SpellName}]}>=1 Self:${Spell[${SpellName}].TargetType.Find[self]}
                    | Set buff to correct spell to check for with Dual tag
                    /if ((${2ndPart.Find[Dual]} && ${Spell[${SpellName}].TargetType.Equal[self]}) || ${Spell[${BuffName}].TargetType.Equal[self]} || ${BookTT.Equal[self]}) /return
                    | Check for Group only spells and skip NON group members.
                    | If buff marked MA skipped if spawn ID isn't MA
                    /if (${Select[${2ndPart},MA,DualMA]} && ${Spawn[${TryToBuffID}].CleanName.NotEqual[${MainAssist}]} || ${2ndPart.Equal[!MA]} && ${Spawn[${TryToBuffID}].CleanName.Equal[${MainAssist}]}) /continue
                    /if ((${Select[${2ndPart},Caster,DualCaster]}>0 && ${Select[${Spawn[${TryToBuffID}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${Select[${2ndPart},Melee,DualMelee]}>0 && ${Select[${Spawn[${TryToBuffID}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /continue
                    /if (${Select[${2ndPart},class,dualclass]}>0 && ${Select[${Spawn[${TryToBuffID}].Class.ShortName},${5thPart}]}==0) /continue
                    /if (${Select[${2ndPart},!class,!dualclass]}>0 && ${Select[${Spawn[${TryToBuffID}].Class.ShortName},${5thPart}]}) /continue
                    DEBUGBUFF CheckINIBuffs  IniBuffCheck 1.1: 2ndPart: ${2ndPart} Class Name: ${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName}
                    | Temp variable to store buff name after stripping rk stuff makes it easier to compare
                    /if (${BuffName.Find[ Rk.]}) {
                        /varset IniTempBuff ${BuffName.Left[${Math.Calc[${BuffName.Find[ Rk.]}-1]}]}
                    } else {
                        /varset IniTempBuff ${BuffName}
                    }
                    DEBUGBUFF CheckINIBuffs  IniBuffCheck 2: ${Spawn[${IniIDList.Arg[${k},|]}].Name} ${IniIDList.Arg[${k},|]} ${IniTempBuff} ${BuffName}
                    /if (!${DanNetOn}) {
                        | 1 = Ini File, 2 = Too Buff List
                        /if (${WhileFlag}==1) {
                            | Assign var IniBBuffList blocked buffs list from ini file
                            /varset IniBBuffList ${Ini["KissAssist_Buffs.ini",${TryToBuffID},"Blockedbuffs"]}
                            | If the current buff is on the blocked buff list skip it.
                            DEBUGBUFF CheckINIBuffs  IniBuffCheck 3: ${IniBBuffList.Find[${IniTempBuff}]} Buff blocked?
                            /if (${IniBBuffList.Find[${IniTempBuff}]}) /continue
                            | Assign var IniBuffList buffs list from ini file
                            /varset IniBuffList ${Ini["KissAssist_Buffs.ini",${TryToBuffID},"Buffs"]}
                            | If current buff is on the buff list skip it
                            DEBUGBUFF CheckINIBuffs IniBuffCheck 4: ${IniTempBuff} ${IniBuffList.Find[${IniTempBuff}]}
                            /if (${IniBuffList.Find[${IniTempBuff}]}) /continue
                            | Assign buff count
                            /varset IniBuffCount ${IniBuffList.Count[|]}
                            | Check if current buff stacks will all existing buffs in list
                            DEBUGBUFF CheckINIBuffs  IniBuffCheck 5: ${Spawn[${TryToBuffID}].Name} ${IniBuffCount} BuffsNum ${SpellName}
                            /for l 1 to ${IniBuffCount}
                                | Fix for stacking issues with Perfected Group Levitation there are a lot
                                /if (${IniBuffList.Arg[${l},|].Find[Group Perfected Levitation]} && !${SpellName.Find[Group Perfected Levitation]}) /continue
                                /if (!${Spell[${IniTempBuff}].RankName.WillStack[${IniBuffList.Arg[${l},|]}]}) {
                                    /varset skipFlag 1
                                    DEBUGBUFF CheckINIBuffs IniBuffCheck Stack: ${IniBuffList.Arg[${l},|]} !Stack ${SpellName} ${Select[${Spell[${IniTempBuff}].RankName.WillStack[${IniBuffList.Arg[${l},|]}]},TRUE,FALSE,NULL]}
                                    /break
                                }
                            /next l
                        }
                    } else {
                        | 1 = Characters using DanNet, 2 = Mercenaries in the area
                        | 3 = Too Buff List, 4 = Pets of Characters using DanNet
                        /if (${WhileFlag}==1) {
                            | Is buff in Blocked Buff List?
                            /dquery ${TryToBuffName} -q "Me.BlockedBuff[${IniTempBuff}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Me.Buff[${IniTempBuff}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Me.Song[${IniTempBuff}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Spell[${IniTempBuff}].Stacks[0]" -o DNout -t ${DanNetDelay}
                            /if (!${Bool[${DNout}]}) /continue
                        } else /if (${WhileFlag}==4) {
                            |Do I have a pet?
                            /dquery ${TryToBuffName} -q "Me.Pet.ID" -o DNout -t ${DanNetDelay}
                            /if (!${Bool[${DNout}]}) /continue
                            /varset TryToBuffID ${DNout}
                            /dquery ${TryToBuffName} -q "Me.BlockedPetBuff[${IniTempBuff}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Me.Pet.Buff[${IniTempBuff}]" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Spell[${IniTempBuff}].StacksPet[0]" -o DNout -t ${DanNetDelay}
                            /if (!${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Me.Pet.Name" -o DNout -t ${DanNetDelay}
                            /varset TryToBuffName ${DNout}
                        }
                    }
                    /if (!${skipFlag}) {
                        | varset ini buff timer toon Id spell Id to shorten var and clarity
                        /varset PBTimerID ${TryToBuffID}${Spell[${SpellName}].ID}
                        | Define timer for spell i am about to cast
                        /if (!${Defined[ExtBuffTimer${PBTimerID}]}) /declare ExtBuffTimer${PBTimerID} timer outer 0
                        DEBUGBUFF CheckINIBuffs IniBuffCheck 6: ${Spawn[${TryToBuffID}].Name} Temp:${IniTempBuff} OnList:${IniBuffList.Find[${IniTempBuff}]} Timer:${ExtBuffTimer${PBTimerID}}
                        | Check if toon is within spell range and cast buff
                        /if (${Spawn[${TryToBuffID}].Distance}<=${BuffRange} && !${ExtBuffTimer${PBTimerID}}) {
                            /if (${Spell[${SpellName}].TargetType.Equal[self]} && ${TryToBuffID}!=${Me.ID}) {
                                DEBUGBUFF CheckINIBuffs tried to buff ${Spawn[${TryToBuffID}].CleanName} with a self buff
                                /continue
                            }
                            /if (${Me.SpellInCooldown} && !${IAmABard}) {
                                /while (${Me.SpellInCooldown}) {
                                    /delay 5
                                }
                            }
                            /call CastWhat "${SpellName}" ${TryToBuffID} Buffs ${CondNumber} 0
                            DEBUGBUFF CheckINIBuffs IniBuffCheck 7: "${SpellName}" ${TryToBuffID} Buffs 0 ${Macro.Return}
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /echo Buffing >> ${SpellName} << on ${TryToBuffName}
                                /varset ExtBuffTimer${PBTimerID} 60s
                                /varset IniNextTimer 0
                                /doevents flush WornOff
                                /varset WriteBuffsTimer 0
                                /call WriteBuffs
                            } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                                /echo You are missing components. Turning off ${BuffName}.
                                /varset Buffs[${BuffsNum}] NULL
                                /varset SpellName
                                /continue
                            } else /if (${Macro.Return.Equal[CAST_HASBUFF]}) {
                                /varset ExtBuffTimer${PBTimerID} ${HasBuffDuration}*10
                                /varset IniNextTimer 0
                            }
                        }
                        DEBUGBUFF CheckINIBuffs IniBuffCheck 8: ExtBuffTimer${PBTimerID}:${ExtBuffTimer${PBTimerID}} IniNextTimer:${IniNextTimer}
                    }
                /next k
            }
            /if (!${DanNetOn} && ${WhileFlag}==2) {
                /break
            } else /if (${DanNetOn} && ${WhileFlag}==4) {
                /break
            }
            /varcalc WhileFlag ${WhileFlag}+1
        }
        DEBUGBUFF CheckIniBuffs Leave
    /return
| ----------------------------------------------------------------------------
| SUB: RegenOther
| ----------------------------------------------------------------------------
    Sub RegenOther(RGName, Stat, int StatPct, RegonOnClasses, int CondNumber)
    | Casting on others during combat will interrupt fast med
    /if (${Medding} && ${MedCombat}) /return FALSE
    /if (${Me.Invis}) /return FALSE
        DEBUGBUFF RegenOther Enter  ${RGName} ${Stat} ${StatPct} ${RegonOnClasses}
        /declare i int local
        /declare ROResult string local FALSE
        /if (${RegonOnClasses.Equal[0]} || ${RegonOnClasses.Equal[null]}) {
            /if (${Stat.Equal[endurance]}) {
                /varset RegonOnClasses BER,BST,MNK,PAL,RNG,ROG,SHD,WAR
            } else /if (${Stat.Equal[mana]}) {
                /varset RegonOnClasses BRD,BST,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHD,SHM,WIZ
            }
        }
        /for i 1 to ${Group}
            DEBUGBUFF RegenOther Class: ${Group.Member[${i}].Class.ShortName} AggroID: ${AggroTargetID}  GrpMemPct: ${Group.Member[${i}].Current${Stat}}<=${StatPct} GrpMemID: ${Group.Member[${i}].ID}
            | If bard rallying call aa skip tank or he won't attack
            /if (${RGName.Find[Rallying Call]} && ${Group.Member[${i}].ID}==${Spawn[${MainAssist} ${MainAssistType}].ID}) /continue
            | Bard Dichotomic uses endurance not mana
            /if  (${RGName.Find[Dichotomic Psalm]} && ${Me.CurrentEndurance}<15000) /continue
            | Dichotomic Psalm & Quiet Miracle do not work on bards
            /if (${Group.Member[${i}].Class.Name.Equal[bard]} && (${RGName.Equal[Dichotomic Psalm]} || ${RGName.Equal[Quiet Miracle]})) /continue
            /if (${Select[${Group.Member[${i}].Class.ShortName},${RegonOnClasses}]} && !${AggroTargetID} && ${Group.Member[${i}].Current${Stat}}<=${StatPct} && ${Group.Member[${i}].Current${Stat}}>=1 && ${Group.Member[${i}].ID}) {
                /call CastWhat "${RGName}" ${Group.Member[${i}].ID} Regenother ${CondNumber} 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting ${RGName} on ${Group.Member[${i}].CleanName} for ${Stat}.
                    /varset ROResult TRUE
                    /break
                } else {
                    /varset ROResult ${Macro.Return}
                }
            }
        /next i
        DEBUGBUFF RegenOther Leave ${ROResult}
    /return ${ROResult}
| ----------------------------------------------------------------------------
| SUB: Pick Up item
| ----------------------------------------------------------------------------
    Sub PickUpItem(string p_ItemName, p_AddToList)
        /declare itemSlot int local
        /declare itemSlot2 int local
        /if (!${FindItemCount[=${p_ItemName}]}) /return
        /varset itemSlot ${FindItem[=${p_ItemName}].ItemSlot}
        /varset itemSlot2 ${FindItem[=${p_ItemName}].ItemSlot2}
        /if (${itemSlot}>22) /varcalc itemSlot ${itemSlot}-22
        /if (${itemSlot2}>-1) /varcalc itemSlot2 ${itemSlot2}+1

        /if (!${PetToyList.Length}) {
            /varset PetToyList ${p_ItemName}@${itemSlot}@${itemSlot2}
        } else {
            /varset PetToyList ${PetToyList}|${p_ItemName}@${itemSlot}@${itemSlot2}
        }
        /if (${itemSlot2}<0) {
            /nomodkey /itemnotify pack${itemSlot} leftmouseup
        } else {
            /nomodkey /itemnotify in pack${itemSlot} ${itemSlot2} leftmouseup
        }
        /delay 20 ${Cursor.ID}
    /return
| ----------------------------------------------------------------------------
| SUB: Check OpenInvSlot - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub OpenInvSlot
        DEBUGBUFF OpenInvSlot Enter
        /if (${BagNum}) /return
        /declare h int local 1
        /declare i int local 0
        /declare maxSlots int local ${Me.NumBagSlots}
        /varset BagNum 0
        /call CheckCursor OpenInvSlot 1
        /if (${Cursor.ID}) {
            /varset BagNumLast 99
            /return
        }
        /while (${h}<3 && !${BagNum}) {
            /for i 1 to ${maxSlots}
                /if (${Me.Inventory[pack${i}].Container}) /continue
                /if (${h}==1) {
                    /if (${Me.Inventory[pack${i}].ID}==0) {
                        /varset BagNum ${i}
                        /break
                    }
                } else /if (${h}==2) {
                    /if (!${Me.Inventory[pack${i}].Container}) {
                        /if (${Me.FreeInventory}>1) {
                            /varset BagNum ${i}
                        } else {
                            /varset BagNumLast 99
                        }
                        /break
                    }
                } else {
                    /break
                }
            /next i
            /varcalc h ${h}+1
            /if (${BagNum}) /break
        }
        /if (${BagNum}) {
            /if (${BagNum}!=${BagNumLast}) {
                /varset BagNumLast ${BagNum}
                /echo Pet Toys: Inventory slot ${i} is empty using that one.
            }
        }
        DEBUGBUFF OpenInvSlot Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Check DestroyBag - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub DestroyBag
        DEBUGBUFF DestroyBag Enter
        /declare j int local
        | Make sure bag has no items other than summoned in it before deleting.
        /if (${Me.Inventory[pack${BagNum}].Items}) {
            /for j 1 to ${Me.Inventory[pack${BagNum}].Container}
                /if (${Me.Inventory[pack${BagNum}].Item[${j}].Name.Length}) {
                    /if (!${Me.Inventory[pack${BagNum}].Item[${j}].NoRent}) {
                        /echo Bag has non summoned item(s) in it. Aborting delete. Pet Toys Off
                        /varset PetToysOn 0
                        /return
                    }
                }
            /next j
        }
        /if (${Me.Inventory[pack${BagNum}].Name.Find[Phantom Satchel]} || ${Me.Inventory[pack${BagNum}].Name.Find[Pouch of Quellious]}) {
            /nomodkey /itemnotify pack${BagNum} leftmouseup
            /delay 5s ${Cursor.ID}
            /if (${Cursor.Name.Find[Phantom Satchel]} || ${Cursor.Name.Find[Pouch of Quellious]}) /destroy
            /delay 20 !${Cursor.ID}
        }
        DEBUGBUFF Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Check GiveTo - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub GiveTo(string GItem, int GTarget, int GiveNow)
        DEBUGBUFF GiveTo Enter ${GItem} ${GTarget} ${GiveNow}
        /declare ItemSummoned  int    local 0
        /declare GItemID       int    local 0
        /declare GDropCount    int    local 0
        /declare x1            int    local 0
        /declare ToyName       string local
        /declare ListItem      string local
        /if (${GItem.NotEqual[giveitems]}) {
            /if (${Target.ID}!=${GTarget}) {
                /target id ${GTarget}
                /delay 2s ${Target.ID}==${GTarget}
            }
            /if (${Target.Distance}>5 && ${Target.Distance}<=${CampRadius}) {
                /moveto id ${Target.ID} mdist 5
                /delay 50 ${MoveTo.Stopped}
            }
            /if (${Me.Mount.ID}) {
                /dismount
                /delay 20 !${Me.Mount.ID}
            }
            /if (${Me.Levitating}) {
                /removelev
                /delay 20 !${Me.Levitating}
            }
            /if (!${Cursor.ID}) {
                /if (${FindItemCount[=${GItem}]}>0) {
                    /call PickUpItem "${GItem}" 0
                } else {
                    /echo Item: ${GItem} Not Found in Inventory. Are you sure the Item Name is Correct?
                    /return
                }
            }
            /varset GItemID ${FindItem[=${GItem}].ID}
            /while (${Cursor.ID} && ${GDropCount}<4) {
                /if (${Cursor.NoRent}) {
                    /if (${Cursor.ID}==${GItemID}) {
                        /varset ItemSummoned 1
                        /nomodkey /click left target
                        /delay 20 !${Cursor.ID}
                        /varcalc ItemsGiven ${ItemsGiven}+1
                    } else {
                        /echo Item: ${GItem} Not Found on Cursor. Dropping ${Cursor} to Inventory.
                        /autoinventory
                        /delay 10
                    }
                } else {
                    /echo Item: ${Cursor} is not Summoned. Dropping to Inventory.
                    /autoinventory
                    /delay 10
                }
                /varcalc GDropCount ${GDropCount}+1
            }
            /if (${Cursor.ID}) {
                /echo Item still on Cursor. The Item is the wrong item or your inventory is full.
                /return
            }
        } else {
            /varset ItemSummoned 1
            /varset GiveNow 1
        }
        /delay 30 ${Window[GiveWnd].Open}
        /if (${Window[GiveWnd].Open}) {
            /if (${GiveNow} || ${ItemsGiven}==4) {
                /notify GiveWnd GVW_Give_Button leftmouseup
                /echo Giving Item(s) to ${Target.CleanName}
                /delay 20 !${Window[GiveWnd].Open}
                /delay 15
                /varset ItemsGiven 0
            }
        }
        | New pet patch gives back item if pet has equipped. Delete item from cursor.
        /varset GDropCount 0
        /if (${Cursor.ID}) {
            /while (${Cursor.ID} && ${GDropCount}<8) {
                /varset GItemID ${Cursor.ID}
                /varset ToyName ${Cursor.Name}
                | This came out of your inventory, so put it back where you got it.
                /if (${PetToyList.Find[${ToyName}]}) {
                    /varset x1 1
                    /while (1) {
                        /varset ListItem ${PetToyList.Arg[${x1},|]}
                        /if (!${ListItem.Length} || ${ListItem.Equal[null]}) /break
                        /if (${ListItem.NotEqual[removed]}) {
                            /if (${ListItem.Arg[1,@].Equal[${ToyName}]}) {
                                /if (${Int[${ListItem.Arg[3,@]}]}<0) {
                                    /nomodkey /itemnotify pack${ListItem.Arg[2,@]} leftmouseup
                                } else {
                                    /nomodkey /itemnotify in pack${ListItem.Arg[2,@]} ${ListItem.Arg[3,@]} leftmouseup
                                }
                                /varset PetToyList ${PetToyList.Replace[${ListItem},removed]}
                                /break
                            }
                        }
                        /varcalc x1 ${x1}+1
                    }
                } else /if (${Cursor.NoRent}) {
                    /destroy
                } else {
                    /autoinventory
                }
                /delay 20 ${Cursor.ID}
                /varcalc GDropCount ${GDropCount}+1
            }
        } else /if (${GiveNow}) {
            /varset PetToyList
        }
        DEBUGBUFF GiveTo Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Check Plugin
| ----------------------------------------------------------------------------
    Sub CheckPlugin(string pluginname, int noautoflag)
        /declare WaitTimer1 timer local 50
        DEBUGN CheckPlugin: Enter
        /if (!${Bool[${Plugin[${pluginname}]}]}) {
            /if (${noautoflag}) {
                /squelch /plugin ${pluginname} noauto
            } else {
                /squelch /plugin ${pluginname}
            }
            /echo ${pluginname} not detected! This macro requires it! Loading ...
            /while (${WaitTimer1} && !${Bool[${Plugin[${pluginname}]}]}) {
                /delay 5
            }
        }
        DEBUGN CheckPlugin: Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Load Ini
| ----------------------------------------------------------------------------
    Sub LoadIni(string sectionName, string varName, string varType, string varValue, string varArray, string FileName)
        /if (${Debug}) {
            /delay 2
            /echo \atDEBUG Sub Loadini S:${sectionName} V1:${varName} V2:${varType} V3:${varValue} V4:${varArray}
        }
        /declare rkTemp                 string      local
        /declare UtilInt                int         local        0
        /declare FileName1              string      local        ${FileName}
        /declare RezCount               int         local        0
        | Assign ini name to default ini if not defined
        /if (${FileName1.Length}==0  || ${FileName1.Equal[NULL]}) {
            /varset FileName1 ${IniFileName}
        }
        | Check if ini value is asking for an array ie buff1 to buff20
        /if (${Bool[${varArray}]}) {
            /if (${${varArray}.Size}>0) {
                /declare i int local
                /for i 1 to ${${varArray}.Size}
                    /if (${sectionName.NotEqual[KConditions]}) {
                        /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
                            /ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
                        } else {
                            /varset ${varArray}[${i}] ${Ini[${FileName1},${sectionName},${varArray}${i}]}
                        }
                        /if (${${varArray}[${i}].NotEqual[null]} && ${${varArray}[${i}].Left[1].NotEqual[;]}) {
                            | find out if there is a Rank and fix spell name.
                            /if (${varType.Equal[string]} && ${Int[${${varArray}[${i}].Left[1]}]}==0) {
                                /call SpellRankCheck "${${varArray}[${i}]}"
                                /varset ${varArray}[${i}] ${Macro.Return}
                            }
                            | code to fix the Heal PCT for those zones Crypt of Sul, that knock your HPs down to
                            /if (${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0) {
                                /if (${sectionName.Equal[Heals]}) {
                                    /if (${${varArray}[${i}].Arg[3,|].Find[rez]}) {
                                        /varcalc RezCount ${RezCount}+1
                                        /if (${RezCount}<=${AutoRez.Size}) {
                                            /varset AutoRez[${RezCount}] ${${varArray}[${i}]}
                                            /varset ${varArray}[${i}] null
                                        }
                                    } else /if (${Select[${Zone.ID},795,796]}) {
                                        /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}*.7
                                        /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                                    }
                                } else /if (${sectionName.Equal[DPS]} && ${${varArray}[${i}].Arg[3,|].Equal[debuffall]}) {
                                    /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
                                    /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                                } else /if (${sectionName.Equal[Aggro]} && ${${varArray}[${i}].Arg[3,|].Equal[<<]}) {
                                    /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
                                    /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                                }
                            } else /if (${sectionName.Equal[Heals]}) {
                                /if (${${varArray}[${i}].Arg[3,|].Find[rez]}) {
                                    /varcalc RezCount ${RezCount}+1
                                    /if (${RezCount}<=${AutoRez.Size}) {
                                        /varset AutoRez[${RezCount}] ${${varArray}[${i}]}
                                        /varset ${varArray}[${i}] null
                                    }
                                }
                            }
                        } else {
                            /varset ${varArray}[${i}] null
                        }
                        DEBUGN Loadini: ${i} - ${varArray}[${i}] - ${${varArray}[${i}]}
                    } else {
                        /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
                            /ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
                        } else {
                            /varset ${varArray}[${i}]  ${Ini[${FileName1},${sectionName},${varArray}${i},NULL,noparse]}
                        }
                        DEBUGN ${varArray}[${i}]  ${Ini[${FileName1},${sectionName},${varArray}${i},NULL,noparse]}
                    }
                /next i
                /return
            }
        } else {
            /if (!${Defined[${varName}]} && ${Select[${varType},string,float,int]}>0) /declare ${varName} ${varType} outer 0
                /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                    /if (${varValue.Length}) {
                        /ini "${FileName1}" "${sectionName}" "${varName}" "${varValue}"
                        /varset ${varName} ${varValue}
                        DEBUGN Sub Loadini /varset ${varName} ${varValue}
                    }
                } else {
                    /varset ${varName} ${Ini[${FileName1},${sectionName},${varName}]}
                }
                /if (${FileName1.Equal[${IniFileName}]}) {
                    /varset rkTemp ${${varName}}
                    | find out if there is a Rank and fix spell name.
                    /if (${varType.Equal[string]} && ${Int[${rkTemp.Left[1]}]}==0 && !${varName.Find[Help]}) {
                        /call SpellRankCheck "${${varName}}"
                        /if (${Macro.Return.NotEqual[null]}) /varset ${varName} ${Macro.Return}
                    }
                }
            DEBUGN Sub LoadIni: ${varName} - ${${varName}}
            /varset rkTemp
        }
        DEBUGN Sub LoadIni: Leave
    /return
| ----------------------------------------------------------------------------
| SUB: End Mac If
| ----------------------------------------------------------------------------
    Sub EndMacroIf
        DEBUGN EndMacroIf: Enter
        | I died wait for rez loop
        /if (${Me.Hovering}) /call PauseWhileHovering EndMacroIf
        /while (${EverQuest.GameState.NotEqual[ingame]}) {
            /delay 10
            /if (${EverQuest.GameState.Equal[CHARSELECT]}) /endmac
        }
        /while (${CampZone}!=${Zone.ID} && ${RezAcceptOn.Arg[1,|].Equal[1]} && ${IAmDead} && ${Me.ID}) {
            /if (${EverQuest.GameState.Equal[CHARSELECT]}) /endmac
            /if (${Attacking}) /call CombatReset 0 endmacroif
            /delay 10
            /if (${ClickBacktoCamp}) /call CampfireBack
            /if (${CampOnDeath}) /call DoICamp
        }
        /if (${RezAcceptOn.Arg[1,|].Equal[0]} && ${CampZone}!=${Zone.ID}) {
            /if (${CampOnDeath}) /call DoICamp
        }
        DEBUGN EndMacroIf: Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Do I Camp
| ----------------------------------------------------------------------------
    Sub DoICamp
        DEBUGN DoICamp Entered ${CampOnDeathTimer} ${CampOnDeath} ${CampZone} ${Zone.ID}
        /while (${CampOnDeathTimer} && ${CampOnDeath}==1 && ${CampZone}!=${Zone.ID}) {
            /delay 10
            DOPARSE
        }
        /if ((!${CampOnDeathTimer} || ${CampOnDeath}==2) && ${CampZone}!=${Zone.ID}) {
            /echo I am dead and not where I am suppose to be. Time to camp out.
            /if (${IAmABard}) {
                /call CastBardCheck
            }
            /docommand /camp desktop
            /delay 10s
            /endmac
        }
        DEBUGN DoICamp Leave
    /return
| ----------------------------------------------------------------------------
| SUB: New Do I Camp, Testing.
| ----------------------------------------------------------------------------
    Sub DoICampA
        DEBUGN DoICampA Entered ${CampOnDeathTimer} ${CampOnDeath} ${CampZone} ${Zone.ID}
        /if (${CampZone}!=${Zone.ID}) {
            /if (${CampOnDeath}==1) {
                /if (${CampOnDeathTimer}) {
                    /echo Camping Due to Not in Camp Zone. Waiting for ${Math.Calc[${CampOnDeathTimer}/10]} Seconds
                    /while (${CampOnDeathTimer} && ${CampZone}!=${Zone.ID}) {
                        /delay 10
                        DOPARSE
                    }
                    /if (${CampZone}==${Zone.ID}) {
                        /if (${CampOnDeathTimer}) /echo Aborting! Camping.
                        /return
                    }
                }
                /echo Time Expired. Camping Now.
            } else /if (${CampOnDeath}==2) {
                /echo I am not where I am suppose to be. Time to camp out.
            }
            /if (${IAmABard}) {
                /call CastBardCheck
            }
            /docommand /camp desktop
            /delay 10s
            /endmac
        }
        DEBUGN DoICamp Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Do Bard Stuff New
| ----------------------------------------------------------------------------
      Sub DoBardStuff
        /if (!${IAmABard}) /return
        /if (!${Medley.Active} && !${Me.Invis} && ${MedleyOn}) {
            /call CastBardCheck
            /if (${MedleyName.Length}) /squelch /medley "${MedleyName}" -quiet
            /return
        } else /if (${Me.Invis}) {
            /if (${Medley.Active} || (${Medding} && ${MedCombat} && ${AggroTargetID})) {
                /call CastBardCheck
            }
            /return
        }
        DEBUGN DoBardStuff: Enter
        /if (!${Medley.Active}) {
            /if (${MedleyOn}) {
                /echo == Resuming Medley
                /if (${Me.Sitting}) {
                    /stand
                    /delay 20 !${Me.Sitting}
                }
                /squelch /medley "${MedleyName}" -quiet
            }
        }
	
        DEBUGN DoBardStuff: Leave
	/return
| ----------------------------------------------------------------------------
| SUB: GroupEscape
| ----------------------------------------------------------------------------
    Sub GroupEscape
        /if (!${GroupEscapeOn}) /return
        DEBUGN GroupEscape Enter
        |- If (in combat) or (Have AgroID) AND (MA is not present) or (a corpse).
        /if ((${Me.CombatState.Equal[COMBAT]} || ${AggroTargetID}) && (!${Spawn[=${MainAssist}].ID} || ${Spawn[=${MainAssist}].Type.Equal[Corpse]})) {
            DEBUGN GroupEscape: CombatState:${Me.CombatState.Equal[COMBAT]} AggroTargetID:${AggroTargetID} MA Dead:!${Spawn[=${MainAssist}].ID}|${Spawn[=${MainAssist}].Type.Equal[Corpse]}
            /echo + The MA is dead and I'm in combat, activating Group Escape!
            /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
                |-- Druid AA or Spell group evac casting.
                /if (${Select[${Me.Class.ShortName},DRU]}) {
                    |- Drop Divine Barrier if it is up so we can exodus group!
                    /removebuff "Divine Barrier"
                    /if (${Me.AltAbilityReady[Exodus]}) {
                        /call CastWhat "Exodus" ${Me.ID} GroupEscape 0 0
                    } else /if (${Me.Book[Succor]}) {
                        /call CastWhat "Succor" ${Me.ID} GroupEscape 0 0
                    }
                }
                |-- Wizard AA or Spell group evac casting.
                /if (${Select[${Me.Class.ShortName},WIZ]}) {
                    /if (${Me.AltAbilityReady[Exodus]}) {
                        /call CastWhat "Exodus" ${Me.ID} GroupEscape 0 0
                    } else /if (${Me.Book[Evacuate]}) {
                        /call CastWhat "Evacuate" ${Me.ID} GroupEscape 0 0
                    }
                }
            }
        }
        DEBUGN GroupEscape Leave
    /return
| ----------------------------------------------------------------------------
| SUB: CheckHealth
| ----------------------------------------------------------------------------
    Sub CheckHealth(string sentFrom)
        /if (!${HealsOn} || (${Me.Invis} && !${AggroTargetID}) || (${Medding} && ${MedCombat})) /return
        DEBUGHEALS CheckHealth Enter ${sentFrom}
        /declare i                  int         local       0
        /declare MainAssistID       int         local       ${Spawn[=${MainAssist}].ID}
        /declare MostHurtName       string      local
        /declare MostHurtType       string      local
        /declare MostHurtID         int         local       0
        /declare MostHurtHP         int         local       100
        /declare MostHurtNo         int         local       0
        /declare MostHurtFlag       string      local       0
        /declare GroupHealthAvg     string      local       0
        /declare HurtClass          string      local
        /if (${IAmMA} && ${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${MyTargetID} && ${CombatStart}) /call CombatTargetCheck 1
        /varset HealAgain 1
        /while (${HealAgain}) {
            /varset HealAgain 0
            /varset GroupHealthAvg 0
            | Check self health
            /if (${Me.PctHPs} < ${SingleHealPoint}) {
                /call SingleHeal "${Me}" PC ${Me.PctHPs} 0 G
                /if (${HealAgain}) /continue
            }
            /if (${HealsOn}==4) /break
            | Call MA health check for only those that can heal others. ENC for runes
            /if (${Select[${Me.Class.ShortName},BST,CLR,ENC,SHM,DRU,RNG,PAL]}) {
                | This is to target Main Assist out of group if class can heal
                /if (${Select[${HealsOn},1,3]} && ${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} && ${Spawn[${MainAssist}].ID}!=${Me.ID}) {
                    DEBUGHEALS CheckHealth:  Tank OOG: ${Spawn[${MainAssist}].PctHPs} ${Spawn[${MainAssist} ${MainAssistType}].ID}  ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} ${Target.ID} ${Target.PctHPs}
                    |Add code to check if pet HP < needed.
                    /if (${Spawn[${MainAssist} ${MainAssistType}].PctHPs} < ${SingleHealPointMA}) {
                        /call SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[${MainAssist} ${MainAssistType}].PctHPs} 6 G
                    }
                }
                /if (${AutoRezOn} && !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck ma
                | Who is the most hurt
                /if (${Select[${HealsOn},1,2]} && (${Group} || ${XTarHeal}) && !${JustZoned} && !${JoinedParty}) {
                    /varset MostHurtName
                    /varset HurtClass
                    /varset MostHurtType
                    /varset MostHurtID 0
                    /varset MostHurtHP 100
                    /varset MostHurtNo 0
                    /if (!${XTarHeal}) {
                        /for i 0 to 5
                            /if (${Select[${HealsOn},2]} && ${Select[${Spawn[${MainAssist} ${MainAssistType}].ID},${Group.Member[${i}].ID},${Group.Member[${i}].Pet.ID}]}>0) /continue
                            /if (${Group} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].PctHPs}>=1) {
                                /if (${Group.Member[${i}].Distance}>${SingleHealPointRange}) /continue
                                /varset HurtClass ${Group.Member[${i}].Class}
                                DEBUGHEALS CheckHealth:  -- Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP}
                                /if (${HurtClass.NotEqual[berserker]} || ${Group.Member[${i}].Level} < 95) {
                                    /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP}) {
                                        /varset MostHurtName ${Group.Member[${i}].CleanName}
                                        /varset MostHurtType ${Group.Member[${i}].Type}
                                        /varset MostHurtID ${Group.Member[${i}].ID}
                                        /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                                        /varset MostHurtNo ${i}
                                        /varset MostHurtFlag G
                                    }
                                } else /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP} && ${Group.Member[${i}].PctHPs} < 70) {
                                    /varset MostHurtName ${Group.Member[${i}].CleanName}
                                    /varset MostHurtType ${Group.Member[${i}].Type}
                                    /varset MostHurtID ${Group.Member[${i}].ID}
                                    /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                                    /varset MostHurtNo ${i}
                                    /varset MostHurtFlag G
                                }
                                /if (${HealGroupPetsOn} && ${Select[${Group.Member[${i}].Class.Name},cleric,wizard]}==0 && ${Group.Member[${i}].Pet.ID}>0 && ${Group.Member[${i}].Pet.PctHPs} < ${MostHurtHP}) {
                                    /varset MostHurtName ${Group.Member[${i}].Pet.CleanName}
                                    /varset MostHurtType Pet
                                    /varset MostHurtID ${Group.Member[${i}].Pet.ID}
                                    /varset MostHurtHP ${Group.Member[${i}].Pet.PctHPs}
                                    /varcalc MostHurtNo ${i}+8
                                    /varset MostHurtFlag G
                                }
                            }
                        /next i
                    } else /if (${XTarHeal}==2) {
                        /for i 1 to ${XSlotTotal}
                            /if (${XTarToHeal[${i}]}==0) /break
                            /if (${XTarToHeal[${i}]}==${XTSlot}) /continue
                            /if (${Me.XTarget[${XTarToHeal[${i}]}].ID} && ${Me.XTarget[${XTarToHeal[${i}]}].Type.NotEqual[corpse]} && ${Me.XTarget[${XTarToHeal[${i}]}].PctHPs}>=1) {
                                /if (${Me.XTarget[${XTarToHeal[${i}]}].Distance}>${SingleHealPointRange}) /continue
                                DEBUGHEALS CheckHealth:  -- XTarget Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP}
                                /if (${Me.XTarget[${XTarToHeal[${i}]}].PctHPs} < ${MostHurtHP}) {
                                    /varset MostHurtName ${Me.XTarget[${XTarToHeal[${i}]}].CleanName}
                                    /varset MostHurtType ${Me.XTarget[${XTarToHeal[${i}]}].Type}
                                    /varset MostHurtID ${Me.XTarget[${XTarToHeal[${i}]}].ID}
                                    /varset MostHurtHP ${Me.XTarget[${XTarToHeal[${i}]}].PctHPs}
                                    /varset MostHurtNo ${i}
                                    /varset MostHurtFlag X
                                }
                            }
                        /next i
                    } else {
                        /for i 0 to 5
                            /if (${Select[${HealsOn},2]} && ${Select[${Spawn[${MainAssist} ${MainAssistType}].ID},${Group.Member[${i}].ID},${Group.Member[${i}].Pet.ID}]}>0) /continue
                            /if (${Group} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].PctHPs}>=1) {
                                /if (${Group.Member[${i}].Distance}>${SingleHealPointRange}) /continue
                                /varset HurtClass ${Group.Member[${i}].Class}
                                DEBUGHEALS CheckHealth:  -- Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP}
                                /if (${HurtClass.NotEqual[berserker]} || ${Group.Member[${i}].Level} < 95) {
                                    /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP}) {
                                        /varset MostHurtName ${Group.Member[${i}].CleanName}
                                        /varset MostHurtType ${Group.Member[${i}].Type}
                                        /varset MostHurtID ${Group.Member[${i}].ID}
                                        /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                                        /varset MostHurtNo ${i}
                                        /varset MostHurtFlag G
                                    }
                                } else /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP} && ${Group.Member[${i}].PctHPs} < 70) {
                                    /varset MostHurtName ${Group.Member[${i}].CleanName}
                                    /varset MostHurtType ${Group.Member[${i}].Type}
                                    /varset MostHurtID ${Group.Member[${i}].ID}
                                    /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                                    /varset MostHurtNo ${i}
                                    /varset MostHurtFlag G
                                }
                                /if (${HealGroupPetsOn} && ${Select[${Group.Member[${i}].Class.Name},cleric,wizard]}==0 && ${Group.Member[${i}].Pet.ID}>0 && ${Group.Member[${i}].Pet.PctHPs} < ${MostHurtHP}) {
                                    /varset MostHurtName ${Group.Member[${i}].Pet.CleanName}
                                    /varset MostHurtType Pet
                                    /varset MostHurtID ${Group.Member[${i}].Pet.ID}
                                    /varset MostHurtHP ${Group.Member[${i}].Pet.PctHPs}
                                    /varcalc MostHurtNo ${i}+8
                                    /varset MostHurtFlag G
                                }
                            }
                        /next i
                        /for i 1 to ${XSlotTotal}
                            /if (${XTarToHeal[${i}]}==0) /break
                            /if (${XTarToHeal[${i}]}==${XTSlot}) /continue
                            /if (${Me.XTarget[${XTarToHeal[${i}]}].ID} && ${Me.XTarget[${XTarToHeal[${i}]}].Type.NotEqual[corpse]} && ${Me.XTarget[${XTarToHeal[${i}]}].PctHPs}>=1) {
                                /if (${Me.XTarget[${XTarToHeal[${i}]}].Distance}>${SingleHealPointRange}) /continue
                                DEBUGHEALS CheckHealth:  -- XTarget Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP}
                                /if (${Me.XTarget[${XTarToHeal[${i}]}].PctHPs} < ${MostHurtHP}) {
                                    /varset MostHurtName ${Me.XTarget[${XTarToHeal[${i}]}].CleanName}
                                    /varset MostHurtType ${Me.XTarget[${XTarToHeal[${i}]}].Type}
                                    /varset MostHurtID ${Me.XTarget[${XTarToHeal[${i}]}].ID}
                                    /varset MostHurtHP ${Me.XTarget[${XTarToHeal[${i}]}].PctHPs}
                                    /varset MostHurtNo ${i}
                                    /varset MostHurtFlag X
                                }
                            }
                        /next i
                    }
                    DEBUGHEALS CheckHealth: (${MostHurtHP} < ${SingleHealPoint}) "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo} ${MostHurtFlag}
                    /if (${MostHurtHP} < ${SingleHealPoint}) {
                        /call SingleHeal "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo} ${MostHurtFlag}
                    }
                }
            }
            | Rez tank check
            /if (${AutoRezOn} && !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck ma
            | Group Heal Check only call for those clases that can group heal
            /if (${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) {
                /varset GroupHealthAvg ${Group.AvgHPs}
                DEBUGHEALS CheckHealth: Group Health Average ${GroupHealthAvg}
                | Check for group heals
                /if (${GroupHealthAvg} < 100 && ${Group} && ${Group.Injured[90]}>1) {
                    /call DoGroupHealStuff ${GroupHealthAvg}
                    | Rez tank check
                    /if (${AutoRezOn} && !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck ma
                }
            }
            /if (${PetOn} && ${Me.Pet.ID} && ${Me.Pet.PctHPs} < 100) /call DoPetHealStuff
        }
        DEBUGHEALS CheckHealth leave ${sentFrom}
        /if (${AutoRezOn}) /call RezCheck group
        /call WriteDebuffs
    /return
| -------------------------------------------------------------------------------------
| SUB: Rez With Check
| -------------------------------------------------------------------------------------
    Sub RezWithCheck(string RWCWho)
        /declare RezWithS string local notready
        /declare i int local 0
        /declare RezType string local
        DEBUGHEALS RezWithCheck Enter
        /for i 1 to ${AutoRez.Size}
            /varset RezType ${AutoRez[${i}].Arg[3,|]}
            DEBUGHEALS RezType: ${RezType} ${Me.Combat} ${RWCWho}
            /if (!${Select[${RezType},rez,rezooc,rezcombat]}) {
                /if (${RezType.NotEqual[null]}) /echo invalid Rez Tag: ${RezType} ${i}
                /break
            }
            /if (${Me.CombatState.Equal[COMBAT]} || ${SpawnCount[xtarhater radius ${MeleeDistance}]}) {
                /if (${RezType.Equal[rezooc]}) /continue
            } else {
                /if (${RezType.Equal[rezcombat]}) /continue
            }
            /call CastReady "${AutoRez[${i}].Arg[1,|]}" rezwithcheck
            /if (${Bool[${Macro.Return}]}) {
                /if (${RWCWho.NotEqual[status]}) {
                    /if (!${ConOn} || !${AutoRez[${i}].Find[|cond]} || ${If[${Cond[${AutoRez[${i}].Mid[${Math.Calc[${AutoRez[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
                        /varset RezWithS ${AutoRez[${i}].Arg[1,|]}
                        /break
                    }
                } else {
                    /varset RezWithS ${AutoRez[${i}].Arg[1,|]}
                    /break
                }
            }
        /next i
        DEBUGHEALS RezWithCheck Leave ${RezWithS} ${Macro.Return}
    /return ${RezWithS}
| -------------------------------------------------------------------------------------
| SUB: Rez Check
| -------------------------------------------------------------------------------------
    Sub RezCheck(string RCWho)
        | Don't rez if AutoRezOn=0.  AutoRezOn=1 dmzone not instanced like pok, hovering, invis and no aggro, AutoRezOn=2 and aggro(rez after combat setting)
        /if (!${AutoRezOn}) /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Me.Hovering}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${AutoRezOn}==2 && ${AggroTargetID}) /return
        DEBUGHEALS RezCheck Enter
        /declare i int local
        /declare j int local
        /declare CorpseCount int local
        /declare RezMeID int local
        /declare RezID int local
        /declare RezRadius int local 150
        /declare RezXTarget int local 0
        /declare RezCheck1 string local null
        /declare RezCheckID int local 0
        /declare RezCheckTries int local 0
        /declare RezWith string local notready
        /declare RezWait timer local 0
        /declare RezName string local
        /call RezWithCheck status 0
        /varset RezWith ${Macro.Return}
        /if (${RezWith.Equal[notready]}) {
            DEBUGHEALS RezCheck RezWith Not Ready.
            /return
        }
        | Does mainassist have a corpse
        /varset RezID ${Spawn[pccorpse ${MainAssist} radius ${RezRadius} zradius 50].ID}
        /if (${RezID}) {
            /call RezWithCheck MA
            /varset RezWith ${Macro.Return}
            /if (${RezWith.NotEqual[notready]}) {
                /if (${RezWith.Find[Call of]} && !${SpawnCount[pc ${Spawn[${RezID}].CleanName.Left[-9]}]}) {
                    /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                    /if (${OOCRezTimer${RezID}}==0) {
                        /target id ${RezID}
                        /delay 10 ${Target.ID}
                        /if (${Target.Distance}>${CampRadius}) /corpse
                        /delay 10
                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckMA 0 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /call BroadCast o "REZZING MA =>> ${MainAssist} <<="
                            /varset OOCRezTimer${RezID} 1m
                        }
                    }
                }
            }
        }
        /if (${RCWho.Equal[ma]}) /return
        /if (!${RezMeLast}) {
            | Do I have a Corpse
            /varset RezMeID ${Spawn[pccorpse ${Me} radius ${RezRadius} zradius 50].ID}
            /if (${RezMeID}) {
                /call RezWithCheck ME
                /varset RezWith ${Macro.Return}
                /if (${RezWith.NotEqual[notready]}) {
                    /varset CorpseCount ${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}
                    /if (!${Defined[OOCRezTimer${RezMeID}]}) /declare OOCRezTimer${RezMeID} timer outer 0
                    /if (${OOCRezTimer${RezMeID}}==0) {
                        /target id ${RezMeID}
                        /delay 10 ${Target.ID}
                        /if (${Target.Distance}>${CampRadius}) /corpse
                        /delay 10
                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckME 0 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /call BroadCast o "REZZING ME =>> ${Me} <<="
                            /varset OOCRezTimer${RezMeID} 1m
                            /varset RezWait 20
                            /while (${CorpseCount}==${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]} && ${RezWait}) {
                                /delay 5
                            }
                            /if (${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}==0 && ${MountOn} && !${Me.Mount.ID} && ${Me.CombatState.NotEqual[COMBAT]} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]})) /call CastMount
                        }
                    }
                }
            }
            /if (${RCWho.Equal[me]}) /return
        }
        | Does Group Member have a corpse?
        /for i 1 to 5
            /call RezWithCheck group
            /varset RezWith ${Macro.Return}
            DEBUGHEALS RezCheck ${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Distance}<${RezRadius} ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Deity.ID} ${RezWith}
            /if (${RezWith.NotEqual[notready]}) {
                /if (${Group.Member[${i}].CleanName.Equal[${MainAssist}]}) /continue
                /if (!${Spawn[${Group.Member[${i}].CleanName} pccorpse].ID} || (${RezWith.Find[Call of]} && ${Group.Member[${i}].OtherZone}==FALSE)) /continue
                | Check for group member corpses and battle rez
                /if (${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Distance}<${RezRadius}) {
                    /squelch /tar id ${Spawn[${Group.Member[${i}].CleanName} pccorpse].ID}
                    /delay 10 ${Target.ID}
                    /if (${Target.Distance}<100) {
                        /if (${Target.Distance}>${CampRadius}) /corpse
                        /delay 10
                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckG 0 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /if (${CombatStart}) {
                                /call BroadCast o "BATTLE REZZED =>> ${Group.Member[${i}]} <<="
                                /varset BattleRezTimer${i} 3m
                            } else {
                                /call BroadCast o "REZZED =>> ${Group.Member[${i}]} <<="
                                /varset BattleRezTimer${i} 1m
                            }
                            /squelch /target clear
                            /if (${RezWith.Find[Call of]}) /varset BattleRezTimer${i} 6m
                        } else {
                            /if (${Group.Member[${i}].Name.NotEqual[${MainAssist}]}) /varset BattleRezTimer${i} 1m
                        }
                    }
                }
            }
        /next i
        /if (${RezMeLast}) {
            | Do I have a Corpse
            /varset RezMeID ${Spawn[pccorpse ${Me} radius ${RezRadius} zradius 50].ID}
            /if (${RezMeID}) {
                /call RezWithCheck ME
                /varset RezWith ${Macro.Return}
                /if (${RezWith.NotEqual[notready]}) {
                    /varset CorpseCount ${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}
                    /if (!${Defined[OOCRezTimer${RezMeID}]}) /declare OOCRezTimer${RezMeID} timer outer 0
                    /if (${OOCRezTimer${RezMeID}}==0) {
                        /target id ${RezMeID}
                        /delay 10 ${Target.ID}
                        /if (${Target.Distance}>${CampRadius}) /corpse
                        /delay 10
                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckME 0 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /call BroadCast o "REZZING ME =>> ${Me} <<="
                            /varset OOCRezTimer${RezMeID} 1m
                            /varset RezWait 20
                            /while (${CorpseCount}==${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]} && ${RezWait}) {
                                /delay 5
                            }
                            /if (${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}==0 && ${MountOn} && !${Me.Mount.ID} && ${Me.CombatState.NotEqual[COMBAT]} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]})) /call CastMount
                        }
                    }
                }
            }
            /if (${RCWho.Equal[me]}) /return
        }
        | Out of Combat Rez |
        /if (!${CombatStart}) {
            | Rez Guild, Fellowship and XTarget members.
            /varset CorpseCount ${SpawnCount[pccorpse radius ${RezRadius} zradius 50]}
            /if (${CorpseCount}>0) {
                /for j 1 to ${CorpseCount}
                    /call RezWithCheck XTARGET
                    /varset RezWith ${Macro.Return}
                    /if (${RezWith.Equal[notready]}) /return
                    /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
                    /if (${RezMeID} && ${RezMeID}==${RezID}) /continue
                    /if (${XTarHeal}) {
                        /for i 1 to ${XSlotTotal}
                            /if (${XTarToHeal[${i}]}==0) /continue
                            /if (${XTarToHeal[${i}]}==${XTSlot}) /continue
                            /if (${Me.XTarget[${XTarToHeal[${i}]}].ID} && ${Me.XTarget[${XTarToHeal[${i}]}].Type.Equal[corpse]} && ${Me.XTarget[${XTarToHeal[${i}]}].ID}==${RezID}) {
                                DEBUGHEALS CRezheck:  -- XTarget Corpse Found: ${i} ${Me.XTarget[${XTarToHeal[${i}]}].Name}
                                /varset RezXTarget ${Me.XTarget[${XTarToHeal[${i}]}].ID}
                            }
                            /if (${RezXTarget}) /break
                        /next i
                    }
                    /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
                        /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                        DEBUGHEALS RezCheck ${OOCRezTimer${RezID}} ${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID} ${RezXTarget}
                        /if (${OOCRezTimer${RezID}}==0 && (${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} || ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID} || ${RezXTarget}==${RezID})) {
                            | If call of wild and toon in zone skip
                            /if (${RezWith.Find[Call of]} && ${SpawnCount[pc ${Spawn[${RezID}].CleanName.Left[-9]}]}) /continue
                            /target id ${RezID}
                            /delay 10 ${Target.ID}==${RezID}
                            /if (${Target.Distance}<=${RezRadius}) {
                                /varset RezName ${Target.CleanName}
                                /call CastWhat "${RezWith}" ${Target.ID} RezCheckX 0 0
                                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                    /call BroadCast o "Rezzing =>> ${RezName} <<="
                                    /varset OOCRezTimer${RezID} 3m
                                    /squelch /target clear
                                }
                            }
                        }
                    }
                /next j
            }
            /if (${AutoRezAll}) {
                /varset CorpseCount ${SpawnCount[pccorpse radius ${RezRadius} zradius 50]}
                /if (${CorpseCount}>0) {
                    /for j 1 to ${CorpseCount}
                        /call RezWithCheck rezall
                        /varset RezWith ${Macro.Return}
                        /if (${RezWith.Equal[notready]}) /return
                        /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
                        /if (${RezMeID} && ${RezMeID}==${RezID}) /continue
                        /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
                            /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                            /if (${OOCRezTimer${RezID}}==0) {
                                /if (${CorpseRezCheck.Find[${RezID}:]}) {
                                    /varset i 1
                                    /while (${CorpseRezCheck.Arg[${i},|].NotEqual[null]}) {
                                        /if (${CorpseRezCheck.Arg[${i},|].Find[${RezID}:]}) {
                                            /varset RezCheck1 ${CorpseRezCheck.Arg[${i},|]}
                                            /varset RezCheckID ${RezCheck1.Arg[1,:]}
                                            /varset RezCheckTries ${RezCheck1.Arg[2,:]}
                                        }
                                        /varcalc i ${i}+1
                                    }
                                } else {
                                    /varset RezCheck1 null
                                    /varset RezCheckID ${RezID}
                                    /varset RezCheckTries 0
                                }
                                /if (${RezCheckTries}<3) {
                                    /target id ${RezID}
                                    /delay 10 ${Target.ID}==${RezID}
                                    /if (${Target.Distance}<=${RezRadius}) {
                                        /varset RezName ${Target.CleanName}
                                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckA 0 0
                                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                            /varcalc RezCheckTries ${RezCheckTries}+1
                                            /call BroadCast o "Rezzing =>> ${RezName} for the ${RezCheckTries} Time<<="
                                            /varset OOCRezTimer${RezID} 3m
                                            /if (${RezCheck1.NotEqual[null]}) {
                                                /varset CorpseRezCheck ${CorpseRezCheck.Replace[${RezCheck1}|,${RezCheckID}:${RezCheckTries}|]}
                                            } else {
                                                /varset CorpseRezCheck ${RezCheckID}:${RezCheckTries}|${CorpseRezCheck}
                                            }
                                            /squelch /target clear
                                        }
                                    }
                                }
                            }
                        }
                    /next j
                } else {
                    /varset i 1
                    /while (${CorpseRezCheck.Arg[${i},|].NotEqual[null]}) {
                        /varset RezCheck1 ${CorpseRezCheck.Arg[${i},|]}
                        /varset RezCheckID ${RezCheck1.Arg[1,:]}
                        /varset RezCheckTries ${RezCheck1.Arg[2,:]}
                        /if (${Spawn[id ${RezCheckID}].ID}==0 || (${Spawn[id ${RezCheckID}].ID} && ${Spawn[id ${RezCheckID}].Type.NotEqual[corpse]})) {
                            /varset CorpseRezCheck ${CorpseRezCheck.Replace[${RezCheck1}|,]}
                            /if (${Defined[OOCRezTimer${RezCheckID}]}) /deletevar OOCRezTimer${RezCheckID}
                        } else {
                            /varcalc i ${i}+1
                        }
                    }
                }
            }
        }
        DEBUGHEALS RezCheck Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Loot Stuff
| -------------------------------------------------------------------------------------
    Sub LootStuff
        /if (!${LootOn} || (!${Me.UseAdvancedLooting} && ${AggroTargetID}) || (${IAmMA} && ${AggroTargetID}) || (${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Invis}) /return
        DEBUGN LootStuff: Enter
        /if (${Me.FreeInventory}==0) {
            /echo Inventory is full. Looting OFF
            /varset LootOn 0
            /if (${Defined[NALStatus]}) {
                /varset NALStatus 0
            }
            /return
        }
        /doevents
        /if (${Me.UseAdvancedLooting}) {
            /if (${Bool[${Plugin[MQ2AutoLoot]}]}) {
                /if (${AutoLoot.Active}) /return
            }
            /call UseAdvLoot
        } else {
            /call LootMobs
        }
        /call DoWeMove 0 lootstuff
        DEBUGN LootStuff: Leave
    /return
| -------------------------------------------------------------------------------------
|   Sub MobRadar
| -------------------------------------------------------------------------------------
    Sub MobRadar(string RadarCheck,int CountRadius,string calledfrom)
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        DEBUGN MobRadar ${CountRadius} Enter ${calledfrom} ${RadarCheck}
        /declare NMob              int      local
        /declare i                 int      local
        /declare i_CorpseCount     int      local 0
        /if (${RadarCheck.Equal[los]}) {
            /varset MobCount ${SpawnCount[npc targetable los radius ${CountRadius} zradius 50 noalert 3]}
            /if (${MobCount}>0) {
                /for i 1 to ${MobCount}
                    /varset NMob ${NearestSpawn[${i},npc targetable los radius ${CountRadius} zradius 50 noalert 3].ID}
                    /if (${i}>${XSlotTotal}) /break
                    /if (${NMob} && (${Spawn[${NMob}].Type.Equal[Corpse]} || !${Spawn[${NMob}].ID})) {
                        |/call RemoveFromArray AddsArray ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}
                        /varcalc i_CorpseCount ${i_CorpseCount}+1
                    }
                    |} else /if (${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}==0) {
                    |    /call AddToArray AddsArray ${NMob}
                    |}
                /next i
                /varcalc MobCount ${MobCount}-${i_CorpseCount}
            }
        } else /if (${RadarCheck.Equal[xtar]}) {
            /if (${CountRadius}>0) {
                /varset i_CorpseCount ${SpawnCount[xtarhater npccorpse radius ${CountRadius} zradius 50]}
                /varcalc MobCount ${SpawnCount[xtarhater radius ${CountRadius} zradius 50]}-${i_CorpseCount}
            } else {
                /varset i_CorpseCount ${SpawnCount[xtarhater npccorpse]}
                /varcalc MobCount ${SpawnCount[xtarhater]}-${i_CorpseCount}
            }
        } else /if (${RadarCheck.Equal[pull]}) {
            /varset i_CorpseCount ${SpawnCount[npccorpse los loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius 50 noalert 3]}
            /varcalc MobCount ${SpawnCount[npc targetable los loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius 50 noalert 3]}-${i_CorpseCount}
        }
        DEBUGN MobRadar ${calledfrom} ${RadarCheck} ${MobCount} ${i_CorpseCount} ${XTSlot} ${Me.XTarget[${XTSlot}].ID} ${Me.XTarget[${XTSlot}].Type}
        | Check if NPC Pet is on Xtarget
        /if (!${MobCount} && ${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].Type.NotEqual[corpse]}) {
            DEBUGN MobRadar MobCount=0 but Mob on Xtarget Setting Mobcount to 1
            /varset MobCount 1
        } else /if (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]}) {
            /varcalc MobCount ${MobCount}+1
        }
        DEBUGN MobRadar Leave ${MobCount}
    /return


| -------------------------------------------------------------------------------------
| SUB: Add to Array
| -------------------------------------------------------------------------------------
    Sub AddToArray(ArrayName, int AddMobID)
        /if (!${AddMobID}) /return
        DEBUGN AddToArray ${AddMobID} Enter
        /declare i int local
        |/for i 1 to 13
        /for i 1 to ${XSlotTotal}
            /if (${${ArrayName}[${i},1].Equal[NULL]}) {
                /varset ${ArrayName}[${i},1] ${Spawn[${AddMobID}].ID}
                /varset ${ArrayName}[${i},2] ${Spawn[${AddMobID}].Level}
                /varset ${ArrayName}[${i},3] ${Spawn[${AddMobID}].CleanName}
                DEBUGN ARRAY Assign >> ${${ArrayName}[${i},3]} << to ${ArrayName}${i}.
                /return
            }
        /next i
        DEBUGN AddToArray Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Remove From Array
| -------------------------------------------------------------------------------------
    Sub RemoveFromArray(RArrayName, int ArNum)
        /if (${${RArrayName}[${ArNum},1].Equal[NULL]}) /return
        /if (${ArNum}<1 || ${ArNum}>${${RArrayName}.Size}) /return
        DEBUGN RemoveFromArray ${ArNum} Enter
        DEBUGN ARRAY Remove >> ${${RArrayName}[${ArNum},3]} << from ${RArrayName}${ArNum}.
        /varset ${RArrayName}[${ArNum},1] NULL
        /varset ${RArrayName}[${ArNum},2] NULL
        /varset ${RArrayName}[${ArNum},3] NULL
        /if (${MezOn} && ${ArNum}<=13) {
            /varset MezCount[${ArNum}] 0
            /varset MezTimer${ArNum} 0
        }
		/if (${CharmOn} && ${ArNum}<=13) {
            /varset CharmCount[${ArNum}] 0
            /varset CharmTimer${ArNum} 0
        }
        DEBUGN RemoveFromArray Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Add a friend to mq2posse list
| ----------------------------------------------------------------------------
    Sub Bind_AddAFriend
        /declare AFriend string local ${Target.CleanName}
        /if (!${Target.ID} || ${Spawn[${Target.ID}].Type.NotEqual[pc]} || ${Target.ID}==${Me.ID}) {
            /echo --ADDFRIEND: Target a PC to add your Posse list.
            /return
        }
        /docommand /posse add ${AFriend}
        /docommand /posse save
        /docommand /posse load
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind_ToggleVariable  Check whenever the player is changing any variable via /echo
| -------------------------------------------------------------------------------------
    Sub Bind_ToggleVariable(string Command, string Command2, string Command3)
        DEBUGN ${Command} ${Defined[${Command}]} ${Command2} ${Command3}
        /declare i int local
        /declare OnOff local
        | Toggle Variables & Set Variables
        /if (${Defined[${Command}]}) {
            DEBUGN ${Command}:${${Command}} ${Defined[${Command}]} ${Command2} ${Command3}
            /if (${Select[${Command2},0,1,on,off]}) {
                /if (${Select[${Command2},0,off]}) {
                    /varset ${Command} 0
                    /varset OnOff Off
                    DEBUGN ${OnOff} 1
                } else /if (${Select[${Command2},1,on]}) {
                    /varset ${Command} 1
                    /varset OnOff On
                    DEBUGN ${OnOff} 2
                }
            } else /if (${${Command}}) {
                /varset ${Command} 0
                /varset OnOff Off
                DEBUGN ${OnOff} 3
                /if (!${ChaseAssist} && ${Stick.Active}) /squelch /stick off
            } else {
                /varset ${Command} 1
                /varset OnOff On
                DEBUGN ${OnOff} 4
            }
            /if (${Command.Equal[ChaseAssist]}) {
                /if (${OnOff.Equal[on]}) {
                    /if (${Command3.NotEqual[null]} && ${Command3.Length}>0 && ${WhoToChase.NotEqual[${Command3}]}) {
                        /varset WhoToChase ${Command3}
                        /echo I Will Now Chase ${WhoToChase}
                    }
                    /if (${ReturnToCamp}) /varset ReturnToCamp 0
                    /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) /pet follow
                } else {
                    /if (${Stick.Active}) /squelch /stick off
                }
            | Turn on return to camp & set new y,x coord
            } else /if (${Command.Equal[ReturnToCamp]} && ${OnOff.Equal[on]}) {
                /varset CampXLoc ${Me.X}
                /varset CampYLoc ${Me.Y}
                /varset CampZLoc ${Me.FloorZ}
                /varset LookForward ${Me.Heading.DegreesCCW}
                | Turn off ChaseAssist if on
                /if (${ChaseAssist}) {
                    /varset ChaseAssist 0
                    /ini "${IniFileName}" "General" "ChaseAssist" "0"
                    /if (${Stick.Active}) /squelch /stick off
                    /echo >> ChaseAssist Off
                }
                /if (${CampZone}!=${Zone.ID}) /varset CampZone ${Zone.ID}
                /echo >> New camp set ${Me.Y}, ${Me.X}
            } else /if (${Command.Equal[AutoRezAll]}) {
                /if (${OnOff.Equal[off]}) {
                    /varset CorpseRezCheck null
                    /echo No longer Rezing Everyone.
                } else {
                    /echo Now Rezing Everyone.
                }
            } else /if (${Command.Equal[charmon]}) {
                /if (${OnOff.Equal[off]}) {
                    /if (${Defined[NALStatus]}) {
                        /varset NALStatus 0
                    }
                } else {
                    /if (${Defined[NALStatus]}) {
                        /varset NALStatus 1
                    }
                }
			} else /if (${Command.Equal[charmkeep]}) {
                /if (${OnOff.Equal[off]}) {
                    /if (${Defined[NALStatus]}) {
                        /varset NALStatus 0
                    }
                } else {
                    /if (${Defined[NALStatus]}) {
                        /varset NALStatus 1
                    }
                }
            } else /if (${Command.Equal[dpsmeter]}) {
                /if (${DPSMeter}) {
                    /call CheckPlugin MQ2DPSAdv 1
                    /if (!${Macro.IsTLO[DPSAdv]}) {
                        /echo DPSAdv TLO not found. Turning off DPS meter.
                        /varset DPSMeter 0
                    }
                }
            } else /if (${Command.Equal[looton]}) {
                /if (${OnOff.Equal[off]}) {
                    /if (${Defined[NALStatus]}) {
                        /varset NALStatus 0
                    }
                } else {
                    /if (${Defined[NALStatus]}) {
                        /varset NALStatus 1
                    }
                }
            } else /if (${Command.Equal[targetswitchingon]}) {
                /if (${OnOff.Equal[on]}) {
                    /if (!${IAmMA}) {
                        /varset ${Command} 0
                        /varset OnOff off
                    }
                }
            }
            DEBUGN ${Command} ${Command2} ${Command3}
            /echo >> Setting: (${Command}) to (${If[${Select[${OnOff},on,1]}>0,On,Off]})
        } else /if (${Command.Equal[waithere]}) {
            /varset ChaseAssist 0
            /varset ReturnToCamp 0
            /if (${Stick.Active}) /squelch /stick off
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: DoMiscStuff
| -------------------------------------------------------------------------------------
    Sub DoMiscStuff
        /if (!${ChainPull} && (${CombatStart} || ${AggroTargetID})) /return
        DEBUGN DoMiscStuff Enter
        | Accept trades
        /if (${Window[TradeWnd].Open} && ${Window[TradeWnd].HisTradeReady} && !${Cursor.ID}) /notify TradeWnd TRDW_Trade_Button leftmouseup
        | Accept group invite
        /if (${Window[GroupWindow].Child[GW_FollowButton]} && ${AcceptInvitesOn}) /invite
        | Ditch wizards familiar
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]} && ${Me.Class.ShortName.Equal[Wiz]}) /pet get lost
        | Drop random items on cursor like drive by mod rods into inventory after 30s min
        /if (${Cursor.ID}) /call CheckCursor DoMiscStuff 0
        | Paint the radius's on the map.
        /if (!${MapSet}) {
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
                /call PullRangeSet
                /call PaintMap
            } else {
                /varset MapSet 1
            }
        }
        /if (${PullPause.Arg[1,|].NotEqual[0]}) {
            /if (!${PullHold} && !${PullWaitTimer2}) {
               /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
               /varset PullWaitTimer2 ${PullPause.Arg[2,"|"]}m
            }
            /if (!${PullWaitTimer1}) {
                /if (${PullWaitRemaining} && ${PullHold}==2) /varset PullHold 0
                /if (!${PullHold}) {
                    /if (!${PullWaitRemaining}) {
                        /echo Pausing Pulls for ${PullPause.Arg[2,"|"]} Minutes.
                    } else {
                        /echo Resuming Medding after interrupt.
                    }
                    /if (${ReturnToCamp}) /call DoWeMove 1 DoMiscStuff
                    /varset PullHold 2
                    /varset PullWaitTimer1 ${PullPause.Arg[2,"|"]}m
                    /call DoWeMed 1 0 "" 100
                } else /if (${PullHold}==2) {
                    /echo Resetting Pull Timer for ${PullPause.Arg[1,"|"]} Minutes.
                    /varset PullHold 0
                    /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
                    /varset PullWaitTimer2 ${PullPause.Arg[2,"|"]}m
                }
            }
        }
        DEBUGN DoMiscStuff Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Can I do Stuff  - Check if invis moving ducked etc
| -------------------------------------------------------------------------------------
    Sub CanIDoStuff
        /if ((${CombatStart} || ${AggroTargetID} || ${Me.CombatState.NotEqual[COMBAT]})) /return
        DEBUGN CanIDoStuff Enter
        /declare DoLoop int local 1
        /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0)) {
            /varset IAmDead 0
            /if (${IAmABard}) {
                /call CastBardCheck
                /varset Twisting 0
                /varset DPSTwisting 0
            }
        }
        | Turn off Medley while invis
        /if (${Me.Invis} && ${IAmABard}) {
            /if (${Medley.Active}) /call CastBardCheck 0
        }
        | Assign Master looter
        /if (${Select[${Me},${Group.Leader}]}==1) /call AssignLooter
        /while (${DoLoop}) {
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            /call WriteDebuffs
            /call RogueStuff
            /delay 2
            /call EndMacroIf
            /if (${Debug} && ${Me.Invis}) /echo You are invisible.
            /if (${Me.Moving} || ${Me.State.Equal[feign]} || (${ChaseAssist}==0 && ${AggroTargetID}==0 && ${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || ${Me.Stunned} || ${Me.Ducking}  || (${Me.State.Equal[BIND]} && !${Window[LootWnd].Open})) /continue
            /if (${Window[MerchantWnd]} || ${Window[GiveWnd]} || ${Window[SpellBookWnd]} || ${Window[BigBankWnd]} || ${Window[BankWnd]} || ${Window[GuildBankWnd]}  || ${Window[TributeMasterWnd]} || ${Window[GuildTributeMasterWnd]}) /continue
            /varset DoLoop 0
        }
        DEBUGN CanIDoStuff Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Mercs Do What
| -------------------------------------------------------------------------------------
    Sub MercsDoWhat
        /if (!${MercOn}) /return
        /if (${Group.Member[1].Owner.Name.Equal[${Me}]}) /varset MyMerc ${Group.Member[1].Name}
        DEBUGN MercsDoWhat Enter
        /if (${Mercenary.State.Equal[Active]}) /varset MercInGroup 1
        | Revive the merc if dead and previously detected in group
        /if (${MercInGroup} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Mercenary.State.Equal[DEAD]}) /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
        /if (!${MercAssisting}) {
            /if (${MercAssistAt}>=${Spawn[${MyTargetID}].PctHPs} && ${Mercenary.State.Equal[Active]} && (${CombatStart} || ${Select[${Role},Puller]} && ${Pulled})) {
                /mercassist
                DEBUGCOMBAT MercsDoWhat1 ${Spawn[${MyTargetID}].CleanName} %:${Spawn[${MyTargetID}].PctHPs} ID:${Spawn[${MyTargetID}].ID}
                /varset MercAssisting ${MyTargetID}
            }
        } else /if (${MyTargetID} && ${MercAssisting}!=${MyTargetID}) {
            /mercassist
            DEBUGCOMBAT MercsDoWhat2 ${Spawn[${MyTargetID}].CleanName} %:${Spawn[${MyTargetID}].PctHPs} ID:${Spawn[${MyTargetID}].ID}
            /varset MercAssisting ${MyTargetID}
        } else /if (!${MyTargetID}) {
            /varset MercAssisting 0
        }
        DEBUGN MercsDoWhat Leave
    /return
| -------------------------------------------------------------------------------------
| Sub Assign Main Assist
| -------------------------------------------------------------------------------------
    Sub AssignMainAssist(string AssignTarget)
        DEBUGN AssignMainAssist Enter ${Role}
        /if (${AssignTarget}) {
            /if (${Select[${Role},pettank,pullerpettank,hunterpettank,tank,pullertank,hunter]}) {
                /target id ${Me.ID}
                /delay 10 ${Target.ID}==${Me.ID}
            } else /if (${Select[${Role},assist,offtank,puller,petassist]}) {
                /if (!${MainAssist.Length} || ${MainAssist.Equal[null]}) {
                    /if (${Target.ID}) {
                        /if (${Target.ID}==${Me.ID}) {
                            /echo Invalid Role(${Role}) for you to be the MA. Please provide a proper target and/or change your Role, and restart the macro.
                            /beep
                            /endmacro
                        } else /if (!${Select[${Target.Type},Mercenary,PC,Pet]}) {
                            /echo ERROR: You have >> ${Target.CleanName} << targeted. Please target a Mercenary, PC or Pet for Main Tank and restart the macro.
                            /beep
                            /endmacro
                        }
                    } else {
                        /echo No MainAssist Target. Please target Main Tank and restart macro.
                        /beep
                        /endmacro
                    }
                } else {
                    /if (${Spawn[=${MainAssist} pc].ID}) {
                        /tar id ${Spawn[=${MainAssist} pc].ID}
                        /delay 10 ${Target.ID}==${Spawn[=${MainAssist} pc].ID}
                    } else {
                        /echo Mainassist ${MainAssist} is no where to be found. Ending Macro.
                        /beep
                        /endmacro
                    }
                }
            } else /if (${Role.NotEqual[manual]}) {
                /echo Invalid Role: ${Role} Ending Macro.
                /beep
                /endmacro
            }
        }
        /varset MainAssist ${Target.CleanName}
        /varset MainAssistType ${Target.Type}
        /varset MainAssistClass ${Target.Class.ShortName}
        DEBUGN AssignMainAssist Leave
    /return
| -------------------------------------------------------------------------------------
| Sub Check Roles
| -------------------------------------------------------------------------------------
    Sub CheckRoles(int specialK)
        DEBUGN CheckRoles Enter
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]}) {
            | Make pet if it isn't up already !!!!
            /if (!${Me.Pet.ID}) {
                /echo My role is (${Role}), but I have no active pet.
                /echo Making my pet!
                /call DoPetStuff
            }
        }
        /if (${Select[${Role},assist,offtank]}) {
            DEBUGN Looks like I am ${Role}ing.
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=0
                /stick mod 0
            } else {
                /if (${MeleeOn} || ${DPSOn}) {
                    /if (${DStickHow.Equal[auto]}) {
                        /varset StickHow snaproll
                        /stick mod 0
                    } else {
                        /varset StickHow ${DStickHow}
                        /stick mod 0
                    }
                } else {
                    /varset StickHow 0
                }
            }
            /if (${Me.Pet.ID} && ${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
        } else /if (${Role.Equal[tank]}) {
            DEBUGN Looks like I am Main Tank. Wish me luck.
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset AssistAt 100
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=1
            } else {
                /if (${DStickHow.Equal[auto]}) {
                    /varset StickHow snaproll front moveback
                    /stick mod -2
                } else {
                    /varset StickHow ${DStickHow}
                    /stick mod -2
                }
            }
            /if (${Me.Pet.ID} && ${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
        } else /if (${Role.Equal[puller]}) {
            DEBUGPULL role puller
            DEBUGPULL Looks like I am Puller.
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=0
            } else {
                /if (${DStickHow.Equal[auto]}) {
                    /varset StickHow snaproll
                    /stick mod 0
                } else {
                    /varset StickHow ${DStickHow}
                    /stick mod 0
                }
            }
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID}) {
                /if (${Me.Pet.Distance}<=${CampRadius}) {
                    /pet guard
                } else {
                    /pet follow
                }
                /if (${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
            }
        } else /if (${Role.Equal[pullertank]}) {
            DEBUGPULL role pullertank
            DEBUGPULL Looks like I am Puller and Tank.
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /if (${DStickHow.Equal[auto]}) {
                /varset StickHow snaproll front moveback
                /stick mod -2
            }
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID}) {
                /if (${Me.Pet.Distance}<=${CampRadius}) {
                    /pet guard
                } else {
                    /pet follow
                }
                /if (${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
            }
        } else /if (${Select[${Role},hunter]}) {
            DEBUGPULLL role hunter
            DEBUGPULLL Looks like I am Hunting.
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /if (${StickHow.Equal[auto]}) {
                /varset StickHow moveback
                /stick mod -2
            }
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${ReturnToCamp}) {
                /varset ReturnToCamp 0
                /varset StayPut 0
            } else {
                /varset StayPut 1
                /varset PullOnReturn 1
            }
            /if (${Pet.ID}) {
                /pet follow
                /if (${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
            }
        } else /if (${Role.Equal[hunterpettank]}) {
            DEBUGPULL role hunterpettank
            DEBUGPULL Looks like I am Hunting and my pet is tanking.
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}
            /if (${ReturnToCamp}) {
                /varset ReturnToCamp 0
                /varset StayPut 0
            } else {
                /varset StayPut 1
                /varset PullOnReturn 1
            }
            /varset ChaseAssist 0
            /varset MountOn 0
            /if (${Pet.ID}) {
                /pet follow
                /if (!${Pet.Taunt}) /pet taunt on
            }
            /varset PetAssistAt 100
        } else /if (${Select[${Role},petassist]}) {
            DEBUGPULL role petassist
            DEBUGPULL Looks like I am assisting a pet.
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
        } else /if (${Select[${Role},pettank]}) {
            DEBUGPULL role pettank
            DEBUGPULL Looks like my pet is tanking.
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Me.Pet.ID} && !${Pet.Taunt}) /pet taunt on
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend} && ${specialK}) /call PetStateCheck
            /varset PetAssistAt 100
        } else /if (${Select[${Role},pullerpettank]}) {
            DEBUGPULL role pullerpettank
            DEBUGPULL Looks like I am pulling and my pet is tanking.
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset AssistAt 100
            /varset MeleeOn 0
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Me.Pet.ID} && !${Pet.Taunt}) /pet taunt on
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow
            /if (${PullRoleToggle} && ${Group.Leader.ID}!=${Me.ID}) {
                /echo You are set to toggle puller mode but are NOT the group leader.
                /echo Please correct this and restart KissAssist.
                /endmacro
            }
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend} && ${specialK}) /call PetStateCheck
            /varset PetAssistAt 100
        } else /if (${Role.Equal[manual]}) {
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
            /varset ReturnToCamp 0
            /varset ChaseAssist 0
            /varset DPSOn 0
            /varset BuffsOn 0
            /varset DebuffAllOn 0
            /if (${Defined[HealsOn]}) /varset HealsOn 0
            /if (${Defined[MezOn]}) /varset MezOn 0
        }
        /if (${TargetSwitchingOn} && !${IAmMA}) /varset TargetSwitchingOn 0
        /if (${StickHow.Equal[null]} || ${StickHow.Equal[auto]}) /varset StickHow 0
        /if (${Select[${Role},puller,pullerpet]}==0 && ${ChainPull}) /varset ChainPull 0
        /if (!${Role.Find[puller]} && !${Role.Find[hunter]}) /varset PullPause 0
        /if (!${PetAttackRange} && ${PetAttackDistance}) /varset PetAttackRange ${PetAttackDistance}
        /if (${MezOn}) {
            /if (${MezDebuffOnResist}) {
                /if (!${Me.AltAbility[${MezDebuffSpell}]} && !${FindItem[=${MezDebuffSpell}].ID} && !${Me.Book[${MezDebuffSpell}]}) {
                    /varset MezDebuffOnResist 0
                    /echo Setting MezDebuffOnResist off. Could not Find MezDebuffSpell: ${MezDebuffSpell}.
                }
            }
        }
        DEBUGN CheckRoles Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: PaintMap
| -------------------------------------------------------------------------------------
    Sub PaintMap
        DEBUGPULL PaintMap Enter - ${MapSet} - ${Math.Distance[${CampYLoc},${CampXLoc}]} - ${CampRadius}
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
            /if (${Bool[${Plugin[MQ2Map]}]}) {
                /if (!${MapSet}) {
                    /squelch /mapfilter CastRadius ${PullRange}
                    /squelch /mapfilter SpellRadius ${MaxRadius}
                    /squelch /mapfilter PullRadius ${MaxRadius}
                    /squelch /mapfilter CampRadius ${CampRadius}
                }
            }
            /varset MapSet 1
        }
        DEBUGPULL PaintMap Leave
    /return
|-------------------------------------------------------------------------------------
| SUB: Exchange Item.
|-------------------------------------------------------------------------------------
    Sub ExchangeItem(string prm_Item, string prm_exToSlot, int prm_deleteFlag, int prm_autoInvFlag, int prm_autoAttuneFlag)
        /declare int_slotNo1 int local 0
        /declare int_slotNo2 int local 0
        /declare str_slotName1 string local
        /declare str_slotName2 string local
        /declare tim_timer1 timer local 0
        /declare bol_attuneable bool local false
        /declare bol_noTrade bool local false
        /if (!${FindItemCount[=${prm_Item}]}) /return
        DEBUG ExchangeItem: Enter ${prm_Item} ${prm_exToSlot} ${prm_autoInvFlag}
        /if (${Cursor.ID}) /call CheckCursor ExchangeItem
        /if (${Cursor.ID}) {
            /beep
            /echo Your Inventory is full. This process needs open inventory slots for this to work.
            /return
        }
        /if (!${Select[${prm_exToSlot},charm,leftear,head,face,rightear,neck,shoulder,arms,back,leftwrist,rightwrist,ranged,hands,mainhand,offsand,leftfinger,rightfinger,chest,legs,feet,waist,powersource,ammo]}) {
            /echo Invalid Item slot ${prm_exToSlot}, must be valid Equipment/Armor slot.
            /return
        }
        /if (${Me.Inventory[${prm_exToSlot}].Name.Equal[${prm_Item}]}) {
            /echo You already have item ${prm_Item} equiped.
            /return
        }
        /varcalc int_slotNo1 ${Int[${FindItem[=${prm_Item}].ItemSlot}]}
        /if (${int_slotNo1}>32) {
            /echo Item ${prm_Item} is not in your characters Inventory.
            /return
        } else /if (${int_slotNo1}<23) {
            /echo Item is already equiped in slot number ${int_slotNo1}
            /return
        }
        /if (${Me.Inventroy[${int_slotNo1}].Container}) {
            /varcalc int_slotNo2 ${Int[${FindItem[=${prm_Item}].ItemSlot2}]}+1
        } else {
            /varset int_slotNo2 0
        }
        /varcalc int_slotNo1 ${int_slotNo1}-22
        | Check if there is an item in the target Slot we are exchanging to.
        /if (${Me.Inventory[${prm_exToSlot}].ID}) {
            /varset str_slotName1 ${Me.Inventory[${prm_exToSlot}].Name}
        } else {
            /varset str_slotName1 null
        }
        |Pick up item on cursor
        /if (${int_slotNo2}) {
            /nomodkey /itemnotify in pack${int_slotNo1} ${int_slotNo2} leftmouseup
        } else {
            /nomodkey /itemnotify pack${int_slotNo1} leftmouseup
        }
        | Wait for item to show on cursor.
        /varset tim_timer1 20
        /while (!${Cursor.ID} && ${tim_timer1}) {
            DOPARSE
            /delay 5
        }
        /if (!${Cursor.ID}) {
            /echo Could Not pick up the item ${prm_Item}. Exiting.
            /return
        } else {
            /varset bol_noTrade ${Cursor.NoDrop}
            /varset bol_attuneable ${Cursor.Attunable}
        }
        |Put Item in Target Slot.
        /nomodkey /itemnotify ${prm_exToSlot} leftmouseup
        /if (${bol_attuneable} && !${bol_noTrade}) /delay 10
        | If item is attuneable then lets attune it.
        /if (${bol_attuneable} && ${Cursor.ID}) {
            /delay 20 ${Window[confirmationdialogbox].Open}
            /if (${Window[confirmationdialogbox].Open}) {
                /if (${prm_autoAttuneFlag}) {
                    /notify confirmationdialogbox CD_Yes_Button leftmouseup
                } else {
                    /notify confirmationdialogbox CD_No_Button leftmouseup
                }
                /delay 20 !${Window[confirmationdialogbox].Open}
            }
        }
        | Wait for cursor to refresh with an item or nothing.
        /varset tim_timer1 20
        /if (${str_slotName1.NotEqual[null]}) {
            /while (${Cursor.Name.NotEqual[${str_slotName1}]} && ${tim_timer1}) {
                DOPARSE
                /delay 5
            }
        } else {
            /delay 10
        }
        |If this was exchanged with another item, then put the item in the originating slot.
        /if (${Cursor.Name.Equal[${str_slotName1}]}) {
            /if (${int_slotNo2}) {
                /nomodkey /itemnotify in pack${int_slotNo1} ${int_slotNo2} leftmouseup
            } else {
                /nomodkey /itemnotify pack${int_slotNo1} leftmouseup
            }
            /delay 10
        }
        | If item stuck on cursor lets drop it in inventory.
        /if (${Cursor.ID}) /autoinventory
        DEBUG ExchangeItem: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckStats
| -------------------------------------------------------------------------------------
    Sub CheckStats(int statcheck, charname, ckclass, cktype, stat, int pause,int resume)
        /if (!${statcheck}) /return
        /if (!${Spawn[${ckclass} ${cktype} ${charname}].ID}) /return
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}>${pause}) /return
        /declare SearchList     string local
        /declare SearchCount    int    local
        DEBUGN CheckStats Enter
        DEBUGN statcheck ${statcheck} charname ${charname} ckclass ${ckclass} stat ${stat} pause ${pause} resume ${resume}
        /if (${Role.Equal[puller]} && ${ChainPull} ) {
            /call MobRadar los ${MeleeDistance} CheckStats
            /if (${MobCount}>0) {
                /varset PullHold 1
                /return
            }
        }
        | Add DanNet code here to get Mana/End levels and Not target character.
        |/if (${DanNetOn}) {
        |    /if (${Zone.ShortName.Find[_]}) {
        |        /varset SearchList ${DanNet.Peers[zone_${Zone.ShortName}]}
        |    } else {
        |        /varset SearchList ${DanNet.Peers[zone_${EverQuest.Server.Lower}_${Zone.ShortName}]}
        |    }
        |    /varset SearchCount ${SearchList.Count[|]}
        |    /if (${SearchCount} && ${SearchList.Find[${charname}]}) {
        |        /dquery ${charname} -q Me.Current${stat} -o DNout -t ${DanNetDelay}
        |        /if (${Int[${DNout}]}) {
        |            /if (${Int[${DNout}]}>${pause}) /return
        |        }
        |    }
        |}
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) {
            /call BroadCast t "Waiting for >> ${charname} << to med up to ${resume}% ${stat}."
        } else {
            /echo  Waiting for >> ${charname} << to med up to ${resume}% ${stat}.
        }
        | target toon to make sure they aren't at full mana due to lag
        /target id ${Spawn[${ckclass} ${cktype} ${charname}].ID}
        /delay 10
        /varset Pulling 0
        /call DoWeMed 2 ${Target.ID} "${stat}" ${resume}
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
            /call BroadCast t "${charname} is now above ${resume}% ${stat} resuming activity."
        } else {
           /echo ${charname} is now above ${resume}% ${stat} resuming activity.
        }
        /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
        /varset Medding 0
        /varset PullHold 0
 |       /if (${IAmABard} && ${TwistMed}) {
 |           /call CastBardCheck
 |       }
        /if (${PullPause.Arg[1,|].NotEqual[0]}) /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
        DEBUGN CheckStats Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckGroupStats
| -------------------------------------------------------------------------------------
    Sub CheckGroupStats(string ckstat)
        /if (!${ckstat.Length} || !${Group}) /return
        /declare ck_x      int      local
        /declare ck_Level  int      local 100
        /declare ck_Idx    int      local 0
        DEBUGN CheckGroupStats Enter - ${ckstat}
        /for ck_x 1 to 5
            /if (!${Group.Member[${ck_x}].ID} || ${Group.Member[${ck_x}].Type.Equal[corpse]} || ${Group.Member[${ck_x}].OtherZone}) /continue
            /if (${ckstat.Equal[mana]}) {
                /if (${Select[${Group.Member[${ck_x}].Class.ShortName},BER,MNK,ROG,WAR]}) /continue
                /if (${Group.Member[${ck_x}].CurrentMana}<${ck_Level}) {
                    /varset ck_Level ${Group.Member[${ck_x}].CurrentMana}
                    /varset ck_Idx ${ck_x}
                }
            } else {
                /if (!${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /continue
                /if (${Group.Member[${ck_x}].CurrentEndurance}<${ck_Level}) {
                    /varset ck_Level ${Group.Member[${ck_x}].CurrentEndurance}
                    /varset ck_Idx ${ck_x}
                }
            }
        /next ck_x
        | Add DanNet code here to get Mana/End levels and Not target character.
        |/if (${DanNetOn}) {
        |    /if (${Zone.ShortName.Find[_]}) {
        |        /varset SearchList ${DanNet.Peers[zone_${Zone.ShortName}]}
        |    } else {
        |        /varset SearchList ${DanNet.Peers[zone_${EverQuest.Server.Lower}_${Zone.ShortName}]}
        |    }
        |    /varset SearchCount ${SearchList.Count[|]}
        |    /if (${SearchCount} && ${SearchList.Find[${charname}]}) {
        |        /dquery ${charname} -q Me.Current${ckstat} -o DNout -t ${DanNetDelay}
        |        /if (${Int[${DNout}]}) {
        |            /if (${Int[${DNout}]}>${pause}) /return
        |        }
        |    }
        |}
        DEBUGN CheckGroupStats Leave
    /return ${ck_Idx}
| -------------------------------------------------------------------------------------
| SUB: alert clear
| -------------------------------------------------------------------------------------
    Sub AlertClearList(int ListToClear, string SentFrom)
        DEBUGPULL AlertClearList Enter
        DEBUGPULL Clearing Alert list ${ListToClear}.
        /squelch /alert clear ${ListToClear}
        DEBUGPULL AlertClearList Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Assign Group Role
| -------------------------------------------------------------------------------------
    Sub AssignGroupRole(ASGOnOff, AGRName, AGRRole)
        DEBUGN AssignGroupRole ${ASGOnOff} ${AGRName} ${AGRRole}
        /docommand /grouproles ${ASGOnOff} ${AGRName} ${AGRRole}
        /delay 10
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Switch
| ----------------------------------------------------------------------------
    Sub Bind_Switch(int lockOnFlag, int newTargetID)
        /if (${IAmMA}) /return

        /declare WasAttacking int local ${Attacking}
        /if (!${newTargetID}) {
            /echo New target called! Assisting...
        } else {
            /echo New target called! ${Spawn[id ${newTargetID}].CleanName}
        }
        /call CombatReset 1 switch
        /if (!${newTargetID}) {
            /call Assist
        } else {
            /squelch /target clear
            /delay 10 !${Target.ID}
            /target id ${newTargetID}
            /delay 10 ${Target.ID}
            /if (${XTarAutoSet} && !${Group.Member[${MainAssist}].Index} && ${Me.XTarget[${XTSlot}].ID}!=${newTargetID} && ${Target.Type.NotEqual[PC]}) /xtarget set ${XTSlot} currenttarget
            /varset MyTargetID ${Target.ID}
            /varset MyTargetName ${Target.CleanName}
            /varset LastTargetID ${MyTargetID}
        }
        /if (${lockOnFlag}) /varset TargetSwitchingOn 2
        /if (${WasAttacking}) {
            /squelch /attack on
            /varset Attacking 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind SwitchMA
| ----------------------------------------------------------------------------
    Sub Bind_SwitchMA(string newMA, string newRole, int DoWhatFlag)
        /declare newRole1 string local ${newRole}
        /declare WasAttacking int local ${Attacking}
        /if (${newMA.Length}==0 || ${newMA.Equal[null]}) /return
        /if (${newRole1.Length}==0 || ${newRole1.Equal[null]}) /varset newRole1 Tank
        /if (${DoWhatFlag}==0) {
            /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
                /bcg //switchma ${newMA} ${newRole1} 1
            } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
                /dgge /switchma ${newMA} ${newRole1} 1
            } else {
                /echo SwitchMA Command requires MQ2EQBC or DanNet Plugin to be loaded.
            }
        }
        /echo Switching Main Assist to ${newMA}
        /if (${newMA.Equal[${Me}]}) {
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset MainAssistType ${Me.Type}
            /varset MainAssistClass ${Me.Class.ShortName}
            /varset Role ${newRole1}
            /call CheckRoles 0
        } else /if (${Me.Pet.ID} && ${newMA.Equal[${Me.Pet.CleanName}]}) {
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset MainAssistType ${Me.Type}
            /varset MainAssistClass ${Me.Class.ShortName}
            /varset Role pettank
            /call CheckRoles 0
        } else {
            /varset MainAssist ${newMA}
            /varset IAmMA 0
            /varset MainAssistType ${Spawn[=${newMA}].Type}
            /varset MainAssistClass ${Spawn[=${newMA}].Class.ShortName}
            /if (${Role.NotEqual[${MyOriginalRole}]} ) {
                /varset Role ${MyOriginalRole}
                /call CheckRoles 0
            }
        }
        /call CombatReset 0 switchma
        /if (!${IAmMA}) {
            /call Assist
        } else {
            /call GetCombatTarget
        }
        /if (${WasAttacking} && ${Target.ID}) {
            /squelch /attack on
            /varset Attacking 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Change Var Int resets various interger settings from ini file
| ----------------------------------------------------------------------------
    Sub Bind_ChangeVarInt(ISection, IName, IVar)
        DEBUGN Bind_ChangeVarInt ${ISection} ${IName} ${IVar}
        /echo Changing ${IName} to ${IVar}
        /varset ${IName} ${IVar}
        /ini "${IniFileName}" "${ISection}" "${IName}" "${IVar}"
        /if (${IName.Find[mezon]}) {
            /if (!${Defined[MezTimer1]}) /call CreateTimersMez
		} else /if (${IName.Find[charmon]}) {
           /if (!${Defined[CharmTimer1]}) /call CreateTimersCharm
        } else /if (${IName.Find[dpson]}) {
            /if (!${Defined[DPSTimer1]}) /call CreateTimersDPS
        } else /if (${IName.Find[buffson]}) {
            /if (!${Defined[Buffs1Timer0]}) {
                /call CreateTimersBuffs
                /echo Buffs on creating timers
            }
		} else /if (${IName.Find[setcharmed]}) {
           /varset CharmPet ${Me.Pet.ID}
        } else /if (${IName.Equal[ChaseAssist]}) {
            /if (${IVar}) {
                /if (${ReturnToCamp}) {
                    | Why set whotochase here. by default whotochase is set to mainassist.
                    /ini "${IniFileName}" "General" "ReturnToCamp" "0"
                    /varset ReturnToCamp 0
                }
                /if (!${Stick.Active}) /varset RebuffOn 300
                /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) /pet follow
            } else {
                /if (${Stick.Active}) /squelch /stick off
            }
        } else /if (${IName.Equal[MaxRadius]}) {
            /varcalc CampRadiusExceed ${MaxRadius}+200
        } else /if (${IName.Equal[LootOn]}) {
            /if (!${LootOn}) {
                /if (${Defined[NALStatus]}) {
                    /varset NALStatus 0
                }
            } else {
                /if (${Defined[NALStatus]}) {
                    /varset NALStatus 1
                }
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind ChaseMe
| ----------------------------------------------------------------------------
    Sub Bind_ChaseMe
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //chase on ${Me.CleanName}
        } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
            /dgge /chase on ${Me.CleanName}
        } else {
            /echo ChaseMe command requires MQ2EQBC/MQ2DanNet plugin loaded.
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind StayHere
| ----------------------------------------------------------------------------
    Sub Bind_StayHere
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //waithere
        } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
            /dgge /waithere
        } else {
            /echo Stayhere command requires MQ2EQBC/MQ2DanNet plugin loaded.
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind MakeCampHere
| ----------------------------------------------------------------------------
    Sub Bind_MakeCampHere
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //camphere on
        } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
            /dgge /camphere on
        } else {
            /echo Makecamphere command requires MQ2EQBC/MQ2DanNet.
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Cast - To allow calling Kiss Internal Casting Routine
| ----------------------------------------------------------------------------
    Sub Bind_KissCast(string KCastWhat, int KWhatID, int ForceInterrupt)
        | castWhat,int WhatID,string sentFrom,int CondNumber
        /if (${KCastWhat.Equal[null]} || !${KCastWhat.Length}) /return
        /if (${Me.Hovering} || ${Me.Feigning}) /return
        DEBUGCAST Bind_KissCast Enter \aw ${KCastWhat} ID: ${KWhatID} ForceInterrupt: ${ForceInterrupt}
        /declare WasCastingSpell string local null
        | I am sure we will need to add code for Bards, But not just sure what to check.
        | Will come back later and add code.
        | ******************************************************************************
        | If I am casting, then I am in the middle of the castwhat routine and need to Interrupt
        | casting current spell(ForceInterrupt==1) or I need to exit this Bind Routine.
        | Start ************************************************************************
        /if (${Me.Casting.ID} && ${Window[CastingWindow].Open}) {
            /if (${ForceInterrupt}) {
                /varset WasCastingSpell ${Me.Casting}
                /stopcast
                /delay 5
            } else {
                /echo Skipped KissCasting ${KCastWhat} I am busy casting ${Me.Casting}
                /return
            }
        }
        | End ***************************************************************************
        | If a casting target was not passed then set myself as the casting target.
        /if (!${KWhatID}) /varset KWhatID ${Me.ID}
        DEBUGCAST Bind_KissCast \aw WhatID: ${KWhatID} ForceInterrupt: ${ForceInterrupt} WasCastingSpell: ${WasCastingSpell}
        /call CastWhat "${KCastWhat}" ${KWhatID} "KissCast" 0 0
        | If previous cast interrupted we need to let spell casting routine it is no longer valid and was cancelled.
        /if (${WasCastingSpell.NotEqual[null]}) {
            /varset CastResult CAST_CANCELLED
        } else {
            /varset CastResult CAST_NO_RESULT
        }
        DEBUGCAST Bind_KissCast \awLeave ${CastResult}
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Edit - Edit ini file in MQ2NotePad
| ----------------------------------------------------------------------------
    Sub Bind_KissE
        /if (!${Bool[${Plugin[MQ2Notepad]}]}) {
            /echo This function requires MQ2Notepad to be loaded..
            /echo 1. Please copy MQUI_NotepadWindow.xml to your Everquest/UIFiles/default or custom ui folder
            /echo 2. then /Plugin MQ2Notepad
        }
        /if (${Bool[${Plugin[MQ2Notepad]}]}) {
            /docommand /notepad kissassist_${Me}.ini
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Check - scan ini file for errors based on nostress KissNamechecker.mac
| ----------------------------------------------------------------------------
    Sub Bind_KissCheck
        /call ScanIni all 0
    /return
| ----------------------------------------------------------------------------
| SUB: AFK Tools from AHTools by Anonymous Hero
| ----------------------------------------------------------------------------
    Sub AFKTools
        /declare holding bool local
        |/if (${CampZone}!=${Zone.ID} || (${HealsOn} && ${AggroTargetID})) /return
        /if (${CampZone}!=${Zone.ID}) {
            /if (${CampOnDeath}) /call DoICampA
            /return
        }
        /if (${HealsOn} && ${AggroTargetID}) /return
        /if (${Select[${AFKToolsOn},1,2]}) {
            /if (${Macro.IsTLO[Posse]}) {
                /while (${Posse.Strangers}>=1) {
                    /if (!${holding}) {
                        /echo [AHTools] Macro on hold due to player activity in camp radius.
                        /call BroadCast r "**PCS DETECTED IN CAMP RADIUS**"
                        /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                        /varset holding 1
                    }
                    /delay 1s
                    /if (${DPSOn} || ${MeleeOn}) {
                        /call CheckForCombat 0 AFKTools1 0
                    } else {
                        /call CheckForCombat 1 AFKTools2 0
                    }
                    /doevents
                }
            } else {
                /varset holding 0
            }
        }
        /if (${Select[${AFKToolsOn},1,3]}) {
            |/if (${GMailEvents.Find[GM]} && ${SpawnCount[GM]}>=1) /call GmailSend "GM in Zone, ${Zone.ShortName}"
            /if (${SpawnCount[GM]}>=1) {
                /if (${AFKGMAction}==1) {
                    /while (${SpawnCount[GM]}>=1) {
                        /if (!${holding}) {
                            /echo [AHTools] Macro on hold due to GM Presence
                            /call BroadCast r "** GM DETECTED **"
                            /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                            /varset holding 1
                        }
                    }
                } else {
                    /varset holding 0
                }
                /if (${AFKGMAction}==2) {
                    /multiline ; /echo [AHTools] Ending Macro due to GM Presence ; /mq2log [AHTools] Ending Macro due to GM Presence ; /endmacro
                } else /if (${AFKGMAction}==3) {
                    /multiline ; /echo [AHTools] Unloading MQ2 due to GM Presence; /mq2log [AHTools] Unloading MQ2 due to GM Presence ; /unload
                } else /if (${AFKGMAction}==4) {
                    /multiline ; /echo [AHTools] Quitting out of EQ due to GM Presence ; /mq2log [AHTools] Quitting out of EQ due to GM Presence ; /quit
                }
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  Code from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Event_TooSteep
        /varset EventFlag 1
        /varset CampfireOn 0
        /echo Setting CampfireOn to 0. You are on a hill.
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  OriginalCode from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Bind_Campfire
        /if (!${CampfireOn}) /return
        /declare UseThisCampfire int local ${CampfireOn}
        /if (${Select[${Zone.ID},33506]}) /return
        /if (${ReturnToCamp}) /call DoWeMove 1 Bind_CampFire
        /if (${UseThisCampfire}>1) {
            /if (${FindItemCount[Fellowship Campfire Materials]}<1) {
                /varset UseThisCampfire 1
                /echo Fellowship Campfire Materials Not Found. Setting to Regular Fellowship.
            }
        }
        /windowstate FellowshipWnd open
        /delay 10
        /nomodkey /notify FellowshipWnd FP_Subwindows tabselect 2
        /if (${Me.Fellowship.Campfire}) {
            /if (!${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]}) {
                /nomodkey /notify FellowshipWnd FP_DestroyCampsite leftmouseup
                /delay 5s ${Window[ConfirmationDialogBox].Open}
                /if (${Window[ConfirmationDialogBox].Open}) {
                    /nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
                }
                /delay 5s !${Me.Fellowship.Campfire}
            }
        }
        /nomodkey /notify FellowshipWnd FP_RefreshList leftmouseup
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_CampsiteKitList listselect ${UseThisCampfire}
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_CreateCampsite leftmouseup
        /delay 5s ${Me.Fellowship.Campfire}
        /windowstate FellowshipWnd close
        /if (${Me.Fellowship.Campfire}) /echo Campfire Dropped
    /return
| ----------------------------------------------------------------------------
| SUB: Sort Array
| ----------------------------------------------------------------------------
    Sub SortArray(ArrayName, HiLo, SortHow)
        DEBUGN SortArray Enter ${ArrayName} ${HiLo} ${SortHow}
        /declare i                  int     local
        /declare j                  int     local
        /declare k                  int     local
        /declare l                  int     local
        /declare m                  int     local
        /declare TempSortedName     string  local ${HiLo}
        /declare TempPos            int     local 0
        /declare NewArrayPos        int     local 0
        /declare NewArraySize       int     local 0
        /declare TempArray[${${ArrayName}.Size}] string     local 0
        /declare TArray2[${${ArrayName}.Size}]   string     local 0
        /declare CArray[${${ArrayName}.Size}]    string     local TRUE
        /declare MArrayCount int    local 1
        /declare WArrayCount int    local 1
        /declare BArrayCount int    local 1
        /declare TempSwapHold       string  local
        /declare Swapped            int     local 1
        | Assign Array to temp array
        /for i 1 to ${${ArrayName}.Size}
            DEBUGN ${i} ${${ArrayName}[${i}]}
            /varset TempArray[${i}] ${${ArrayName}[${i}]}
        /next i
        /if (${ArrayName.Equal[dps]}) {
            /for i 1 to ${TempArray.Size}
                /if (${TempArray[${i}].Find[|weave]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset WeaveArray[${WArrayCount}] ${TempArray[${i}].Replace[|weave,]}
                    DEBUGN ${WeaveArray[${WArrayCount}]}
                    /if (${WArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc WArrayCount ${WArrayCount}+1
                } else /if (${TempArray[${i}].Find[|mash]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset MashArray[${MArrayCount}] ${TempArray[${i}].Replace[|mash,]}
                    DEBUGN ${MashArray[${MArrayCount}]}
                    /if (${MArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc MArrayCount ${MArrayCount}+1
                } else /if (${TempArray[${i}].Find[|ambush]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset BeforeArray[${BArrayCount}] ${TempArray[${i}].Replace[|ambush,]}
                    DEBUGN ${BeforeArray[${BArrayCount}]}
                    /if (${BArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc BArrayCount ${BArrayCount}+1
                }
            /next i
        }
        | Move Array to Temp Array leaving out useless entries.
        /for m 1 to ${${ArrayName}.Size}
            /if (${TempArray[${m}].Length} && !${TempArray[${m}].Find[|0]} && ${TempArray[${m}].NotEqual[null]}) {
                /if (!${Select[${ArrayName},Buffs,Burn]} && ${Int[${TempArray[${m}].Arg[2,|]}]}==0) {
                    /echo Invalid Format for: ${ArrayName}${m}=${TempArray[${m}]} Second Tag: ${TempArray[${m}].Arg[2,|]} Should be a Numeric Value.
                    /echo Skipping Entry. ${ArrayName}${m}. Please correct and restart macro.
                    /continue
                }
                /varcalc NewArrayPos ${NewArrayPos}+1
                /varset TArray2[${NewArrayPos}] ${TempArray[${m}]}
                /varcalc NewArraySize ${NewArraySize}+1
            }
        /next m
        |Sort the Array if needed
        /if (!${Select[${ArrayName},Buffs,Burn]} && ${NewArraySize}>1) {
            /varset m ${NewArraySize}
            /while (${Swapped} && ${m}>1) {
                /varset Swapped 0
                /for k 2 to ${m}
                    /varcalc j ${k}-1
                    /if (${TArray2[${j}].Arg[2,|]} ${SortHow} ${TArray2[${k}].Arg[2,|]}) {
                        /varset TempSwapHold ${TArray2[${j}]}
                        /varset TArray2[${j}] ${TArray2[${k}]}
                        /varset TArray2[${k}] ${TempSwapHold}
                        /varset Swapped 1
                    }
                /next k
                /varcalc m ${m}-1
            }
        }
        | Bail if array is empty and turn off switch
        /if (!${NewArraySize}) {
            /if (${Defined[${ArrayName}On]}) {
                /if (${${ArrayName}On}) {
                    /varset ${ArrayName}On 0
                    /echo ${ArrayName}
                    /if (${ArrayName.NotEqual[heals]} && ${ArrayName.NotEqual[burn]}) {
                        /echo ERROR1: ${ArrayName}On=1 but section is empty. Turning ${ArrayName} off. Please check your ini file.
                        /beep
                        /delay 10
                    } else /if (${ArrayName.Equal[heals]} && !${AutoRezOn}) {
                        /echo ERROR: ${ArrayName}On=1 but section is empty. Turning ${ArrayName} off. Please check your ini file.
                        /beep
                        /delay 10
                    }
                }
            }
            /return
        }
        /deletevar ${ArrayName}
        /declare ${ArrayName}[${NewArraySize}] string outer
        /for l 1 to ${NewArraySize}
            /varset ${ArrayName}[${l}] ${TArray2[${l}]}
            DEBUGN  ${${ArrayName}[${l}]}
        /next l
        /if (${ArrayName.Equal[buffs]}) /call CreateTimersBuffs
        /if (${ArrayName.Equal[dps]}) /call CreateTimersDPS
        DEBUGN ${${ArrayName}.Size}
        DEBUGN SortArray Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Creat Timers Buffs
| ----------------------------------------------------------------------------
    Sub CreateTimersBuffs
        | Declare timers for Buff duration spells
        /declare o int local
        /declare p int local
        | Create buff timer for all buff in array
        /for o 1 to ${Buffs.Size}
           | Create timers for everyone in group plus 2 extra for MA buffs
            /for p 0 to 7
                /if (!${Defined[Buff${o}GM${p}]}) {
                    /declare Buff${o}GM${p}     timer   outer   0
                } else {
                    /varset Buff${o}GM${p} 0
                }
                /if (${Buffs[${o}].Find[|begfor]}) {
                    /varset Buff${o}GM${p} 600
                }
                /if (${Debug}) {
                    /echo \atDEBUG Buff Timers:Buff${o}GM${p} ${Buff${o}GM${p}}
                    |/delay 1
                }
            /next p
        /next o
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers GoM
| ----------------------------------------------------------------------------
    Sub CreateTimersGoM
        | Declare timers for Rez duration spells
        /declare i int local
        /for i 1 to ${GoMSpell.Size}
            /if (!${Defined[GoMSpellTimer${i}]}) {
                /declare GoMSpellTimer${i} timer outer 0
            } else {
                /varset GoMSpellTimer${i} 0
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: ZCheck /call ZAxisCheck current ,Z to check, difference
| ----------------------------------------------------------------------------
    Sub ZAxisCheck(float Zcur, float Zdiff)
        | Move down if Z distance more than Zcheck due to levitation
        DEBUGN ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} Enter. - ${Me.FeetWet}
        /if (!${Me.FeetWet}) {
            /if (${Zcur}>=${Zdiff}) {
                /keypress CMD_MOVE_DOWN hold
                /delay 10 ${Math.Distance[${CampZLoc}:${Me.Z}]}<=${Zdiff}
                /keypress CMD_MOVE_DOWN
            }
        }
        DEBUGN ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} leave.
    /return
|-----------------------------------------------------------------------------
| SUB: Capture Tells
| ----------------------------------------------------------------------------
    Sub Event_YouGotTell(Message, Fwho, Swhat)
        /varset EventFlag 1
        |/if (${GMailEvents.Find[tells]}) {
            | The Fwho.Equal[${Me.CleanName}'s pet] does NOT work, so I split it to 2 Finds and this works.
            /if ((${Me.Pet.ID} && ${Spawn[${Fwho}].ID}==${Me.Pet.ID}) || (${Fwho.Find[${Me.CleanName}]} && ${Fwho.Find[s pet]})) /return
            /if (!${Me.Pet.ID} && ${Swhat.Find[, master.]} && ${Swhat.Find[I am unable to wake an]}) /return
            /if (${Select[${Spawn[${Fwho}].Type},NPC,PET]}) /return
            /echo ====> ${Fwho} Sent you a Tell: ${Swhat} <====
        |/call GmailSend "You Got Tell From ${Fwho}, ${Swhat}"
        |} else {
        |    /doevents flush YouGotTell
        |}
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Merc state 4 = no gold membership
| ----------------------------------------------------------------------------
    Sub WriteBuffsMerc
        /if (${Mercenary.State.NotEqual[Active]} || ${EverQuest.GameState.NotEqual[INGAME]}) /return
        /if (${WriteBuffsMercTimer}) /return
        /if (!${Redguides}) /return
        /if (${AggroTargetID}) /return
        /if (${DanNetOn}) /return
        DEBUGBUFF WriteBuffsmerc Enter
        /declare i int local 0
        /declare tSwitch int local 0
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Mercenary.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Mercenary.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Mercenary.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Mercenary.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        | You have to target your Merch to get Buffs.
  |      /if (${IAmABard} && ${DPSTwisting} && ${Twist}) {
  |          /call CastBardCheck
  |          /varset tSwitch 1
  |      }
        /target id ${Mercenary.ID}
        /delay 20 ${Target.BuffsPopulated}
        /for i 1 to 15
            DEBUGBUFF WriteBuffsMerc ${i} ${Mercenary.Buff[${i}]}
            /if (${Mercenary.Buff[${i}].Name.Length}) {
                /varset BuffList ${Mercenary.Buff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                DEBUGBUFF WriteBuffsMerc: ${i}-${BuffList}
                /varset Writebufflist ${Writebufflist}${BuffList}|
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Buffs "${Writebufflist}"
        |/delay 15
        |/if (${tSwitch}) /squelch /twist
        /varset WriteBuffsMercTimer 30s
        DEBUGBUFF WriteBuffsMerc Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Pet
| ----------------------------------------------------------------------------
    Sub WriteBuffsPet
        /if (!${Me.Pet.ID} || ${EverQuest.GameState.NotEqual[ingame]}) /return
        /if (${AggroTargetID}) /return
        |/if (!${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Spawn[${MainAssist} ${MainAssistType}].ID}!=${Me.Pet.ID}) /return
        /if (!${Select[${Role},pettank,pullerpettank,hunterpettank]}) /return
        /if (${WriteBuffsPetTimer}) /return
        /if (${DanNetOn}) /return
        /if (!${Redguides}) /return
        DEBUGBUFF WriteBuffPet Enter
        /declare i int local 0
        /declare k int local 0
        /declare tSwitch int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        | Do I need to Target my pet here?
        |/if (${IAmABard} && ${DPSTwisting} && ${Twist}) /squelch /twist off
 |       /if (${IAmABard} && ${DPSTwisting} && ${Twist}) {
 |           /call CastBardCheck
 |           /varset tSwitch 1
 |      }
        /target id ${Me.Pet.ID}
        /delay 20 ${Target.BuffsPopulated}
        /for i 1 to 50
            DEBUGBUFF WriteBuffPet ${i} ${Target.Buff[${i}]}
            /if (${Me.PetBuff[${i}].Name.Length}) {
                /varset BuffList ${Me.PetBuff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                DEBUGBUFF WriteBuffPet: ${i}-${BuffList}
                /varset Writebufflist ${Writebufflist}${BuffList}|
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs "${Writebufflist}"
        /delay 15
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 0 to 39
            /varset Blockedbuff ${Me.BlockedPetBuff[${k}].Name}
            /if (${Blockedbuff.Length} && ${Blockedbuff.NotEqual[null]}) {
                /varset Blockedbufflist ${Blockedbufflist}${Blockedbuff}|
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedPetBuffWnd].Open}) /windowstate BlockedPetBuffWnd close
        |/if (${tSwitch}) /squelch /twist
        /varset WriteBuffsPetTimer 30s
        DEBUGBUFF WriteBuffsPet Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Clean Buffs File
| ----------------------------------------------------------------------------
    Sub CleanBuffsFile
        /if (${CleanBuffsTimer}) /return
        /declare i int local
        /declare SectionList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare SectionListCount int local ${SectionList.Count[|]}
        /if (${SectionListCount}==0) /return
        /varcalc SectionListCount ${SectionListCount}-1
        /declare SectionName string local
        /for i 1 to ${SectionListCount}
            /varset SectionName ${SectionList.Arg[${i},|]}
            DEBUGBUFF CleanBuffsFile ${i} ${SectionName} ${Math.Calc[${Ini["KissAssist_Buffs.ini",${SectionName},Day]}-${Time.Day}]} ${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]} Day: ${Time.Day} Hour: ${Time.Hour}
            /if (${Ini["KissAssist_Buffs.ini",${SectionName},Day].NotEqual[${Time.Day}]}) {
                /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
                /continue
            }
            /if (${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]}!=0) /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
        /next i
        /varset CleanBuffsTimer 10m
    /return
| ----------------------------------------------------------------------------
| SUB: Load SpawnMaster Entries
| ----------------------------------------------------------------------------
    Sub LoadSpawnMaster
        /squelch /alert clear 5
        /declare i int local
        /declare KeyList string local ${Ini["MQ2SpawnMaster.ini",${Zone.ShortName}]}
        /declare KeyListCount int local ${KeyList.Count[|]}
        /if (!${KeyListCount}) /return 0
        /varcalc KeyListCount ${KeyListCount}-1
        /declare KeyName string local
        /declare KeyValue string local
        /for i 1 to ${KeyListCount}
            /varset KeyName ${KeyList.Arg[${i},|]}
            /varset KeyValue ${Ini["MQ2SpawnMaster.ini",${Zone.ShortName},${KeyName}]}
            DEBUGN LoadSpawnMaster ${i} ${KeyName}=${KeyValue}
            /squelch /alert add 5 ${KeyValue}
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: WaitSubs - bunch of crap to call while medding standing around etc
| ----------------------------------------------------------------------------
    Sub WaitSubs (int waitFlag)
        DEBUGN WaitSubs Enter
        /if (${Me.Hovering}) /call PauseWhileHovering WaitSubs
        /call WriteDebuffs
        /if (${CuresOn}) {
            /call CheckCures WaitSubs
            /if (${HealsOn}) /call CheckHealth WaitSubs
        } else /if (${HealsOn}) {
            /call CheckHealth WaitSubs
        }
        /if (${MezOn}) {
            /call MezCheck WaitSubs
        }
        /call WriteBuffs
        /if (${AutoRezOn}) /call RezCheck all
        /call CanIDoStuff
        /call CastMana WaitSubs
        /if (${PetOn}) /call DoPetStuff
        /if (${CharmOn} && ${Me.Pet.ID}) /call DoPetStuff
        /if (${BuffsOn}) {
            /call CheckBuffs ${ForceBuffs}
            /varset ForceBuffs 0
            /if (${KABegActive}) /call CheckBegforBuffs
        }
        /if (${MercOn}) /call MercsDoWhat
        DEBUGN WaitSubs Leave
    /return
| ----------------------------------------------------------------------------
| SUB: BroadCast - Handles echos and messages in mq2irc and mq2eqbc
| ----------------------------------------------------------------------------
    Sub BroadCast(msgcolor, message)
        /if (${msgcolor.Equal[null]}) /varset msgcolor w
        /if (${EQBCOn}) {
            /if (${Macro.IsTLO[EQBC]}) {
                /if (${EQBC.Connected}) {
                    /if (TRUE) /${BroadCastSay} [+${msgcolor}+] [${Time}] ${message} [+x+]
                } else {
                    /echo You are NOT connected to an EQBC Server. Please check your connection.
                    /echo ${message}
                }
            } else {
                /echo EQBC is Required, but the plugin is NOT Loaded.
                /echo ${message}
            }
        } else /if (${DanNetOn}) {
            /if (${Macro.IsTLO[DanNet]}) {
                /if (${DanNet.PeerCount}) {
                    /if (TRUE) /${BroadCastSay} \a${msgcolor} [${Time}] ${message} \aw
                } else {
                    /echo DanNet is Loaded but no Peers are connected.
                    /echo ${message}
                }
            } else {
                /echo DanNet is Required, but the plugin is NOT Loaded.
                /echo ${message}
            }
        } else {
            /echo ${message}
        }
        /if (${Bool[${Plugin[MQ2IRC]}]} && ${IRCOn}) /i say ${message}
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire ${Window[FellowshipWnd].Child[FP_CampPage].Child[FP_CampsiteViewer].Text}
| ----------------------------------------------------------------------------
    Sub Campfire
        /if (!${CampfireOn}) /return
        /if (${CampfireTimer}) /return
        /if (${Me.Fellowship.CampfireZone.ID} && (${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]} || ${Me.Fellowship.CampfireZone.Name.Find[guild hall]})) /return
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) /return
        /if (${AggroTargetID}) /return
        /if (${CombatStart}) /return
        /if (${SpawnCount[pc radius 50 fellowship]}>=3) {
            /call Bind_Campfire
        } else {
            /echo Not enough fellowship members trying again in 5 minutes
            /varset CampfireTimer 5m
        }
        /doevents TooSteep
    /return
| ----------------------------------------------------------------------------
| SUB: IsSpawnNamed
| ----------------------------------------------------------------------------
    Sub IsSpawnNamed(int SpawnID1)
        /declare IsNamed1 bool local False
        /if (!${SpawnID1}) /return False
        /if (!${UseSpawnMaster}) {
            /if (${Spawn[${SpawnID1}].Named}) /varset IsNamed1 True
        } else {
            /if (${Alert[5].Size}) {
                /if (${SpawnCount[ID ${SpawnID1} alert 5]}) /varset IsNamed1 True
            }
        }
    /return ${IsNamed1}
| ----------------------------------------------------------------------------
| SUB: NamedWatch
| ----------------------------------------------------------------------------
    Sub NamedWatch(int IgnoreTarget)
        /declare IsNamed bool local False
        /if (!${BurnAllNamed}) {
            | For GMail Notify Only
            |/if (${GMailEvents.Find[named]} && ${SpawnCount[xtarhater named radius ${MeleeDistance}]}) {
            |    /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
            |    /varset NamedCheck 1
            |}
        } else {
            | BurnAllNameds is ON, So Do this.
            /if (!${IgnoreTarget}) {
                |Is Target a Named?
                /call IsSpawnNamed ${MyTargetID}
                /varset IsNamed ${Macro.Return}
                | Use Target and MyTargetID to ID the Named.
                |/if (${BurnAllNamed}==1 && ${Spawn[${MyTargetID}].Named}) {
                /if (${BurnAllNamed}==1 && ${IsNamed}) {
                    /popup *** Mob:(${Target.CleanName}) is a NAMED!
                    /echo *** Mob:(${Target.CleanName}) is a NAMED!
                    /if (${BurnAllNamed}) /call Burn
                    /varset NamedCheck 1
                    |/if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
                } else {
                    | Setting BurnAllNamed=2 will only burn mobs on the list.
                    /declare i int local
                    /varset MobsToBurn ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
                    /if (${MobsToBurn.Find[null]}) /return
                    /for i 1 to 25
                        /if (${MobsToBurn.Arg[${i},,].Length} && !${MobsToBurn.Find[null]} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${MyTargetID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Target.CleanName}]}) {
                            /call Burn
                            /popup *** Mob:(${Target.CleanName}) is a NAMED!
                            /echo *** Mob:(${Target.CleanName}) is a NAMED!
                            |/if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
                            /varset NamedCheck 1
                            /break
                        }
                    /next i
                }
            } else {
                |Is Target a Named?
                /if (!${UseSpawnMaster}) {
                    /if (${SpawnCount[xtarhater named radius ${MeleeDistance}]}) {
                        /varset IsNamed True
                    /varset MyTargetID ${Spawn[xtarhater named radius ${MeleeDistance}].ID}
                    /varset MyTargetName ${Spawn[id ${MyTargetID}].CleanName}
                    }
                } else {
                    /if (${Alert[5].Size}) {
                        /if (${SpawnCount[xtarhater radius ${MeleeDistance} alert 5]}) {
                            /varset IsNamed True
                            /varset MyTargetID ${Spawn[xtarhater radius ${MeleeDistance} alert 5].ID}
                            /varset MyTargetName ${Spawn[id ${MyTargetID}].CleanName}
                        }
                    }
                }
                | BurnAllNameds is ON, but I am NON-Melee, So Using SpawnCount and Spawn info to determine if Named.
                |/if (${BurnAllNamed}==1 && ${SpawnCount[xtarhater named radius ${MeleeDistance}]}) {
                |    /popup *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                |    /echo *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                |    /varset MyTargetID ${Spawn[xtarhater named radius ${MeleeDistance}].ID}
                |    /varset MyTargetName ${Spawn[id ${MyTargetID}].CleanName}
                /if (${BurnAllNamed}==1 && ${IsNamed}) {
                    /popup *** Mob:(${MyTargetName}) is a NAMED!
                    /echo *** Mob:(${MyTargetName}) is a NAMED!
                    |/varset MyTargetID ${Spawn[xtarhater named radius ${MeleeDistance}].ID}
                    |/varset MyTargetName ${Spawn[id ${MyTargetID}].CleanName}
                    /call Burn
                    /varset NamedCheck 1
                    /varset MyTargetID 0
                    |/if (${GMailEvents.Find[named]}) /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
                } else {
                    | Setting BurnAllNamed=2 will only burn mobs on the list.
                    /declare i int local
                    /varset MobsToBurn ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
                    /if (${MobsToBurn.Find[null]}) /return
                    /for i 1 to 25
                        /if (${MobsToBurn.Arg[${i},,].Length} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${Spawn[xtarhater named radius ${MeleeDistance}].ID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}]}) {
                            /varset MyTargetID ${Spawn[xtarhater named radius ${MeleeDistance}].ID}
                            /varset MyTargetName ${Spawn[id ${MyTargetID}].CleanName}
                            /call Burn
                            /popup *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                            /echo *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                            |/if (${GMailEvents.Find[named]}) /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
                            /varset NamedCheck 1
                            /varset MyTargetID 0
                            /break
                        } else /if (${MobsToBurn.Arg[${i},,].Length}==0 || ${MobsToBurn.Arg[${i},,].Equal[null]}) {
                            /break
                        }
                    /next i
                }
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Scan ini file for errors in spelling or missing items
| ----------------------------------------------------------------------------
    Sub ScanIni(string p_Sections)
        /declare int_i             int    local 1
        /declare int_j             int    local 1
        /declare int_Count         int    local 0
        /declare int_CountEnrties  int    local 0
        /declare int_CountErrors   int    local 0
        /declare str_Sections      string local
        /declare str_Section       string local null
        /declare str_iniKey        string local
        /declare str_SummonedStuff string local null

        /if (!${p_Sections.Length} || ${p_Sections.Equal[null]} || ${p_Sections.Equal[all]}) {
            /varset str_Sections Buffs|DPS|Burn|Heals|AE|Cures|Pet|PetBuffs|GoM|Mez|Aggro|Pull
        } else {
            /varset str_Sections ${p_Sections}
        }

        /if (${str_Sections.Find[Buffs]}) {
            /for int_i 1 to ${BuffsSize}
                /varset str_iniKey ${Ini["${IniFileName}",Buffs,Buffs${int_i}]}
                /if (${str_iniKey.NotEqual[null]}) {
                    /if (${str_iniKey.Arg[2,|].Equal[summon]}) {
                        /if (${str_SummonedStuff.Equal[null]}) {
                            /varset str_SummonedStuff ${str_iniKey.Arg[3,|]}|
                        } else {
                            /varset str_SummonedStuff ${str_SummonedStuff}${str_iniKey.Arg[3,|]}|
                        }
                    }
                }
            /next int_i
        }

        /for int_j 1 to ${Math.Calc[${str_Sections.Count[|]}+1]}
            /varset str_Section ${str_Sections.Arg[${int_j},|]}
            /varset int_CountEnrties 0
            /varset int_CountErrors 0
            /varset int_Count 0
            /echo ---------------->> Scanning ${str_Section} <<----------------
            /if (${Select[${str_Section},Buffs,DPS,Burn,Heals,AE,Cures,PetBuffs,GoM,Aggro]}) {
                /if (${Defined[${str_Section}Size]}) {
                    /varset int_Count ${${str_Section}Size}
                }
            } else /if (${str_Section.Equal[Pet]}) {
                /varset int_Count 3
            } else /if (${str_Section.Equal[Mez]}) {
                /varset int_Count 2
            } else /if (${str_Section.Equal[Pull]}) {
                /varset int_Count 1
            }
            /if (${int_Count}) {
                /for int_i 1 to ${int_Count}
                    /if (${Select[${str_Section},DPS,Burn,Heals,AE,Cures,Aggro]}) {
                        /varset str_iniKey ${Ini["${IniFileName}",${str_Section},${str_Section}${int_i}]}
                    } else /if (${str_Section.Equal[Buffs]}) {
                        /if (${Select[${str_iniKey.Arg[2,|]},summon,remove,begfor]}) {
                            /varset str_iniKey null
                        } else /if (${str_SummonedStuff.NotEqual[null]} && ${str_SummonedStuff.Find[${str_iniKey.Arg[1,|]}|]}) {
                            /varset str_iniKey null
                        } else {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},${str_Section}${int_i}]}
                        }
                    } else /if (${str_Section.Equal[Pet]}) {
                        /if (${int_i}==1) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},PetSpell]}
                        } else /if (${int_i}==2) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},PetShrinkSpell]}
                        } else /if (${int_i}==3) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},PetBreakMezSpell]}
                        } else {
                            /break
                        }
                    } else /if (${str_Section.Equal[PetBuffs]}) {
                        /varset str_iniKey ${Ini["${IniFileName}",Pet,${str_Section}${int_i}]}
                    } else /if (${str_Section.Equal[GoM]}) {
                        /varset str_iniKey ${Ini["${IniFileName}",${str_Section},GomSpell${int_i}]}
                    } else /if (${str_Section.Equal[Mez]}) {
                        /if (${int_i}==1) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},MezSpell]}
                        } else /if (${int_i}==2) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},MezAESpell]}
                        } else {
                            /break
                        }
                    } else /if (${str_Section.Equal[Pull]}) {
                        /varset str_iniKey ${Ini["${IniFileName}",${str_Section},PullWith]}
                    }
                    /if (${str_iniKey.Left[1].Equal[;]} || ${str_iniKey.Equal[null]}) /continue
                    /while (1) {
                        DEBUGN ScanIni: ${str_Section}${int_i}=${str_iniKey}
                        | find out if there is a Rank and fix spell name.
                        /call SpellRankCheck "${str_iniKey}"
                        /varset str_iniKey ${Macro.Return}
                        DEBUGN ScanIni: ${str_iniKey} after return
                        /if (${str_iniKey.Find[|]}) /varset str_iniKey ${str_iniKey.Arg[1,|]}
                        /if (${str_iniKey.Find[Command:]}) /break
                        /if (${str_Section.Equal[GoM]} && ${str_iniKey.Find[Gift Of Mana]}) /break
                        /if (${str_Section.Equal[AE]} && ${str_iniKey.Find[Burn]}) /break
                        /if (${str_Section.Equal[Pull]} && ${Select[${str_iniKey},melee,pet]}) {
                            /varcalc int_CountEnrties ${int_CountEnrties}+1
                            /break
                        }
                        /if (!${Me.Book[${str_iniKey}]} && !${Me.CombatAbility[${str_iniKey}]} && !${Me.AltAbility[${str_iniKey}]} && !${FindItem[=${str_iniKey}].ID} && ${str_iniKey.NotEqual[banestrike]} && !${Me.Skill[${str_iniKey}]}) {
                            /echo ...ERROR: ${str_Section}${int_i}=${str_iniKey} unable to find as a AA, Combat Ability, Item, Skill, or Spell
                            /varcalc int_CountErrors ${int_CountErrors}+1
                        }
                        /varcalc int_CountEnrties ${int_CountEnrties}+1
                        /break
                    }
                /next int_i
            }
            /if (!${int_CountEnrties}) {
                /echo -- Nothing defined in this section
            } else /if (!${int_CountErrors}) {
                /echo -- No Spelling Errors or Missing Items Detected
            }
        /next int_j
    /return
| ----------------------------------------------------------------------------
| SUB: IniWrite - quick ini entry for spells,  aas, discs, items
| ----------------------------------------------------------------------------
    Sub Bind_IniWrite(IWSection, IWE1, IWE2, IWE3, IWE4, IWE5, IWE6, IWE7, IWE8)
    DEBUGN Bind_IniWrite: Enter
    /declare keyNum int local 0
    /declare IWPercent int local 100
    /declare IWSlot int local 1
    /declare IWType string local ${IWE1}
    /declare IWTypeSingle string local
    /declare IWArray int local ${${IWSection}.Size}
    /declare IWEmptySlot string local 0
    /declare IWEntry string local
    /declare i int local
    /declare j int local
    /declare k int local
    | Determine if single type
    /if (${Select[${IWType},aa,disc,item,spell,clear]}) {
        | Set Item
        /if (${IWType.Equal[item]}) {
            /if (!${Cursor.ID}) {
                /echo ..SET${IWSection}: You need to put the item on your cursor.
                /return
            }
            /varset IWTypeSingle ${Cursor.Name}
            /echo ${IWTypeSingle}
        }
        | Set Spell
        /if (${IWType.Equal[spell]}) {
            /if (!${Me.Gem[${IWE2}].Name.Length}) {
                /echo ..SET${IWSection}: You need to mem a spell
                /return
            }
            /varset IWTypeSingle ${Me.Gem[${IWE2}].Name}
        }
        | Set AA
        /if (${IWType.Equal[aa]}) {
            /if (!${Me.AltAbility[${IWE2}]}) {
                /echo ..SET${IWSection}: You don't have that AA
                /return
            }
            /varset IWTypeSingle ${Me.AltAbility[${IWE2}].Name}
        }
        | Set Disc/Combat Ability
        /if (${IWType.Equal[disc]}) {
            /if (!${Select[${IWE2},1,2,3,4,5,6,7,8]}) {
                /echo ..SET${IWSection}: Disc # must be a Combat Abilty Button 1-8
                /return
            }
            /if (!${Me.CombatAbility[${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}]}) {
                /echo ..SET${IWSection}: You don't have that Disc or Combat Ability button ${IWE2} is empty.
                /return
            }
            /varset IWTypeSingle ${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}
        }
        | Final Catchall for error control
        /if (!${IWTypeSingle.Length}) {
            /echo ..SET${IWSection}: ${IWType} parameter is blank. Please provide a ${IWType}
            /return
        }
        | Find empty slot & check if entry exists
        /echo ..SET${IWSection}: Looking of for spot to write ${IWTypeSingle}
        /for k 1 to ${IWArray}
            /varset IWEntry ${Ini[${IniFileName},${IWSection},${IWSection}${k}]}
            /if (${IWSection.Equal[DPS]}) /varset IWPercent 90
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            DEBUGN ${${IWSection}[${k}].Length}
            /if (${IWEntry.Find[${IWTypeSingle}]}) {
                /echo ..SET${IWSection}: Duplicate entry ${IWSection}${k}=${IWTypeSingle} skipping.
                /return
            }
            /if (${IWEntry.Equal[null]} && ${IWEmptySlot}==0) {
                /varset IWEmptySlot ${k}
            }
            /if (${k}==${IWArray} && !${IWEmptySlot}) /varset IWEmptySlot ${k}
        /next k
        /if (${IWEmptySlot}==${IWArray}) {
            /echo ..SET${IWSection}: No empty slots in ${IWSection} to write
            /return
        }
        /if (${Select[${IWSection},DPS,Heals]}) {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}|${IWPercent}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}|${IWPercent}
        } else {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}
        }
    } else {
        /echo ..SET${IWSection}: This command will write over current ${IWSection} settings
        /for i 1 to 8
            /varset keyNum ${i}
            /if (${Me.Gem[${IWE${i}}].Name.Length}) {
                /if (${IWSection.Equal[DPS]}) /varcalc IWPercent ${IWPercent}-5
                /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
                /if (${Select[${IWSection},DPS,Heals]}) {
                    /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}|${IWPercent}"
                    /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}|${IWPercent}
                }
                /if (${Select[${IWSection},Buffs]}) {
                    /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}"
                    /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}
                }
                /varcalc IWSlot ${IWSlot}+1
                /delay 10
            }
        /next i
    }
    /return
|-----------------------------------------------------------------------------
| SUB: Check Begged for buffs
| ----------------------------------------------------------------------------
    Sub CheckBegforBuffs
        /declare WNWAll    string local
        /declare WNWPart1  string local
        /declare WNWPart2  string local
        /declare WNWPart3  string local
        /declare WNWx      int    local 1
        /declare WNWSpellType string local
        /declare BuffToCast   string local
        DEBUGBUFF CheckBegForBuffs: Enter
        /if (${Me.Invis}) /return
        /if (!${KABegForList.Length}) /return
        /while (1) {
            /varset WNWAll ${KABegForList.Arg[${WNWx},|]}
            /if (!${WNWAll.Length} || ${WNWAll.Equal[null]}) {
                /if (!${KABegForList.Length} || ${KABegForList.Equal[null]}) /varset KABegActive 0
                /break
            }
            /varset WNWPart1 ${WNWAll.Arg[1,:]}
            /varset WNWPart2 ${WNWAll.Arg[2,:]}
            /varset WNWPart3 ${WNWAll.Arg[3,:]}
            DEBUGBUFF CheckBegForBuffs: ${WNWAll} - ${Me.Invis}
            /if (${Me.Invis}) /break
            /varset BuffToCast ${Buffs[${WNWPart3}].Arg[1,|]}
            /if (${Me.Book[${BuffToCast}]}) {
                /varset WNWSpellType ${Spell[${BuffToCast}].TargetType}
            } else /if (${Me.AltAbility[${BuffToCast}]}) {
                /varset WNWSpellType ${Me.AltAbility[${BuffToCast}].Spell.TargetType}
            } else {
                /varset WNWSpellType self
            }
            DEBUGBUFF CheckBegForBuffs: ${BuffToCast} - ${WNWSpellType}
            /if (${WNWSpellType.NotEqual[self]}) {
                /call CastWhat "${BuffToCast}" ${Spawn[PC ${WNWPart2}].ID} Buffs 0 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]} || ${Macro.Return.Equal[CAST_RECOVER]}) {
                    /call RemoveFromBegList "${WNWAll}" ${WNWx} "${WNWSpellType}"
                } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                    /break
                } else {
                    /varcalc WNWx ${WNWx}+1
                }
            } else {
                /call RemoveFromBegList "${WNWAll}" ${WNWx} "self"

            }
        }
        DEBUGBUFF CheckBegForBuffs: Leave
    /return
|-----------------------------------------------------------------------------
| SUB: Remove From Beg List
| ----------------------------------------------------------------------------
    Sub RemoveFromBegList(string RBLAll, int RBLIdx, string RBLType)
        /declare RBLPart1  string Local
        /declare RBLPart2  string Local
        /declare RBLPart3  string Local
        /declare RBLPart1t string Local
        /declare RBLPart2t string Local
        /declare RBLPart3t string Local
        /declare RBLy      int    local 0
        /if (!${RBLAll.Length} || ${RBLAll.Equal[null]}) /return
        /varset RBLPart1 ${RBLAll.Arg[1,:]}
        /varset RBLPart2 ${RBLAll.Arg[2,:]}
        /varset RBLPart3 ${RBLAll.Arg[3,:]}
        DEBUGBUFF RemoveFromBegList: Enter - ${RBLAll} - ${RBLIdx} - ${RBLType}
        /if (!${RBLIdx}) /varset RBLIdx 1
        /if (${KABegForList.Find[${RBLAll}|]}) {
            /varset KABegForList ${KABegForList.Replace[${RBLAll}|,]}
            | Check for AE Items and remove any entries with same item tag and buff number entry
            /if ((${Select[${RBLPart1},BEGFORAEITEMS]} && ${KABegForList.Find[${RBLPart1}:]}) || ${RBLType.Equal[self]}) {
                /varset RBLy ${RBLIdx}
                /while (1) {
                    /varset RBLAll ${KABegForList.Arg[${RBLy},|]}
                    /if (!${RBLAll.Length} || ${RBLAll.Equal[null]}) {
                        /break
                    } else {
                        | Part1: Alias Name - Part2: Character Name - Part3: Buff entry index number
                        /varset RBLPart1t ${RBLAll.Arg[1,:]}
                        /varset RBLPart2t ${RBLAll.Arg[2,:]}
                        /varset RBLPart3t ${RBLAll.Arg[3,:]}
                        /if (${RBLPart1t.Equal[${RBLPart1}]} && ${RBLPart3t.Equal[${RBLPart3}]}) {
                            /if (${KABegForList.Find[${RBLAll}|]}) {
                                /varset KABegForList ${KABegForList.Replace[${RBLAll}|,]}
                            } else /if (${KABegForList.Find[${RBLAll}]}) {
                                /varset KABegForList ${KABegForList.Replace[${RBLAll},]}
                            } else {
                                /varcalc RBLy ${RBLy}+1
                            }
                        } else {
                            /varcalc RBLy ${RBLy}+1
                        }
                    }
                }
            } else /if (${RBLType.Equal[single]}) {
                | Check for single targeted items and remove any duplicates from list. Only need to cast once.
                /if (${KABegForList.Find[${RBLAll}]}) {
                    /while (${KABegForList.Find[${RBLAll}|]}) {
                        /varset KABegForList ${KABegForList.Replace[${RBLAll}|,]}
                    }
                    /if (${KABegForList.Find[${RBLAll}]}) /varset KABegForList ${KABegForList.Replace[${RBLAll},]}
                }
            }
        } else /if (${KABegForList.Find[${RBLAll}]}) {
            /varset KABegForList ${KABegForList.Replace[${RBLAll},]}
        }
        DEBUGBUFF RemoveFromBegList: Leave
    /return
|-----------------------------------------------------------------------------
| SUB: Check Begged for Pet buffs
| ----------------------------------------------------------------------------
    Sub CheckBegforPetBuffs
        /declare WNWAll    string local
        /declare WNWPart1  string local
        /declare WNWPart1t string local
        /declare WNWx      int    local 1
        /declare WNWy      int    local
        /declare WhatBeenCast string local

        /declare PTPPetID int local
        /declare GMemID int local
        /declare GMemShortName string local
        /declare GMemPetName string local
        /declare i int local 0
        /if (!${PetToysOn}) /return
        /if (${Me.Invis}) /return
        DEBUGPET PetToysPlease: Enter GiveToys
        | If group command give all pets in group toys
        /echo CheckBegforPetBuffs: ${KABegForPetList} ${WNWx}
        /if (!${KABegForPetList.Length}) /return
        /while (1) {
            /varset WNWAll ${KABegForPetList.Arg[${WNWx},|]}
            /if (!${WNWAll.Length} || ${WNWAll.Equal[null]}) {
                /if (!${KABegForPetList.Length} || ${KABegForPetList.Equal[null]}) /varset KAPetBegActive 0
                /break
            }
            /varset WNWPart1 ${WNWAll}
            /if (${WNWPart1.Equal[group]}) {
                /echo I am giving pet toys to every Pet in Group except mine.
                | Start at 1 my pet doesn't need toys
                /for i 1 to 5
                    /varset GMemID ${Group.Member[${i}].ID}
                    /varset PTPPetID ${Group.Member[${i}].Pet.ID}
                    /varset GMemShortName ${Group.Member[${i}].Class.ShortName}
                    /varset GMemPetName ${Group.Member[${i}].Pet.Name}
                    DEBUGPET PetToysPlease: ${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}
                    /if (${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}) {
                        /if (${Me.Invis}) /break
                        /call pettoys ${GMemPetName}
                    }
                /next i
            } else {
                | Individual Pet.
                /if (${Me.Invis}) /break
                /echo Giving pet toys to (${WNWPart1}).
                /call pettoys ${WNWPart1}
            }

            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /if (${KABegForPetList.Find[${WNWAll}|]}) {
                    /varset KABegForPetList ${KABegForPetList.Replace[${WNWAll}|,]}
                    /if (${KABegForPetList.Find[${WNWPart1}]}) {
                        /varset WNWy ${WNWx}
                        /while (1) {
                            /varset WNWAll ${KABegForPetList.Arg[${WNWy},|]}
                            /if (!${WNWAll.Length} || ${WNWAll.Equal[null]}) {
                                /break
                            } else {
                                /varset WNWPart1t ${WNWAll}
                                /if (${WNWPart1t.Equal[${WNWPart1}]}) {
                                    /if (${KABegForPetList.Find[${WNWAll}|]}) {
                                        /varset KABegForPetList ${KABegForPetList.Replace[${WNWAll}|,]}
                                    } else /if (${KABegForPetList.Find[${WNWAll}]}) {
                                        /varset KABegForPetList ${KABegForPetList.Replace[${WNWAll},]}
                                    } else {
                                        /varcalc WNWy ${WNWy}+1
                                    }
                                } else {
                                    /varcalc WNWy ${WNWy}+1
                                }
                            }
                        }
                    }
                } else /if (${KABegForPetList.Find[${WNWAll}]}) {
                    /varset KABegForPetList ${KABegForPetList.Replace[${WNWAll},]}
                }
            } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                /break
            } else {
                /varcalc WNWx ${WNWx}+1
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Campfire back to camp
| ----------------------------------------------------------------------------
    Sub CampfireBack
        DEBUGN CampFireBack Enter ${CampZone} ${Zone.ID} ${IAmDead} ${CampfireClickTimer}
        /if (${Me.Hovering}) /call PauseWhileHovering CampFireBack
        /if (!${Me.ID} || !${Zone.ID}) /call PauseWhileZoning CampFireBack
        /if (${CampfireClickTimer}) /return
        /if (${CampZone}==${Zone.ID}) /return
        /declare SpamTimerCFB timer local 0
        /declare t_Wait timer local 100
        /while (${t_Wait}) {
            /delay 5
            /if (${Me.Fellowship.Campfire} && ${ClickBacktoCamp}==1) /break
        }
        | Am I Dead?
        /if (${Me.Buff[Revival Sickness].ID}) {
            | Does Campfire Exist?
            /if (!${Me.Fellowship.Campfire}) {
                /echo There is no campfire up.
            | Am I & the campfire in the same zone?
            } else /if (${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]}) {
                /echo I'm back in the same zone as my campfire.
                /varset IAmDead 0
            } else /if (${FindItemCount[Fellowship Registration Insignia]}) {
                /while (1) {
                    /if (${FindItem[Fellowship Registration Insignia].TimerReady} == 0) {
                        /echo Time to get back to work. Clicking Fellowship Insignia in 30 seconds.
                        | Delay for rest state to kick in
                        /while (${Select[${Me.CombatState},active,resting]}==0) {
                            /delay 5
                        }
                        /doevents
                        /squelch /nomodkey /itemnotify "Fellowship Registration Insignia" rightmouseup
                        /delay 50 !${Zone.ID}
                        /if (!${Zone.ID}) /call PauseWhileZoning CampFireBack
                        /break
                    } else {
                        /if (!${SpamTimerCFB}) /echo Waiting for Fellowship Registration Insignia to refresh.
                        /varset SpamTimerCFB 100
                    }
                    /delay 10
                    /if (!${Me.Fellowship.Campfire}) {
                        /echo There is no campfire up.
                        /break
                    }
                }
                /while (1) {
                    /varset EventFlag 0
                    /doevents
                    /if (!${EventFlag}) /break
                }
            } else {
                /echo You Don't have a Fellowship Registration Insignia. You may want to go get one.
            }
        }
        /varset CampfireClickTimer 1m
        DEBUGN CanpFireBack Leave
    /return
|-----------------------------------------------------------------------------
| SUB: Debug
| ----------------------------------------------------------------------------
    Sub Bind_Debug(string p_cmd1, string p_cmd2, string p_cmd3)
        /declare str_onoff string local
        /declare str_command string local
        /declare str_uselog string local
        /if (${EverQuest.CurrentUI.NotEqual[Default]}) {
            /echo You are using a Custom UI. Please switch to Default UI before Posting.
        }
        | Check param 3
        /if (${Select[${p_cmd3},log,logc]}) {
            /varset str_uselog ${Select[${p_cmd3},log,logc]}
        } else {
            /varset str_uselog 0
        }
        | Check Param 2
        /if (${Select[${p_cmd2},0,1,on,off]}) {
            /varset str_command ${p_cmd1}
            /varset str_onoff ${p_cmd2}
            /if (${p_cmd2.Equal[on]}) {
                /varset str_onoff 1
            } else /if (${p_cmd2.Equal[off]}) {
                /varset str_onoff 0
            }
        } else /if (${Select[${p_cmd2},log,logc]}) {
            /varset str_uselog ${Select[${p_cmd2},log,logc]}
            /varset str_onoff
        } else {
            /varset str_onoff
        }
        | Check Param 1
        /if (${Select[${p_cmd1},0,1,on,off]}) {
            /varset str_command Debug
            /varset str_onoff ${p_cmd1}
            /if (${p_cmd1.Equal[on]}) {
                /varset str_onoff 1
            } else {
                /varset str_onoff 0
            }
            /if (!${str_onoff} && ${DebugAllOn}) /varset str_command all
        } else /if (${p_cmd1.Equal[all]}) {
            /varset str_command ${p_cmd1}
        } else /if (${Select[${p_cmd1},Buffs,Combat,Cast,ChainP,Heals,Mez,Move,Pull,RK]}) {
            /varset p_cmd1 ${p_cmd1.Left[1].Upper}${p_cmd1.Right[-1].Lower}
            /if (${Select[${p_cmd1.Right[1]},p,k]}) /varset p_cmd1 ${p_cmd1.Left[-1]}${p_cmd1.Right[1].Upper}
            /varset str_command Debug${p_cmd1}
        } else /if (!${p_cmd1.Length}) {
            /if (${DebugAllOn}) {
                /varset str_command all
            } else {
                /varset str_command Debug
            }
        } else {
            /varset str_command Help
            /varset str_onoff
        }

        /if (${str_command.Equal[help]}) {
            /echo --------------------------------------------------------------------------------------------
            /echo \ayDebug help:
            /echo \ay    /debug command action1 action2
            /echo \ay        command: \aohelp/all/Buffs/Combat/Cast/Charm/ChainP/Heals/Mez/Move/Pull/RK/on/off/0/1
            /echo \ay        action1: \aoon/off/0/1 or blank
            /echo \ay        action2: \aolog or blank
            /echo \ag    Examples:
            /echo \at        /debug all on -----> Turns on debug all.
            /echo \at        /debug all off ----> Turns off debug all.
            /echo \at        /debug all --------> Taggles on/off debug all.
            /echo \at        /debug all log ----> Toggles on/off debug all and starts/stops logging.
            /echo \at        /debug on ---------> Turns on debug only.
            /echo \at        /debug off --------> Turns off debug only.
            /echo \at        /debug ------------> Toggles on/off debug only.
            /echo \at        /debug combat on --> Turns on combat debug only.
            /echo \at        /debug combat off -> Turns off combat debug only.
            /echo \at        /debug combat -----> Taggles on/off combat debug only
            /echo \at
            /echo \at        /debug log - Is an invalid format and shouldn't be used.
            /echo
            /echo \ay        log - can be used as either action1 or action2, but never as command.
            /echo \ay              you do NOT have to sepcify the log action to turn logging off.
            /echo \ay              any action that turns off any debug command will stop logging.
            /echo
            /echo \ay    Note: MQ2Log plugin will be loaded using the noauto option if the plugin is not loaded.
            /echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            /return
        } else /if (${str_command.Equal[debug]}) {
            /if (!${str_onoff.Length}) {
                /if (${Debug}) {
                    /varset str_onoff 0
                } else {
                    /varset str_onoff 1
                }
            }
            /varset Debug ${str_onoff}
            /if (${Debug}) {
                /echo \atDEBUG On
            } else {
                /echo \atDEBUG Off
            }
        } else /if (${str_command.Equal[all]}) {
            /if (!${str_onoff.Length}) {
                /if (${DebugAllOn}) {
                    /varset str_onoff 0
                } else {
                    /varset str_onoff 1
                }
            }
            /varset DebugAllOn ${str_onoff}
            /if (${DebugAllOn}) {
                /echo \atDebugAll On
            } else {
                /echo \atDebugAll Off
            }
            /varset Debug ${DebugAllOn}
            /varset DebugBuffs ${DebugAllOn}
            /varset DebugCast ${DebugAllOn}
            /varset DebugCombat ${DebugAllOn}
            /varset DebugHeals ${DebugAllOn}
            /varset DebugMez ${DebugAllOn}
            /varset DebugMove ${DebugAllOn}
            /varset DebugPet  ${DebugAllOn}
            /varset DebugPull ${DebugAllOn}
        } else /if (${Defined[${str_command}]}) {
            /if (!${str_onoff.Length}) {
                | Double brackets it is on purpose.
                /if (${${str_command}}) {
                    /varset str_onoff 0
                } else {
                    /varset str_onoff 1
                }
            }
            /varset ${str_command} ${str_onoff}
            /if (${${str_command}}) {
                /echo \at${str_command} On
            } else {
                /echo \at${str_command} Off
            }
        } else {
            /echo Invalid Command. Try /debug help.
            /return
        }
        /if (${str_uselog}) {
            /if (!${Bool[${Plugin[mq2log]}]}) {
                /plugin MQ2Log noauto
                /delay 20 ${Bool[${Plugin[mq2log]}]}==True
            }
            /if (!${DebugLogging}) {
                /if (${str_onoff.Equal[1]}) {
                    /if (${str_uselog.Equal[2]}) /mqlogcustom ${EverQuest.Server}_${Me.CleanName} clear
                    /mlog on
                    /varset DebugLogging 1
                    /echo Using UI: ${EverQuest.CurrentUI}
                    /echo KissAssist Info: ${MacroName} ${MacroVer}-${KissRevision}
                    /echo MQ Build: ${MacroQuest.InternalName} - ${MacroQuest.Build} - ${MacroQuest.BuildDate}
                    /plugin list
                    /call DebugInfo
                }
            } else {
                /if (${str_onoff.Equal[0]}) {
                    /echo KissAssist Debug Off Marker!
                }
            }
        } else {
            /if (${DebugLogging}) {
                /if (${str_onoff.Equal[0]}) {
                    /echo KissAssist Debug Off Marker!
                }
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: DebugInfo Used to dump Macro Variables in debug log.
| ----------------------------------------------------------------------------
    Sub DebugInfo
        /declare di_x int local 0
        /declare di_y int local 0
        /if (${UseMQ2Melee} && ${Bool[${Plugin[mq2melee]}]}) {
            /melee
            /echo Melee stickcmd: ${Ini[${EverQuest.Server}_${Me.CleanName}.ini,mq2melee,stickcmd]}
        }
        /echo ============================================================
        /echo 1 - ${Role} ${ReturnToCamp} ${ChaseAssist} ${CampRadius} ${MeleeDistance} ${CampZone} ${Zone.ID}
        /echo 2 - ${Math.Distance[${CampYLoc},${CampXLoc}]} ${Spawn[=${MainAssist}].Distance3D}
        /echo 3 - ${MeleeOn} ${DPSOn} ${UseMQ2Melee} "${StickHow}" ${XTSlot}
        /echo 4 - ${IAmMA} ${Spawn[=${MainAssist}].ID} ${Group} ${Group.MainAssist.ID}
        /echo 5 - ${BuffsOn} ${AEOn} ${AggroOn} ${HealsOn} ${CuresOn} ${AFKToolsOn} ${ConOn} ${PullLocsOn} ${CharmOn}
        /echo 6 - ${MiscGem} ${MiscGemLW} ${MiscGemRemem}
        /echo 7 - ${Me.Class} ${Me.Level} ${PullMoveUse} ${If[${PullMoveUse.Equal[nav]},${Navigation.MeshLoaded},0]}
        /if (${Role.Find[Puller]} || ${Role.Find[Hunter]}) {
            /echo 8 - ${PullWith} ${MaxRadius} ${MaxZRange} ${PullRadiusToUse} ${ChainPull} ${ChainPullHP} ${PullPause} ${PullLevel} ${PullArcWidth} ${PullOnReturn}
        }
        /if (${HealsOn} && ${XTarHeal}) {
            /echo 9 - ${XTarHealList} ${XTSlot} ${XTSlot2}
            /for di_x 1 to ${XSlotTotal}
                /if (${XTarHealList.Arg[${di_x},|].Length}) {
                    /varset di_y ${XTarHealList.Arg[${di_x},|]}
                    /echo --> ${di_x} - ${di_y} - ${Me.XTarget[${di_y}].TargetType}
                }
            /next di_x
        }
        /echo ============================================================
        | Put in the Type/TLO Checks you want below here.
       | /if (${IAmABard}) {
       |     /if (${TwistOn}) {
       |         /call DebugDumpTLO twist
       |     } else {
       |         /echo I am a Bard, but I am not using twist.
       |     }
       | }
    /return
|-----------------------------------------------------------------------------
| SUB: DebugDumpTLO Pass the type name. Used to dump TLO/Type Members Data.
| ----------------------------------------------------------------------------
    Sub DebugDumpTLO(typeName)
        /declare dt_i int local 1
        /declare dt_TLOName string local
        /if (!${typeName.Length} || !${Type[${typeName}].Name.Length}) {
            /echo Type - ${typeName} Not Available.
            /return
        }
        /varset dt_TLOName ${typeName.Left[1].Upper}${typeName.Right[-1]}
        /echo Listing for Type: ${typeName} - TLO: ${dt_TLOName}
        /echo =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
        /while (1) {
            /if (!${Type[${typeName}].Member[${dt_i}].Length}) /break
			/echo ${Type[${typeName}].Member[${dt_i}]} - ${${dt_TLOName}.${Type[${typeName}].Member[${dt_i}]}}
            /varcalc dt_i ${dt_i}+1
        }
        /echo =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    /return
|-----------------------------------------------------------------------------
| SUB: Back Off and stop melee
| ----------------------------------------------------------------------------
    Sub Bind_BackOff(string OnOffFlag, int waitFlag)
        /declare t_Wait      timer local 0
        /declare i_Target    int   local ${Int[${Target.ID}]}
        /declare i_Flag1     int   local 0
        /if (${Select[${OnOffFlag},on,off,1,0]}>0) {
            /if (${Select[${OnOffFlag},on,1]}>0) {
                /varset DPSPaused 0
            } else {
                /varset DPSPaused 2
            }
        }
        /if (${DPSPaused}) {
            /echo Resetting. No Longer Backing off. ${waitFlag} ${IAmMA}
            /if (${waitFlag} && ${IAmMA}) {
                /if (${Me.Casting.ID}) {
                    /stopcast
                    /varset CastResult CAST_CANCELLED
                }
                /echo Pausing for new target. Switch to new target now.
                /varset t_Wait 30
                /beep
                /while (${t_Wait} && !${i_Flag1}) {
                    /if (${Target.ID} && ${Target.ID}!=${i_Target}) /varset i_Flag1 1
                    /delay 5
                }
                /if (${i_Flag1}) {
                    /varset i_Flag1 ${TargetSwitchingOn}
                    /varset TargetSwitchingOn 1
                    /call CombatTargetCheck 2
                    /varset TargetSwitchingOn ${i_Flag1}
                    /echo Target Switched from Backoff command.
                } else {
                    /echo Target NOT Switched. You can always try again.
                }
            }
            /if (${DPSPaused}==2 && ${UseMQ2Melee}) /squelch /melee on
            /varset DPSPaused 0
        } else {
            /varset DPSPaused 1
            /varset CombatStart 0
            /if (${UseMQ2Melee}) /squelch /melee off
            /squelch /attack off
            /if (${Stick.Active}) /stick off
            /call CombatReset 0 backoff
            /varset DPSPaused 2
            /echo Backing off - All Combat has been reset.
        }
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15 && !${waitFlag}) {
            /call DoWeMove 0 bind_backoff
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Add stuff to alert list
| -------------------------------------------------------------------------------------
    Sub AlertAddToList(int whatlist, MvarList, IDvarList)
        DEBUGN AlertAddToList List:${whatlist} Mlist: ${MvarList}
        /declare k int local
        | Clear ignore mobs alert from list before assigning from ini list
        /squelch /alert clear ${whatlist}
        /if (${MvarList.Length} && !${MvarList.Find[null]}) {
            /for k 1 to 25
                /if (${MvarList.Arg[${k},,].Length} && !${MvarList.Find[null]} && ${Debug}) /echo \atDEBUG ADD ${MvarList.Arg[${k},,]} to ${MvarList}
                /if (${MvarList.Arg[${k},,].Length}) {
                    /if (${MvarList.Arg[${k},,].Find[*]}) {
                        /squelch /alert add ${whatlist} "${MvarList.Arg[${k},,].Replace[*,]}"
                    } else {
                        /squelch /alert add ${whatlist} "=${MvarList.Arg[${k},,]}"
                    }
                    DEBUGN AlertAddToList Add ${MvarList.Arg[${k},,]} to Alert List ${whatlist}
                }
            /next k
        }
        | Add by mob ID for mobs that get invalidated when pulling.
        /if (${IDvarList.Length} && ${IDvarList.NotEqual[null]}) {
            /varset k 1
            /while (${IDvarList.Arg[${k},|].Length} && ${IDvarList.Arg[${k},|].NotEqual[null]} && ${Int[${IDvarList.Arg[${k},|]}]}>0) {
                DEBUGN ADD ${IDvarList.Arg[${k},|]} to ${MvarList}
                /if (${Int[${IDvarList.Arg[${k},|]}]}>0) /squelch /alert add ${whatlist} id ${IDvarList.Arg[${k},|]}
                DEBUGN AlertAddToList Add ${IDvarList.Arg[${k},|]} to Alert List ${whatlist}
                /varcalc k ${k}+1
            }
        }
        DEBUGN AlertAddToList Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: SpellRankCheck
| ------------------------------------ -------------------------------------------------
    Sub SpellRankCheck(Rk_Check_What)
        /declare rkCheck                string      local null
        /declare rkCheck1               string      local
        /declare rkdCheck               string      local
        /declare rkTemp                 string      ${Rk_Check_What.Arg[1,|]}
        /declare rkdTemp                string      ${Rk_Check_What.Arg[3,|]}
        /declare rkd_i                  int         local 0
        DEBUGN SpellRankChecks: Enter - ${rkTemp} - ${rkdTemp}
        /if (${Rk_Check_What.Left[1].Equal[0]} || ${Int[${Rk_Check_What.Left[1]}]}>0) /return ${Rk_Check_What}
        | Check for Rk. in spell name and Remove it.
        /if (${rkTemp.Find[ Rk.]}) {
            /varset rkTemp ${rkTemp.Left[${Math.Calc[${rkTemp.Find[ Rk.]}-1]}]}
        }
        /if (${Int[${Me.Book[${rkTemp}]}]}==0 && ${Int[${Me.Book[${Spell[${rkTemp}].RankName}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}==0 && ${Int[${Me.CombatAbility[${Spell[${rkTemp}].RankName}]}]}==0) {
            /return ${Rk_Check_What}
        }
        DEBUGN SpellRankChecks: 1 rkCheck: "${rkCheck}" rkTemp: "${rkTemp}" rkdCheck: "${rkdCheck}" rkdTemp: "${rkdTemp}"
        | If this is NOT an Alt Ability then it must be a spell.
        /if (${Int[${Me.AltAbility[${rkTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
           /if (${DebugRK}) /echo 1a. well we think ${rkTemp} is an AA
           /varset rkCheck ${rkTemp}
        } else {
           /if (${DebugRK}) /echo 1c. well ${rkTemp} is not an AA or CombatAbility
           /varset rkCheck ${Spell[${rkTemp}].RankName}
        }
        | check for null
        DEBUGN SpellRankChecks: 2 rkCheck: ${rkCheck} rkTemp: ${rkTemp} Rk_Check_What: ${Rk_Check_What}
        | must NOT be null so lets fix Rk_Check_What.
        /if (${rkCheck.NotEqual[${rkTemp}]}) {
            /if (${Rk_Check_What.Find[|]}>0) {
                /varset rkCheck1 ${rkCheck}${Rk_Check_What.Right[-${Math.Calc[${Rk_Check_What.Find[|]}-1]}]}
                /varset rkCheck ${rkCheck1}
            }
        } else {
            /varset rkCheck ${Rk_Check_What}
        }
        /if (${Rk_Check_What.Arg[2,|].Equal[dual]}) {
            /if (${rkdTemp.Find[ Rk.]}) {
                /varset rkdTemp ${rkdTemp.Left[${Math.Calc[${rkdTemp.Find[ Rk.]}-1]}]}
            }
            /if (${Int[${Me.AltAbility[${rkdTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
                /varset rkdCheck ${Spell[${rkdTemp}].RankName}
            } else {
                /if (${Me.Subscription.NotEqual[gold]}) {
                    /varset rkdCheck ${rkdTemp}
                } else {
                    /varset rkdCheck ${Spell[${rkdTemp}].RankName}
                }
            }
            DEBUGN SpellRankChecks: 3 rkdCheck: ${rkdCheck} rkdTemp: ${rkdTemp} Rk_Check_What: ${Rk_Check_What}
            /varset rkCheck ${rkCheck.Arg[1,|]}|dual|${rkdCheck}
            /for rkd_i 4 to 10
                /if (!${Bool[${Rk_Check_What.Arg[${rkd_i},|]}]}) /break
                /varset rkCheck ${rkCheck}|${Rk_Check_What.Arg[${rkd_i},|]}
            /next rkd_i
        }
        DEBUGN SpellRankChecks: 4 Rk_Check_What: ${Rk_Check_What} rkCheck: ${rkCheck} rkTemp: ${rkTemp}
        DEBUGN SpellRankChecks: leave
    /return ${rkCheck}
| -------------------------------------------------------------------------------------
| SUB: Check cursor
| -------------------------------------------------------------------------------------
    Sub CheckCursor(string SentFrom, int ForceDrop)
        DEBUGN CheckCursor: enter ${SentFrom} ${ForceDrop}
        /if (${ForceDrop}) {
            /while (${Cursor.ID}) {
                /if (${Debug} && ${Cursor.ID}) /echo Dropping ${Cursor} ${SentFrom}
                /if (!${Me.FreeInventory}) {
                    /echo HEY YOUR INVENTORY IS FULL!
                    /break
                }
                /autoinventory
                /delay 10
            }
            /varset CursorID 0
        } else {
            /if ((!${CursorIDTimer} && !${CursorID}) || (${CursorID} && ${Cursor.ID}!=${CursorID})) {
                /varset CursorIDTimer 20s
                /varset CursorID ${Cursor.ID}
                /if (${Me.FreeInventory}) {
                    /echo ${Cursor.Name} is stuck on my cursor. Dropping it into inventory in 15s.
                } else {
                    /echo HEY YOUR INVENTORY IS FULL!
                }
            } else /if (!${CursorIDTimer}) {
                /while (${Cursor.ID}) {
                    /if (${Debug} && ${Cursor.ID}) /echo Dropping ${Cursor} ${SentFrom}
                    /autoinventory
                    /delay 10
                }
                /varset CursorID 0
            }
        }
        DEBUGN CheckCursor: leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind ZoneInfo
| -------------------------------------------------------------------------------------
    Sub Bind_ZoneInfo
        /declare LineInfo string local
        /declare zi_x int local
        /echo -------------------------------------------------------------------------
        /echo  ${ZoneName} - (${Zone.ShortName})
        /echo -------------------------------------------------------------------------
        /echo MezImmune: ${Ini[${InfoFileName},${ZoneName},MezImmune]}
		/echo CharmImmune: ${Ini[${InfoFileName},${ZoneName},CharmImmune]}
        /echo MobsToPull: ${Ini[${InfoFileName},${ZoneName},MobsTopull]}
        /echo MobsToIgnore: ${Ini[${InfoFileName},${ZoneName},MobsToIgnore]}
        /echo MobsToBurn: ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
        /if (${PullLocsOn}) {
            /for zi_x 1 to ${PullLocs.Size}
                /if (${PullLocs[${zi_x}].Length} && ${PullLocs[${zi_x}].NotEqual[null]}) /echo PullLocs${zi_x}: ${PullLocs[${zi_x}]}
            /next zi_x
        }
        /echo -------------------------------------------------------------------------
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind WriteMySpell
| -------------------------------------------------------------------------------------
    Sub Bind_WriteMySpells(int Quite)
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /return
        /varcalc GemSlots ${Int[${Me.AltAbility[Mnemonic Retention].Rank}]}+8
        /declare i int local
        /for i 1 to ${GemSlots}
            /if (!${Quite}) /echo Gem ${i}: ${Me.Gem[${i}].Name}
            /ini "${IniFileName}" "Spells" "Gem${i}" "${Me.Gem[${i}].Name}"
            /ini "${EverQuest.Server}_${Me.CleanName}.ini" "Gems-Ref" "Gem${i}" "${Me.Gem[${i}].Name}"
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind MemMySpells
| -------------------------------------------------------------------------------------
    Sub Bind_MemMySpells(Message, p_SpellSet)
        /declare temppCharName          string      local
        /declare pCharName              string      local ${Message}
        /declare tempIniFileName        string      local
        /declare pKV                    string      local
        /declare i                      int         local
        /declare ii                     int         local
        /declare SpellToMem             string      local
        /declare tempSpellName          string      local
        /declare tempSpellSection       string      local
        /declare int_WasIStanding       bool        local ${Me.Standing}

        DEBUGN MemMySpells: Enter
        /varcalc GemSlots ${Int[${Me.AltAbility[Mnemonic Retention].Rank}]}+8
        /if (!${pCharName.Length} || ${pCharName.Equal[null]}) {
           /varset temppCharName ${Me.CleanName}
        } else {
           /varset temppCharName ${pCharName}
        }
        /if (!${PIniSet}) {
            /if (${Ini[${MacroName}_${EverQuest.Server}_${temppCharName}.ini,General,KissAssistVer].Length}) {
                /varset tempIniFileName ${MacroName}_${EverQuest.Server}_${temppCharName}.ini
                /echo Server Name ini file detected using ${tempIniFileName}
            } else {
                /varset tempIniFileName ${MacroName}_${temppCharName}.ini
            }
        } else {
            /varset tempIniFileName ${IniFileName}
        }
        /varset pKV ${Ini[${tempIniFileName},General,KissAssistVer]}
        /if (${Int[${pKV}]}==0) {
           /echo Invalid INI file: ${tempIniFileName} for memorizing spells. Returning.
           /return
        }
        /if (${Bool[${p_SpellSet}]}) {
            /varset tempSpellSection Spells${p_SpellSet}
            /varset pKV ${Ini[${tempIniFileName},"${tempSpellSection}",Gem1]}
            /if (${Int[${pKV.Length}]}==0) {
               /echo No Spells Section found for: ${tempSpellSection}. Defaulting to Spells Section.
               /varset tempSpellSection Spells
               |/return
            }
        } else {
            /varset tempSpellSection Spells
        }
        /varset pKV ${Ini[${tempIniFileName},"${tempSpellSection}",Gem1]}
        /if (${Int[${pKV.Length}]}==0) {
           /echo No Spells found in INI file: ${tempIniFileName}. Use /writespells and try again. Returning.
           /return
        }
        /if (${IAmABard}) {
            /call CastBardCheck 0
        }
        /for i 1 to ${GemSlots}
            /varset SpellToMem ${Ini[${tempIniFileName},"${tempSpellSection}",Gem${i}]}
            /if (${SpellToMem.Length} && ${SpellToMem.NotEqual[null]}) {
                /if (${SpellToMem.Find[ Rk.]}) {
                   /varset tempSpellName ${SpellToMem.Left[${Math.Calc[${SpellToMem.Find[ Rk.]}-1]}]}
                } else {
                   /varset tempSpellName ${SpellToMem}
                }
                /varset SpellToMem ${Spell[${tempSpellName}].RankName}
                /if (${Me.Book[${SpellToMem}]}) {
                    /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && ${Int[${Me.Gem[${SpellToMem}]}]}!=${i}) {
                        /varcalc ii ${Int[${Me.Gem[${SpellToMem}]}]}-1
                        /notify CastSpellWnd CSPW_Spell${ii} rightmouseup
                        /delay 20 ${Int[${Me.Gem[${SpellToMem}]}]}==0
                    }
                    /if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${SpellToMem}]}) {
                        /varset DontMoveMe 1
                        /while (${Me.Moving}) {
                            /delay 5
                        }
                        /if (!${Me.Mount.ID} && ${Me.Standing}) /sit
                        /echo Meming ${SpellToMem} in slot ${i}
                        /if (${Stick.Active}) {
                            /stick pause
                            /MemSpell ${i} "${SpellToMem}"
                            /delay 150 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]}
                            /stick unpause
                        } else {
                            /MemSpell ${i} "${SpellToMem}"
                            /delay 150 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]}
                        }
                        /varset DontMoveMe 0
                    }
                } else {
                    /echo Could Not find the spell ${tempSpellName} in your spell book.
                }
            }
        /next i
        /varset ReMemMiscSpell ${Me.Gem[${MiscGem}].Name}
        /varset ReMemMiscSpellLW ${Me.Gem[${MiscGemLW}].Name}
       | /if (${IAmABard} && ${WasTwisting}) {
       |     /if (${Me.Sitting}) /stand
       |     /delay 5
       |     /squelch /twist
       | } else /if (${int_WasIStanding} && ${Me.Sitting} && !${Me.Mount.ID}) {
       |     /stand
       | }
    DEBUGN MemMySpells: leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind Parse
| -------------------------------------------------------------------------------------
    Sub Bind_Parse(TimeToParse)
        DEBUGN Bind_Parse Enter
        /if (!${Defined[ParseDPS]}) /declare ParseDPS     timer       outer       0
        /echo Parsing combat for ${TimeToParse} second
        /varset BurnAllNamed 0
        /tar npc dummy
        /delay 10 ${Target.ID}
        /varset MyTargetID ${Target.ID}
        /varset MyTargetName ${Target.CleanName}
        /varset ParseDPS ${TimeToParse}s
        /call Combat
        /call CombatReset 0 parse
        /target clear
        /attack off
        /stick off
        DEBUGN Bind_Parse Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind_TrackMeDown
| -------------------------------------------------------------------------------------
    Sub Bind_TrackMeDown(int StickOff, int UseNavOnly, int IgnoreDistance)
        /if (${DontMoveMe}) {
            /echo WAIT UP! I was told not to move. Leaving TrackMeDown.
            /return
        }
        DEBUGN Bind_TrackMeDown Enter
        /declare tmdChaseAssist int local ${ChaseAssist}
        /declare tmdReturnToCamp int local ${ReturnToCamp}
        /declare tmdChaseDistance int local ${ChaseDistance}
        /declare tmdCampRadiusExceed int local ${CampRadiusExceed}
        | Check if I am Dead.
        /if (${Me.Hovering} || ${IAmDead}) /return
        | Check if Who to chase character is in the zone.
        /if (${Spawn[pc ${WhoToChase}].ID}==0) /return
        /varset BindActive 1
        | Check if we are to use Navigation and it is loaded with a valid Mesh and Path.
        /if (${UseNavOnly} ) {
            /if (${PullMoveUse.NotEqual[nav]} || !${Navigation.MeshLoaded}) {
                /echo I can't Track Down ${WhoToChase}. Navigation not loaded or bad Mesh.
                /return
            } else {
                /if (${Navigation.PathExists[id ${Spawn[pc ${WhoToChase}].ID}]}==FALSE) {
                    /echo I can't Track Down ${WhoToChase}. No Valid Path too destination.
                    /return
                }
            }
        }
        /varset ChaseAssist 2
        /varset ReturnToCamp 0
        /varset ChaseDistance 20
        /if (${IgnoreDistance}) /varset CampRadiusExceed 100000
        /if (${Me.Casting.ID}) /stopcast
        | Go chase them down.
        /call DoWeChase TrackMeDown
        | Set things back
        /if (${tmdReturnToCamp}) {
            /varset CampXLoc ${Me.X}
            /varset CampYLoc ${Me.Y}
            /varset CampZLoc ${Me.FloorZ}
            /varset LookForward ${Me.Heading.DegreesCCW}
            /echo >> New camp set ${Me.Y}, ${Me.X}
        }
        /if (${StickOff}) {
            /if (${Stick.Active}) /squelch /stick off
        }
        /varset ChaseAssist ${tmdChaseAssist}
        /varset ReturnToCamp ${tmdReturnToCamp}
        /varset ChaseDistance ${tmdChaseDistance}
        /varset CampRadiusExceed ${tmdCampRadiusExceed}
        /varset BindActive 0
        DEBUGN Bind_TrackMeDown Leave
    /return
| -------------------------------------------------------------------------------------
| Task Code
| -------------------------------------------------------------------------------------
| SUB: Unmount
| -------------------------------------------------------------------------------------
    Sub Event_KTDismount
        /varset EventFlag 1
        |/declare factor1 int local 10
        /if (${MountOn}) /varset MountOn 0
        /if (${Me.Mount.ID}) {
            |/if (${Group}) {
            |    /varcalc factor1
            |}
            /dismount
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Target NPC
| ----------------------------------------------------------------------------
    Sub Event_KTTarget(Line, NPCName)
        /varset EventFlag 1
        /echo Targeting ${NPCName}
        /if (${NPCName.Equal[null]}) {
            /echo NPC Name is Null. Check your variables.
            /return FALSE
        }
        /if (!${Spawn[npc ${NPCName}].ID}) {
            /echo ${NPCName}? You must be in the wrong palce, no one here by that name
            /return FALSE
        }
        /target id ${Spawn[${NPCName}].ID}
        /delay 3s ${Target.ID}==${Spawn[${NPCName}].ID}
        /if (${Target.Distance}>15 && ${Target.Distance}<50) {
            /moveto id  ${Spawn[${NPCName}].ID}
            /delay 250 ${MoveTo.Stopped}
        }
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /call ZAxisCheck ${ZDist} 4.1
        /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
        /delay 10
        /return TRUE
|-----------------------------------------------------------------------------
| SUB: KTHail
| ----------------------------------------------------------------------------
    Sub Event_KTHail(Line, KTMobID)
        |/varset EventFlag 1
        /tar id ${Spawn[npc ${KTMobID}].ID}
        /delay ${Math.Rand[30]}
        /keypress h
        /doevents flush KTaskSay
    /return
|-----------------------------------------------------------------------------
| SUB: KTSay
| ----------------------------------------------------------------------------
    Sub Event_KTSay(Line, KTSayWhat, KTMobID)
        |/varset EventFlag 1
        /tar id ${KTMobID}
        /delay ${Math.Rand[20]}
        /say ${KTSayWhat}
        /delay 10
        /doevents flush KTaskSay
    /return
|-----------------------------------------------------------------------------
| SUB: TaskDoorTarget
| ----------------------------------------------------------------------------
    Sub Event_KTDoorClick(Line, int KTDoorID)
        |/varset EventFlag 1
        /declare KTCDTimer timer local 10s
        /if (!${Defined[KTDoorID]}) {
            /doortarget
            /delay 3
            /declare KTDoorID ${DoorTarget.ID}
        }
        /echo DoorID: ${KTDoorID}
        /delay 10
        /keypress FIRST_PERSON_CAMERA hold
        /delay 2
        /keypress FIRST_PERSON_CAMERA
        /delay 10
        /if (${Target.ID}) /squelch /tar clear
        /delay 3
        /while (${KTCDTimer}) {
            /echo target door id ${KTDoorID}
            /if (${KTDoorID}) {
                /doortarget id ${KTDoorID}
            } else {
                /doortarget
            }
            /delay 3
            /echo ${DoorTarget.Name}
            /if (${Switch.ID}) /break
        }
        /face door
        /delay 3
        /if (!${KTCDTimer}) /varset KTCDTimer 50
        /while (${KTCDTimer} && ${DoorTarget.ID}) {
            /if (${DoorTarget.Distance}<=70)  {
                /echo Moving to Door
                /if (${DoorTarget.Distance}>15) {
                    /keypress forward hold
                    /delay 3
                    /keypress forward
                } else /if (${DoorTarget.Distance}<10) {
                    /keypress back hold
                    /delay 1
                    /keypress back
                }
            } else {
               /echo ${DoorTarget.Name} is too far away(${DoorTarget.Distance}). Get closer.
               /break
            }
            /if (!${Switch.Open}) {
                /face door
                /delay 3
                /echo clicking door
                /click left door
                /delay 1s
            } else {
                /break
            }
        }
        /if (${Window[largedialogwindow].Open}) {
            /notify largedialogwindow LDW_YesButton leftmouseup
        }
        /doevents flush KTDoorClick
    /return
|-----------------------------------------------------------------------------
| SUB: KTInvite
| ----------------------------------------------------------------------------
    Sub Event_KTInvite
        /varset EventFlag 1
        /declare i int
        /declare WhoToInvite ${SpawnCount[pc radius 75 guild]}
        /alert clear 6
        /squelch /alert add 6 ${Me}
        /for i 1 to ${WhoToInvite}
            /target id ${NearestSpawn[radius 75 pc guild noalert 6].ID}
            /delay 10
            /invite
            /delay 20
            /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bct ${Target.CleanName} //invite
            } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
                /dex ${Target.CleanName} /invite
            }
            /delay 10
            /squelch /alert add 6 id ${Target.ID}
        /next i
    /return
|-----------------------------------------------------------------------------
| SUB: Reload INI Settings
| ----------------------------------------------------------------------------
    Sub Bind_Settings(string command1, string command2, int skipIniCheck)
        /declare CondNo     int     local     0
        /if (!${Select[${command1},load,list,help]}) {
            /echo Invalid Settings command.. Please use load, list, or help.
            /return
        }
        /if (${command1.Equal[load]}) {
            /if (!${command2.Length} || ${command2.Equal[null]}) /varset command2 all
            /if (!${Select[${command2},all,general,spells,buffs,melee,gom,gmail,ae,dps,aggro,heals,cures,pet,merc,mez,burn,pull,pulladvanced,afktools,conditions]}) {
                /echo Invalid reload option. Valid options are: general, spells, buffs, melee, gom, gmail, ae, dps, aggro, heals, cures, pet, merc, mez, burn, pull, pulladvanced, afktools, conditions, or all.
                /return
            }
            /echo Loading INI Info from ${command2} Section(s).
            | ************************* General **************************************|
            /if (${Select[${command2},all,general]}) {
                | Edit settings in your KissAssist_ToonName.ini file
                | Only call role from ini if not defined in command line from hot key
                /call LoadIni General Role                  string      Assist
                /if (${p_Role.NotEqual[null]}) /varset Role ${p_Role}
                /call LoadIni General CampRadius            int         30
                /call LoadIni General CampRadiusExceed      int         400
                /call LoadIni General ReturnToCamp          int         0
                /call LoadIni General ChaseAssist           int         0
                /call LoadIni General ChaseDistance         int         25
                /call LoadIni General MedOn                 int         1
                /call LoadIni General MedStart              int         20
                /call LoadIni General MedStop               int         100
                /call LoadIni General MedCombat             int         0
                /call LoadIni General LootOn                int         0
                /call LoadIni General RezAcceptOn           string      1|90
                /call LoadIni General AcceptInvitesOn       int         1
                /call LoadIni General GroupWatchOn          string      0
                /call LoadIni General GroupWatchCheck       string      FALSE
                /call LoadIni General CorpseRecoveryOn      int         0
                /if (${CorpseRecoveryOn}) {
                    /if (${Select[${Me.Class.ShortName},NEC,SHD]}) {
                        /if (${FindItemCount[Tiny Jade Inlaid Coffin]}<2 || ${Me.Level}<70) {
                            /varset CorpseRecoveryOn 2
                        }
                    } else /if (${Me.Class.ShortName.Equal[ROG]}) {
                        /if (!${Me.AltAbility[Shroud of Stealth]}) {
                            /varset CorpseRecoveryOn 2
                        }
                    } else {
                        /varset CorpseRecoveryOn 2
                    }
                }
                /if (${GroupWatchOn.Find[|]}) {
                    /varset GroupWatchPct ${GroupWatchOn.Arg[2,|]}
                    /varset GroupWatchOn ${GroupWatchOn.Arg[1,|]}
                }
                /call LoadIni General EQBCOn                string      0
                /call LoadIni General DanNetOn              string      0
                /call LoadIni General DanNetDelay           int         20
                /if (${EQBCOn}) {
                    /varset BroadCastSay bc
                    /if (${EQBCOn.Arg[2,|].Length} && ${EQBCOn.Arg[1,|].Equal[2]}) {
                        DEBUGN ${EQBCOn} ${EQBCOn.Arg[1,|]} ${EQBCOn.Arg[2,|]}
                        /varset BroadCastSay bct ${EQBCOn.Arg[2,|]}
                        /varset EQBCOn 2
                    }
                } else /if (${DanNetOn}) {
                    /varset BroadCastSay dgtell all
                    /if (${DanNetOn.Arg[2,|].Length} && ${DanNetOn.Arg[1,|].Equal[2]}) {
                        DEBUGN ${DanNetOn} ${DanNetOn.Arg[1,|]} ${DanNetOn.Arg[2,|]}
                        /varset BroadCastSay dgtell ${DanNetOn.Arg[2,|]}
                        /varset DanNetOn 2
                    }
                }
                /call LoadIni General IRCOn                 int         0
                /call LoadIni General CampfireOn            int         0
                /if (${Int[${Ini[${IniFileName},General,CharInfo].Arg[2,|]}]}!=${Me.Level}) /ini "${IniFileName}" "General" "CharInfo" "${Me.Class}|${Me.Level}|${Me.Subscription}"
                /if (${Int[${Ini[${IniFileName},General,DefaultUI].Arg[1,|]}]}!=${EverQuest.CurrentUI.Equal[Default]}) /ini "${IniFileName}" "General" "DefaultUI" "${If[${EverQuest.CurrentUI.Equal[Default]},TRUE,FALSE|Custom UIs are not supported. Please switch to Default UI before posting bugs.]}"
                /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
                    /call LoadIni General GroupEscapeOn     int         0
                } else {
                    /if (!${Defined[GroupEscapeOn]}) {
                        /declare GroupEscapeOn              int         outer    0
                    }
                }
                /call LoadIni General DPSMeter              int         0
                /call LoadIni General ScatterOn             int         0
                /call LoadIni General LOSBeforeCombat       int         0
                /call LoadIni General UseSpawnMaster        int         0
                /if (${IAmABard}) {
                    /call LoadIni Bard MedleyOn             int         0
                    /call LoadIni Bard MedSongGem           int         "Mana song gem"
                    /call LoadIni Bard MedleyName           string      "Medley Name"
                } else {
                    /if (!${Defined[MedleyOn]}) {
                        /declare MedleyOn                   int         outer       0
                        /declare MedSongGem                 int      outer       0
                        /declare MedleyName                 string      outer       0
                    }
                }
            }
            | ************************* Spells *************************************|
            /if (${Select[${command2},all,spells]}) {
                /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}==0) {
                    /call LoadIni SpellS MiscGem            int         8
                    /call LoadIni SpellS MiscGemLW          int         0
                    /call LoadIni SpellS MiscGemRemem       int         1
                    /call LoadIni SpellS LoadSpellSet       int         0
                    /call LoadIni SpellS SpellSetName       string      "KissAssist"
                    /call LoadIni Spells CastingInterruptOn int         1
                    /call LoadIni Spells CheckStuckGem      int         1
                    /if (${CastingInterruptOn}==1) /varset CastingInterruptOn 30
                } else /if (!${Defined[MiscGem]} ) {
                    /declare MiscGem                        int         outer   0
                    /declare MiscGemLW                      int         outer   0
                    /declare MiscGemRemem                   int         outer   0
                    /declare LoadSpellSet                   int         outer   0
                    /declare SpellSetName                   string      outer   null
                    /declare CastingInterruptOn             int         outer   0
                    /declare CheckStuckGem                  int         outer   0
                }
            }
            | ************************* Buffs ****************************************|
            /if (${Select[${command2},all,buffs]}) {
                /if (${LoadFromINI}) /call AutoLoad "buffs"
                /if (${Defined[Buffs]}) /deletevar Buffs
                /call LoadIni Buffs BuffsOn                 int         0
                /call LoadIni Buffs BuffsSize               int         20
                /declare Buffs[${BuffsSize}]                string      outer
                /call LoadIni Buffs Buffs                   string      NULL       Buffs
                /call LoadIni Buffs RebuffOn                int         1
                /call LoadIni Buffs CheckBuffsTimer         int         10
                /call LoadIni Buffs PowerSource             string      NULL
                /if (${BuffsOn}) {
                    /call SortArray Buffs 100|100 >
                } else {
                    /call CreateTimersBuffs
                }
            }
            | ************************* Melee ****************************************|
            /if (${Select[${command2},all,melee]}) {
                /call LoadIni Melee AssistAt                int         95
                /if (${p_AssistAt}) /varset AssistAt ${p_AssistAt}
                /if (${Select[${Me.Class.ShortName},BST,BER,MNK,PAL,RNG,ROG,SHD,WAR]}) {
                    /call LoadIni Melee MeleeOn             int         1
                } else {
                    /call LoadIni Melee MeleeOn             int         0
                }
                /call LoadIni Melee FaceMobOn               int         1
                /call LoadIni Melee MeleeDistance           int         75
                /call LoadIni Melee StickHow                string      "snaproll"
                /call LoadIni Melee AutoFireOn              int         0
                /call LoadIni Melee UseMQ2Melee             int         0
                /call LoadIni Melee TargetSwitchingOn       int         0
                /if (${Select[${Me.Class.ShortName},ROG]}) {
                    /call LoadIni Melee AutoHide            int         1
                } else /if (!${Defined[AutoHide]}) {
                    /declare AutoHide                       int         outer 0
                }
                
                   /declare MeleeTwistOn                    int         outer       0
                   /declare MeleeTwistWhat                  string      outer       0
                
                /call LoadIni Melee PetTauntOverride        int         0
            }
            | ************************* GoM ****************************************|
            /if (${Select[${command2},all,gom]}) {
                /if (!${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
                    /if (${Defined[GoMSpell]}) /deletevar GoMSpell
                    /call LoadIni GoM GoMSHelp              string       "Format - Spell|Target, MA Me or Mob, i.e. Rampaging Servant Rk. II|Mob"
                    /call LoadIni GoM GoMSize               int         3
                    /declare GoMSpell[${GoMSize}]           string      outer
                    /call LoadIni GoM GoMSpell              string      NULL       GoMSpell
                    /call CreateTimersGoM
                } else /if (!${Defined[GoMSize]}) {
                    /declare GoMSize                        int         outer 1
                    /declare GoMSpell[${GoMSize}]           string      outer
                }
            }
            | ************************* Gmail ****************************************|
            /if (${Select[${command2},all,gmail]}) {
                /if (${Defined[GMail]}) /deletevar GMail
                /call LoadIni GMail GMailHelp               string      "Events currently support - Dead,Drag,GM,Level,Named,Leftgroup,Tells"
                /call LoadIni GMail GMailOn                 int         0
                /call LoadIni GMail GMailSize               int         5
                /declare GMail[${GMailSize}]                string      outer
                /call LoadIni GMail GMail                   string      NULL       GMail
                /if (${GMailOn}) /call GmailIniParse
            }
            | *************************  AE ******************************************|
            /if (${Select[${command2},all,ae]}) {
                /if (${Defined[AE]}) /deletevar AE
                /call LoadIni AE AEOn                       int         0
                /call LoadIni AE AESize                     int         10
                /call LoadIni AE AERadius                   int         50
                /declare AE[${AESize}]                      string      outer
                /call LoadIni AE AE                         string      NULL       AE
            }
            | ************************* DPS ******************************************|
            /if (${Select[${command2},all,dps]}) {
                /if (${LoadFromINI}) /call AutoLoad "dps"
                /if (${Defined[DPS]}) /deletevar DPS
                /call LoadIni DPS DPSOn                     int         0
                /call LoadIni DPS DPSSize                   int         20
                /call LoadIni DPS DPSSkip                   int         20
                /call LoadIni DPS DPSInterval               int         2
                /declare DPS[${DPSSize}]                    string      outer
                /call LoadIni DPS DPS                       string      NULL        DPS
                /call LoadIni DPS DebuffAllOn               int         0
                /if (${DPSOn}) /call SortArray DPS 1|1 <
            }
            | ************************* Aggro ******************************************|
            /if (${Select[${command2},all,aggro]}) {
                /if (${Defined[Aggro]}) /deletevar Aggro
                /call LoadIni Aggro AggroOn                 int         0
                /if (${Select[${Me.Class.ShortName},SHD,WAR,PAL]})  {
                    /call LoadIni Aggro AggroSize           int         10
                } else {
                    /call LoadIni Aggro AggroSize           int         5
                }
                /declare Aggro[${AggroSize}]                string      outer
                /call LoadIni Aggro Aggro                   string      NULL        Aggro
                /if (${AggroOn}) /call SortArray Aggro 1|1 <
            }
            | ************************* Heals ***************************************|
            /if (${Select[${command2},all,heals]}) {
                /if (${Defined[AutoRez]}) /deletevar AutoRez
                /if (${Defined[Heals]}) /deletevar Heals
                /if (${Defined[SingleHeal]}) /deletevar SingleHeal
                /if (${Defined[GroupHeal]}) /deletevar GroupHeal
                /call LoadIni Heals Help                    string      "Format Spell|% to heal at i.e. Devout Light Rk. II|50"
                /if (${LoadFromINI}) /call AutoLoad "heals"
                /call LoadIni Heals HealsOn                 int         0
                /call LoadIni Heals HealInterval            int         0
                /call LoadIni Heals AutoRezOn               int         0
                /declare AutoRez[3]                         string      outer
                /if (${Select[${Me.Class.ShortName},CLR,SHM,DRU,PAL]})  {
                    /call LoadIni Heals HealsSize           int         15
                } else {
                    /call LoadIni Heals HealsSize           int         5
                }
                /declare Heals[${HealsSize}]                string      outer
                /declare GroupHeal[10]                      string      outer
                /declare SingleHeal[50]                     string      outer
                /call LoadIni Heals Heals                   string      NULL        Heals
                /call LoadIni Heals XTarHeal                int         0
                /call LoadIni Heals XTarHealList            string      "Xtar slots here Example: 5|6|7"
                /call LoadIni Heals HealGroupPetsOn         int         0
                /call LoadIni Heals RezMeLast               int         0
                /if (${HealsOn}) {
                    /call SortArray Heals 100|100 >
                    /call FindSingleHeals
                    /call FindGroupHeals
                    /call CreateTimersHeals
                }
                /if (${AutoRezOn}) /call CreateTimersRez
                /if (${XTarHeal} && ${XTarHealList.NotEqual[null]}) /call SetXTargetHealList "${XTarHealList}"
            }
            | ************************* Cures ***************************************|
            /if (${Select[${command2},all,cures]}) {
                /if (${Defined[Cures]}) /deletevar Cures
                /call LoadIni Cures CuresOn                 int         0
                /call LoadIni Cures CuresSize               int         5
                /declare Cures[${CuresSize}]                string      outer
                /call LoadIni Cures Cures                   string      NULL        Cures
            }
            | ************************* Pet *****************************************|
            /if (${Select[${command2},all,pet]}) {
                /if (${Defined[PetBuffs]}) /deletevar PetBuffs
                /if (${Defined[PetToysDone]}) /deletevar PetToysDone
                /if (${Defined[PetToys]}) /deletevar PetToys
				|/if (${Defined[CharmAECount]}) /deletevar CharmAECount
                |/if (${Defined[CharmCount]}) /deletevar CharmCount
				|/if (${Defined[CharmPet]}) /deletevar CharmPet
                |/if (${Defined[CharmAEClosest]}) /deletevar CharmAEClosest
                /if (${Select[${Me.Class.ShortName},DRU,SHM,BST,ENC,MAG,NEC,SHD,BRD]}) {
                    /call LoadIni Pet PetOn                 int         0
                    /call LoadIni Pet PetSpell              string      "YourPetSpell"
                    /call LoadIni Pet PetFocus              string      "NULL"
                    /call LoadIni Pet PetShrinkOn           int         0
                    /call LoadIni Pet PetShrinkSpell        string      "Tiny Companion"
                    /call LoadIni Pet PetBuffsOn            int         0
                    /call LoadIni Pet PetBuffsSize          int         8
                    /declare PetBuffs[${PetBuffsSize}]      string      outer
                    /call LoadIni Pet PetBuffs              string      NULL    PetBuffs
                    /call LoadIni Pet PetCombatOn           int         1
                    /call LoadIni Pet PetAssistAt           int         95
                    /call LoadIni Pet PetAttackDistance     int         115
                    /declare PetToysDone                    int         outer   0
                    /call LoadIni Pet PetToysSize           int         6
                    /declare PetToys[${PetToysSize}]        string      outer
                    /if (${Select[${Me.Class.ShortName},MAG]}) {
                        /call LoadIni Pet PetToysOn         int         0
                        /call LoadIni Pet PetToys           string      NULL    PetToys
                        /call LoadIni Pet PetToysGave       string      NULL
                    } else /if (!${Defined[PetToysOn]}) {
                        /declare PetToysGave                string      outer   NULL
                        /declare PetToysOn                  int         outer   0
                    }
					/if (${Select[${Me.Class.ShortName},DRU,ENC,NEC,BRD]}) {
					/call LoadIni Pet CharmOn                 int         0
					/call LoadIni Pet CharmSpell              string      NULL
					/call LoadIni Pet CharmMinLevel           int         5
                    /call LoadIni Pet CharmMaxLevel           int         0
					/call LoadIni Pet CharmRadius             int         50
					/call LoadIni Pet CharmKeep 			   int 			0
					/if (!${Defined[CharmAEClosest]}) /declare CharmAEClosest                   int         outer 0
					/if (!${Defined[CharmCount]}) /declare CharmCount[13]                   int         outer 0
					| This loads and declares the CharmImmune var
					/call LoadIni "${ZoneName}" CharmImmune   string      "List up to 10 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL ${InfoFileName}
					/if (${CharmOn}) /call CreateTimersCharm
						|KissAssist_Info variables
						/if (!${CharmImmune.Find[null]} && ${CharmImmune.Length}>0) {
							/squelch /alert clear 4
							/call AlertAddToList 4 "${CharmImmune}"
						} else {
							/varset CharmImmune null
						}
					}

                    /call LoadIni Pet PetBreakMezSpell      string      NULL
                    /call LoadIni Pet PetRampPullWait       int         0
                    /call LoadIni Pet PetSuspend            int         0
                    /call LoadIni Pet MoveWhenHit           int         0
                    /call LoadIni Pet PetHoldOn             int         1
                    /if (!${Defined[PetHold]}) /declare PetHold                        string     outer
                    /if (${Int[${Me.AltAbility[Companion's Discipline]}]} > 0) {
                        /if (${Me.AltAbility[Companion's Discipline]}>1) {
                            /varset PetHold ghold
                        } else {
                            /varset PetHold hold
                        }
                    }
                    /call LoadIni Pet PetForceHealOnMed     int         0
                } else /if (!${Defined[PetOn]}) {
                    /declare PetForceHealOnMed              int         outer   0
                    /declare PetOn                          int         outer   0
                    /declare PetAssistAt                    int         outer   0
                    /declare PetCombatOn                    int         outer   0
                    /declare PetRampPullWait                int         outer   0
                    /declare PetHoldOn                      int         outer   0
                    /declare PetHold                        string      outer   0
                    /declare PetToysOn                      int         outer   0
                    /declare PetAttackDistance              int         outer   0
                }
            }
			/if (!${Defined[CharmOn]}) /declare CharmOn      int         outer   0
			/if (!${Defined[CharmRadius]}) /declare CharmRadius      int         outer   0
			/if (!${Defined[CharmMaxLevel]}) /declare CharmMaxLevel      int         outer   0
			/if (!${Defined[CharmMinLevel]}) /declare CharmMinLevel      int         outer   80
			/if (!${Defined[CharmSpell]}) /declare CharmSpell      string         outer   0
			/if (!${Defined[CharmKeep]}) /declare CharmKeep 		int			outer 		0
            | ************************* Merc ****************************************|
            /if (${Select[${command2},all,merc]}) {
                /call LoadIni Merc Help                     string      "To use: Turn off Auto Assist in Manage Mercenary Window"
                /call LoadIni Merc MercOn                   int         0
                /call LoadIni Merc MercAssistAt             int         92
            }
            | ************************* Mez *****************************************|
            /if (${Select[${command2},all,mez]}) {
                /if (${Defined[MezAECount]}) /deletevar MezAECount
                /if (${Defined[MezCount]}) /deletevar MezCount
                /if (${Defined[MezAEClosest]}) /deletevar MezAEClosest
                /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
                    /call LoadIni Mez MezOn                 int         0
                    /call LoadIni Mez MezRadius             int         50
                    /call LoadIni Mez MezMinLevel           int         0
                    /call LoadIni Mez MezMaxLevel           int         0
                    /call LoadIni Mez MezStopHPs            int         80
                    /call LoadIni Mez MezSpell              string      NULL
                    /call LoadIni Mez MezDebuffOnResist     int         0
                    /call LoadIni Mez MezDebuffSpell        string      NULL
                    | necros can't AE mez
                    /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
                        /call LoadIni Mez MezAESpell        string      NULL
                        /declare MezAECount                 int         outer   ${MezAESpell.Arg[2,|]}
                        /varset MezAESpell                  ${MezAESpell.Arg[1,|]}
                    }
                    /declare MezCount[13]                   int         outer 0
                    /declare MezAEClosest                   int         outer 0

                } else /if (!${Defined[MezOn]}) {
                    /declare MezOn                          int         outer 0
                }


				| This loads and declares the MezImmune var
                /call LoadIni "${ZoneName}" MezImmune   string      "List up to 10 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL ${InfoFileName}
                /call LoadIni "${ZoneName}" AAMezImmune int         0 0 ${InfoFileName}
                /if (${MezOn}) /call CreateTimersMez
                |KissAssist_Info variables
                /if (!${MezImmune.Find[null]} && ${MezImmune.Length}>0) {
                    /squelch /alert clear 4
                    /call AlertAddToList 4 "${MezImmune}"
                } else {
                    /varset MezImmune null
                }
            }
            | ************************* Burn ****************************************|
            /if (${Select[${command2},all,burn]}) {
                /if (${Defined[Burn]}) /deletevar Burn
                /call LoadIni Burn  BurnAllNamed            int         0
                /call LoadIni Burn  UseTribute              int         0
                /call LoadIni Burn  BurnSize                int         15
               | /if (${IAmABard}) {
                |    /call LoadIni Burn BurnTwistWhat        string      0
                /if (!${Defined[BurnTwistWhat]}) {
                   /declare BurnTwistWhat                   string      outer       0
                }
                /declare Burn[${BurnSize}]                  string      outer
                /call LoadIni Burn  Burn                    string      NULL        Burn
                /call SortArray Burn 1|1 >
                /call FixBurnSpells
            }
            | ************************* Pull ****************************************|
            /if (${Select[${command2},all,pull]}) {
                /call LoadIni Pull PullWith                 string      "Melee"
                /call LoadIni Pull PullMeleeStick           int         0
                /call LoadIni Pull MaxRadius                int         350
                /call LoadIni Pull MaxZRange                int         50
                /call LoadIni Pull UseWayPointZ             int         0
                /call LoadIni Pull PullWait                 int         5
                                                                        | Include the # symbol for mobs with names that start with #
                /call LoadIni "${ZoneName}" MobsToPull      string      "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or ALL for all mobs" NULL  ${InfoFileName}
                /call LoadIni "${ZoneName}" MobsToIgnore    string      "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL ${InfoFileName}
                /call LoadIni "${ZoneName}" MobsToBurn      string      "List up to 10 mobs. Use full names i.e. Beget Cube,Helias,Raze or NULL" Null ${InfoFileName}
                /call LoadIni "${ZoneName}" PullPath        string      "Place holder for path file. Not yet impletmented." NULL ${InfoFileName}
                /if (${p_PullPath.NotEqual[null]}) /varset PullPath ${p_PullPath}
                /call LoadIni Pull PullRadiusToUse          int         90
                /call LoadIni Pull PullRoleToggle           int         0
                /call LoadIni Pull ChainPull                int         0
                /call LoadIni Pull ChainPullHP              int         90
                /call LoadIni Pull PullPause                string      30|2
                /call LoadIni Pull PullLevel                string      0|0
                /call LoadIni Pull PullArcWidth             string      0

                /if (!${Defined[PullTwistOn]}) {
                    /declare PullTwistOn                    int         outer       0
                }
                /call LoadIni Pull PullOnReturn             int         0
                /if ((${MobsToPull.Find[all for all]} || !${MobsToPull.Length} || ${MobsToPull.Equal[all]} || ${MobsToPull.Equal[null]}) && (${MobsToIgnore.Find[or null]} || !${MobsToIgnore.Length} || ${MobsToIgnore.Equal[null]})) {
                    /varset MobsToPull all
                    /varset MobsToIgnore null
                } else /if (${MobsToIgnore.Find[or null]} || !${MobsToIgnore.Length} || ${MobsToIgnore.Equal[null]}) {
                    /varset MobsToIgnore null
                } else /if (${MobsToPull.Find[all for all]} || !${MobsToPull.Length} || ${MobsToPull.Equal[all]} || ${MobsToPull.Equal[null]}) {
                    /varset MobsToPull all
                }
                /squelch /alert clear 2
                /if (${MobsToPull.Equal[all]}) {
                    /varset SearchType noalert 1
                } else {
                    /call AlertAddToList 2 "${MobsToPull}" "null"
                    /varset SearchType alert 2
                }
                /squelch /alert clear 3
                /if (${MobsToIgnore.NotEqual[null]}) {
                    /call AlertAddToList 3 "${MobsToIgnore}" "null"
                }
                /if (${Role.Find[Puller]} || ${Role.Find[hunter]}) {
                    /if (${Bool[${Plugin[MQ2Map]}]}) {
                        /squelch /mapfilter CastRadius color 25 225 25
                        /squelch /mapfilter SpellRadius color 25 25 225
                        /squelch /mapfilter PullRadius color 255 255 0
                        /squelch /mapfilter CampRadius color 255 25 25
                    }
                }
                /if (!${PullRadiusToUse} || ${PullRadiusToUse}>100) /varset PullRadiusToUse 100
            }
            | *********************** PullAdvanced ***********************************|
            /if (${Select[${command2},all,pullAdvanced]}) {
                /if (${Defined[PullLocs]}) /deletevar PullLocs
            |    /call LoadIni pullAdvanced CalmOn           int         0
            |    /call LoadIni pullAdvanced CalmWith         string      0
            |    /call LoadIni pullAdvanced CalmRadius       int         50
            |    /call LoadIni pullAdvanced PullAbortOn      int         0
            |    /call LoadIni pullAdvanced PullAbortCMD     string      null

                /declare PullLocs[5]                        string      outer
                /call LoadIni PullAdvanced PullLocsOn       int         0
                /call LoadIni "${ZoneName}" PullLocsHelp    string      "Y,X|Range. Ignore mobs in this area" NULL ${InfoFileName}
                /call LoadIni "${ZoneName}" PullLocs        string      0        PullLocs ${InfoFileName}
            }
            | ************************* AFKTools ************************************|
            /if (${Select[${command2},all,afktools]}) {
                /call LoadIni AFKTools AFKHelp              string      "AFKGMAction=0 Off, 1 Pause Macro, 2 End Macro, 3 Unload MQ2, 4 Quit Game"
                /call LoadIni AFKTools AFKToolsOn           int         1
                /call LoadIni AFKTools AFKGMAction          int         1
                /call LoadIni AFKTools AFKPCRadius          int         500
                /call LoadIni AFKTools CampOnDeath          int         0
                /call LoadIni AFKTools ClickBacktoCamp      int         0
            }
            | ************************* Kcond ************************************|
            /if (${Select[${command2},all,conditions]}) {
                /if (${Defined[Cond]}) /deletevar Cond
                /call LoadIni KConditions ConOn             int         0
                /call LoadIni KConditions CondSize          int         5
                /declare Cond[${CondSize}]                  string      outer
                /call LoadIni KConditions Cond              string      TRUE      Cond
            }
            | Re-figure Declared variables if needed.
            /if (${Select[${command2},all,pull]}) {
                /if (${PullPause.Find[|cond]}) {
                    /squelch /engine parser 2
                    /varset CondNo ${PullPause.Mid[${Math.Calc[${PullPause.Find[|cond]}+5]},3]}
                    /varset PullHoldCond ${Parse[1,${Cond[${CondNo}]}]}
                    /squelch /engine parser 1
                } else {
                    /varset PullHoldCond FALSE
                }
            }
            /if (!${skipIniCheck}) {
                /echo Checking your ini file for errors.
                /call ScanIni ${command2}
            }
        }
        DEBUGN Settings: 1: ${command1} 2: ${command2} procesed
    /return
|-----------------------------------------------------------------------------
| SUB: AssignLooter
| ----------------------------------------------------------------------------
    Sub AssignLooter
        /if (${Select[${Me},${Group.Leader}]}==0) /return
        /if (${LooterAssigned}) /return
        /if (${Group}<=0 || ${Raid.Members}>0) /return
        /if (${Group.MasterLooter.ID}>=1) /return
        DEBUGN Sub AssignLooter Enter
        /declare k int local
        /declare IniIDList string local
        /declare IniIDCount int local
        /declare IniID int local
        /declare AmIML string local
        /if (!${DanNetOn}) {
            /varset IniIDList ${Ini["KissAssist_Buffs.ini"]}
            /varcalc IniIDCount ${IniIDList.Count[|]}
        } else {
            /varset IniIDList ${DanNet.Peers[all]}
            /varset IniIDCount ${IniIDList.Count[|]}
        }
        /if (!${IniIDCount}) /return
        /declare pIDList[${IniIDCount}] string local
        /for k 1 to ${IniIDCount}
            /varset pIDList[${k}] ${IniIDList.Arg[${k},|]}
        /next k
        | If I am group leader set Main Looter Tag for Group
        /if (${Select[${Me},${Group.Leader}]}) {
            DEBUGN AssignLooter: /echo I am group Leader
            |Assign myself as MainLooter if LootOn=1
            /if (${LootOn}) {
                DEBUGN AssignLooter: /echo I am the looter
                /if (${Group.MasterLooter.Name.NotEqual[${Me}]} && ${Group.MasterLooter.Name.Length}) {
                    /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                    /delay 30 !${Group.MasterLooter.Name.Length}
                    /call AssignGroupRole set "${Group.MainAssist.Name}" 5
                    /call BroadCast r "Assigning ${Me} as Master Looter in Group Window"
                    /varset LooterAssigned 1
                    /return
                }
            } else {
                DEBUGN AssignLooter: Looking for looter
                /for k 1 to ${IniIDCount}
                    /if (!${DanNetOn}) {
                        /varset IniID ${pIDList[${k}]}
                        /varset AmIML ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"AmILooting"]}
                    } else {
                        /varset IniID ${Int[${Spawn[=${pIDList[${k}]}].ID}]}
                        /if (!${IniID} || ${IniID}==${Me.ID} || !${Spawn[id ${IniID} pc group].ID}) /continue
                        /dquery ${pIDList[${k}]} -q "LootOn" -o DNout -t ${DanNetDelay}
                        /if (${Int[DNout]}==0) /continue
                        /varset AmIML ${DNout}
                    }
                    DEBUGN AssignLooter: ${Spawn[${IniIDList.Arg[${k},|]}].ID} ${IniID} ${AmIML} ${Spawn[${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} ${Spawn[id ${IniIDList.Arg[${k},|]} group].ID}
                    | If toon is not the zone or not a PC skip to next ID
                    /if (!${Spawn[id ${IniID}].ID} || ${Spawn[id ${IniID}].Type.NotEqual[pc]} || !${AmIML}) /continue
                    /if (${Spawn[id ${IniID} pc group].ID}) {
                        | If Looter is someone else than who its suppose to be unset Group tag
                        /if (${Group.MasterLooter.Name.Length} && ${Group.MasterLooter.Name.NotEqual[${Spawn[id ${IniID} group pc].CleanName}]}) /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                        /delay 30 !${Group.MasterLooter.Name.Length}
                        /call AssignGroupRole set "${Spawn[id ${IniID} group pc].CleanName}" 5
                        /call BroadCast r "LOOT: Assigning ${Spawn[id ${IniID} group pc].CleanName} as Master Looter in Group Window"
                        /varset LooterAssigned 1
                        /return
                    }
                /next k
            }
        }
        DEBUGN Sub AssignLooter Leave
    /return
| ----------------------------------------------------------------------------
| SUB: GmailParse
| ----------------------------------------------------------------------------
    Sub GmailIniParse
        DEBUGN GmailIniParse Enter
        /declare i int local 0
        /declare GMailEventCheck string local
        /for i 1 to ${GMail.Size}
            /varset GMailEventCheck ${Ini[${IniFileName},Gmail,Gmail${i}]}
            /if (${GMailEventCheck.Length} && ${GMailEventCheck.NotEqual[null]}) {
                /if (${Select[${GMailEventCheck},Dead,Drag,GM,Level,Named,Leftgroup,Tells]}) {
                     DEBUGN /echo ${i}. ${GMailEventCheck}
                    /if (${GMailEvents.Length}) {
                        /varset GMailEvents ${GMailEvents},${GMailEventCheck}
                    } else {
                        /varset GMailEvents ${GMailEventCheck}
                    }
                }
            }
        /next i
        DEBUGN GmailIniParse Leave
    /return
| ----------------------------------------------------------------------------
| SUB: GmailSend
| ----------------------------------------------------------------------------
    Sub GmailSend(GMessage)
        | Not supported by MQNext. Current Date: 11/6/2021
    /return
| ----------------------------------------------------------------------------
| SUB: GmailSend1
| ----------------------------------------------------------------------------
    Sub GmailSend1(GMessage)
        /return
        DEBUGN GmailSend Enter
        |Goofy time shit because Gmail fails if any entry has a colon : in it.
        /declare GTime string local
        /declare GtimeHour string local ${Time.Hour}
        /declare AMPM string local am
        /if (${Time.Hour}>=13) {
            /varset GtimeHour ${Int[${Math.Calc[${Time.Hour}-12]}]}
            /varset AMPM pm
        }
        /varset GTime Date.${Time.Date} Time.${GtimeHour}.${Time.Minute} ${AMPM}
        | Ghetto fix for buffer overflow until MQ2GMail is fixed
        /if (${Bool[${Plugin[MQ2Gmail]}]}) /squelch /plugin MQ2Gmail unload noauto
        /squelch /plugin MQ2Gmail noauto
        /gmail "Kiss-${EverQuest.Server}-${Me}" "${GTime} - ${GMessage}"
        /echo GMAIL just sent "Kiss-${EverQuest.Server}-${Me}" "${GTime} - ${GMessage}"
        /varcalc GSent ${GSent}+1
        /if (${GSent}==5) {
            /varset GSent 0
        }
        /delay 10
        DEBUGN GmailSend Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Roguestuff
| ----------------------------------------------------------------------------
    Sub Roguestuff
        /if (${Me.Hovering}) /return
        DEBUGN Roguestuff Enter
        /if (${Me.Class.Name.Equal[Rogue]} && !${Me.Combat} && ${AutoHide}) {
            /if (${Me.AbilityReady[hide]} && ${Me.AbilityReady[sneak]}) {
                /doability hide
                /doability sneak
            }
        }
        DEBUGN Roguestuff Leave
    /return
| ----------------------------------------------------------------------------
| SUB: LoadSpellSet
| ----------------------------------------------------------------------------
    Sub LoadSpellSet
        DEBUGN LoadSpellSet Enter
        /declare GemNum      int local
        /declare ValidSpells int local 0

        DEBUGN Sub LoadSpellSet LoadSpellSet=(${LoadSpellSet})
        /varcalc GemSlots ${Int[${Me.AltAbility[Mnemonic Retention].Rank}]}+8
        /if (${LoadSpellSet}==1) {
            DEBUGN Sub LoadSpellSet SpellSetName=(${SpellSetName})
            /echo Memming spellset (${SpellSetName}).
            /memspellset ${SpellSetName}
            /delay ${Math.Calc[${GemSlots}*10]}
        } else {
            |---Test to see if we have MySpells section defined in INI or not.
            /for GemNum 1 to ${GemSlots}
                /call LoadIni Spells Gem${GemNum} string NULL
                /if (${Gem${GemNum}.Length} && ${Gem${GemNum}.NotEqual[NULL]}) {
                    |-- We have found a good spell defined, one good spell is all it takes to be a valid Spells config.
                    /varset ValidSpells 1
                    /break
                }
            /next GemNum
            /if (${LoadSpellSet}==2) {
                /if (!${ValidSpells}) {
                    /echo You have no valid spells defined in your ini file [Spells], load your spells now and do a /writespells command while in KissAsssist.
                } else {
                    /call Bind_MemMySpells ${Me.CleanName}
                }
            }
        }
        |-- If we called this routine, make sure we update values for ReMemMiscSpell and ReMemMiscSpellLW since they might have changed after spellset load.
        /varset ReMemMiscSpell ${Me.Gem[${MiscGem}].Name}
        /varset ReMemMiscSpellLW ${Me.Gem[${MiscGemLW}].Name}
        DEBUGN LoadSpellSet Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Set Window Title Buffs
| ----------------------------------------------------------------------------
    Sub WinTitle
        DEBUGN WinTitle Enter
        /SetWinTitle ${Me.Name} (Lvl:${Me.Level} ${Zone.ShortName})
        DEBUGN WinTitle Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Do Class Stuff 
| ----------------------------------------------------------------------------
    Sub DoClassStuff
        | Reserved for now
    /return
| ----------------------------------------------------------------------------
| SUB: Summon Corpse
| ----------------------------------------------------------------------------
    Sub RecoverCorpses(string rc_Flag1,int rc_Distance)
        /declare int_summonID    int    local 0
        /declare int_summonLevel int    local 0
        /declare int_coffinCount int    local 0
        /declare int_corpseCount int    local 0
        /declare int_idx1        int    local 0
        /declare int_idx2        int    local 0
        /declare str_useWhat     string local
        /declare str_Status      string local false
        /declare tim_wait1       timer  local 0
        /if (${AggroTargetID} || ${Me.Invis}) /return false
        /if (!${Select[${Me.Class.ShortName},shd,nec,rog]}) /return false

        /if (!${rc_Distance}) /varset rc_Distance 150
        DEBUGN SummonCorpse Enter ${rc_Flag1} ${rc_Distance}
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>10) /call DoWeMove 1 summoncorpse
        /if (!${SpawnCount[pccorpse ${Me}]} && !${SpawnCount[pccorpse group]}) /return false
        /if (${Select[${Me.Class.ShortName},shd,nec]}) {
            /if (${FindItemCount[Tiny Jade Inlaid Coffin]}<2) {
                /varset CorpseRecoveryOn 2
                /return false
            }
            /while (1) {
                /varset int_coffinCount ${FindItemCount[Tiny Jade Inlaid Coffin]}
                /varset int_summonID 0
                /varset str_useWhat null
                /if (${SpawnCount[pccorpse ${Me}]}) {
                    /if (${NearestSpawn[1,${Me} pccorpse].Distance3D}>${rc_Distance}) {
                        /varset int_summonID ${Me.ID}
                        /varset int_summonLevel ${Me.Level}
                    }
                }
                /if (!${int_summonID}) {
                    /if (${rc_Flag1.Equal[me]}) /break
                    /for int_idx1 1 to 5
                        /if (${Group.Member[${int_idx1}].OtherZone} || ${Group.Member[${int_idx1}].Type.Equal[corpse]} || ${Group.Member[${int_idx1}].Distance3D}>100) /continue
                        /varset int_corpseCount ${SpawnCount[${Group.Member[${int_idx1}].CleanName} pccorpse]}
                        /if (${int_corpseCount}) {
                            /for int_idx2 1 to ${int_corpseCount}
                                /if (${NearestSpawn[${int_idx2},${Group.Member[${int_idx1}].CleanName} pccorpse].Distance3D}>${rc_Distance}) {
                                    /varset int_summonID ${Group.Member[${int_idx1}].ID}
                                    /varset int_summonLevel ${Group.Member[${int_idx1}].Level}
                                    /break
                                }
                            /next int_idx2
                        }
                        /if (${int_summonID}) /break
                    /next int_idx1
                }

                /if (!${int_summonID}) /break

                /if (${Me.AltAbilityReady[Summon Remains]} && ${int_coffinCount}>3) {
                    /varset str_useWhat Summon Remains
                } else /if (${int_coffinCount}>1) {
                    /if (${Me.Spell[Thanatos' Proclamation].ID}) {
                        | Up to level 120 TJIC x 2
                        /varset str_useWhat Thanatos' Proclamation
                    } else /if (${Me.Spell[Duskreaper's Proclamation].ID} && ${int_summonLevel}<116) {
                        | Up to level 115 TJIC x 2
                        /varset str_useWhat Duskreaper's Proclamation
                    } else /if (${Me.Spell[Shadereaper's Proclamation].ID} && ${int_summonLevel}<111) {
                        | Up to level 110 TJIC x 2
                        /varset str_useWhat Shadereaper's Proclamation
                    } else /if (${Me.Spell[Stormreaper's Proclamation].ID} && ${int_summonLevel}<106) {
                        | Up to level 105 TJIC x 2
                        /varset str_useWhat Stormreaper's Proclamation
                    } else /if (${Me.Spell[Reaper's Proclamation].ID} && ${int_summonLevel}<101) {
                        | Up to level 100 TJIC x 2
                        /varset str_useWhat Reaper's  Proclamation
                    } else /if (${Me.Spell[Reaper's Decree].ID} && ${int_summonLevel}<96) {
                        | Up to level 95 TJIC x 2
                        /varset str_useWhat Reaper's Decree
                    } else /if (${Me.Spell[Reaper's Beckon].ID} && ${int_summonLevel}<91) {
                        | Up to level 90 TJIC x 2
                        /varset str_useWhat Reaper's Beckon
                    } else /if (${Me.Spell[Reaper's Call].ID} && ${int_summonLevel}<86) {
                        | Up to level 85 TJIC x 2
                        /varset str_useWhat Reaper's Call
                    } else /if (${Me.Spell[Procure Corpse].ID} && ${int_summonLevel}<81) {
                        | Up to level 80 TJIC x 2
                        /varset str_useWhat Procure Corpse
                    } else /if (${Me.Spell[Exhumer's Corpse].ID} && ${int_summonLevel}<76) {
                        | Up to level 75 TJIC x 2
                        /varset str_useWhat Exhumer's Corpse
                    } else /if (${Me.Spell[Conjure Corpse].ID} && ${int_summonLevel}<71) {
                        | Up to level 70 TJIC x 2
                        /varset str_useWhat Conjure Corpse
                    }
                }
                /if (${str_useWhat.Equal[null]}) /break

                /while (${Me.SpellInCooldown}) {
                   /delay 5
                }

                /if (${Me.Gem[${str_useWhat}]}) {
                    /varset tim_wait1 350
                    /while (!${Me.SpellReady[${str_useWhat}]} && ${tim_wait1}) {
                        /if (${ChaseAssist}) {
                            /call DoWeChase 0 summoncorpse
                        } else {
                            DOPARSE
                            /delay 5
                        }
                    }
                    /if (!${Me.SpellReady[${str_useWhat}]}) /break
                }

                /if (${Me.Invis}) /break
                /if (!${Target.ID} || ${Target.ID}!=${int_summonID}) /squelch /target id ${int_summonID}
                /call CastWhat "${str_useWhat}" ${int_summonID} summoncorpse-nomem 0 0
                /if (${Macro.Return.Equal[cast_success]}) {
                    /call BroadCast r "Summoned Corpse for: ${Spawn[ID ${int_summonID}].CleanName} Using: ${str_useWhat}"
                    /varset str_Status true
                    /delay 20
                } else {
                    /break
                }
                /if (${rc_Flag1.Equal[me]}) /break

            | End of While Loop.
            }
        } else /if (${Me.Class.ShortName.Equal[rog]}) {
            /echo Rogues are not Supported at this time. Thank you for shopping at RedGuides.
            /delay 50
            /varset CorpseRecoveryOn 2
        }
        DEBUGN SummonCorpse Leave ${int_summonID} ${int_coffinCount} ${str_useWhat} ${int_summonLevel}
    /return ${str_Status}
| ----------------------------------------------------------------------------
| SUB: Grab Corpse
| ----------------------------------------------------------------------------
    Sub GrabCorpse(int checkFlag)
        DEBUGN GrabCorpse Enter ${checkFlag}
        /if (!${checkFlag}) /varset checkFlag 1
        /if (${checkFlag}==1) {
            /if (${SpawnCount[pccorpse ${Me}]}) {
                /if (${CorpseRecoveryOn}==1) {
                    /if (${NearestSpawn[1,pccorpse ${Me}].Distance3D}>89) {
                        /call RecoverCorpses "me" 89
                        /delay 30
                    }
                }
                /if (${SpawnCount[pccorpse ${Me} radius 89]}) {
                    /corpsedrag
                    /varset DragCorpse 1
                }
            }
        } else /if (${checkFlag}==2) {
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius}) {
                /target ${Me}
                /delay 10
                /corpsedrag
                /varset DragCorpse 1
                /echo Hey I found my corpse. Running back to camp for a rez
                |/if (${GMailEvents.Find[drag]}) /call GmailSend "Hey I found my corpse. Running back to camp for a rez!"
            }
        }
        DEBUGN GrabCorpse Leave
    /return
| ----------------------------------------------------------------------------
| SUB: DoCastingEvents
| ----------------------------------------------------------------------------
    Sub DoCastingEvents(int CastTimer, int actionFlag)
        DEBUGCAST DoCastingEvents \awEnter
        /declare CastCalcTimer timer local 10
        /declare castHold string local ${castReturn}
        /if (${CastTimer}) /varset CastCalcTimer ${CastTimer}
        /while (${CastCalcTimer} && ${castHold.Equal[${castReturn}]}) {
            /doevents CAST_BEGIN
            /doevents CAST_CANNOTSEE
            /doevents CAST_COLLAPSE
            /doevents CAST_DISTRACTED
            /doevents CAST_FDFAIL
            /doevents CAST_FIZZLE
            /doevents CAST_IMMUNE
            /doevents CAST_INTERRUPTED
            /doevents CAST_NOMOUNT
            /doevents CAST_NOTARGET
            /doevents CAST_NOTREADY
            /doevents CAST_OUTDOORS
            /doevents CAST_OUTOFMANA
            /doevents CAST_OUTOFRANGE
            /doevents CAST_RECOVER
            /varset CheckResisted 1
            /doevents CAST_RESISTED
            /varset CheckResisted 0
            /doevents CAST_RESISTEDYOU
            /doevents CAST_STANDING
            /doevents CAST_STUNNED
            /doevents CAST_TAKEHOLD
            /doevents CAST_FAILED
            /doevents CAST_COMPONENTS
            /if (${actionFlag}) /break
        }
        DEBUGCAST DoCastingEvents \awLeave ${CastCalcTimer} ${castHold} ${castReturn} ${Me.Casting.ID} ${Window[CastingWindow].Open}
    /return
| ----------------------------------------------------------------------------
| SUB: Auto Load INI Entries
| ----------------------------------------------------------------------------
    Sub AutoLoad(string SectionName)
        /if (${SectionName.Equal[null]} || !${SectionName.Length}) /return
        /if (${Select[${SectionName},buffs,heals,dps]}==0) /return
        /echo AutoLoad INI - ${SectionName}
        /declare ActionsTag     string     local
        /declare SpellLevel     int        local
        /declare SpellLevelChk  int        local
        /declare ka             int        local
        /declare kb             int        local
        /declare kc             int        local
        /declare kl             int        local
        /declare km             int        local
        /declare kx             int        local
        /declare AutoLoadFile   string     local     AUTO${Me.Class.ShortName}.ini
        /declare SpellList      string     local
        /declare SpellListL     string     local
        /declare SpellListT     string     local
        /declare SpellName      string     local
        /declare SpellNameChk   string     local
        /declare VarArray       string     local
        /declare SpellTag       string     local
        /declare SpellTagL      string     local     null
        /declare UseLowerLevel  int        local     0
        /declare MemTheSpell    int        Local     0
        /if (${SectionName.Equal[buffs]}) {
            /varset VarArray Buffs
        } else /if (${SectionName.Equal[heals]}) {
            /varset VarArray Heals
        } else /if (${SectionName.Equal[dps]}) {
            /varset VarArray DPS
        } else {
            /echo Invalid Auto Array (${SectionName}) to check.
            /return
        }
        /varset ka 1
        /varset kc 0
        | File Name Format: AUTO Class Short Name .ini Example: AUTOCLR.ini, AUTOSHM.ini, AUTOMAG.ini
        | tag: is used for what you want to tag on after the end of the spell name.
        |      Use standard kiss syntax.
        |      This should come before the Actions: tag
        |      Example: tag:90|MA.
        | Actions Tag Syntax:
        |      UL - Is used to designate the use of a lower level spell for the previous spell list. This allows for 2 remedy spells.
        |           The spell based on your current level and the one just below your current level.
        |      Mem|# - Mem the spell in Gem #. This has to be last entry on line.
        |
        | Heals1=Ethereal Remedy,Supernal Remedy,Pious Remedy,Sacred Remedy,Solemn Remedy,Devout Remedy,Earnest Remedy,Faithful Remedy,Graceful Remedy,Spiritual Remedy,Merciful Remedy,tag:85|MA,Actions:Mem|1
        | Heals2=tag:90|MA,Actions:UL|Mem|2
        | Heals3=tag:75|!MA
        | Heals4=tag:80|!MA,Actions:UL
        | OR
        | Heals3=tag:75
        | Heals4=tag:80,Actions:UL
        |
        /varset SpellListL null
        /while (1) {
            /varset SpellList null
            /varset SpellListT null
            /varset SpellLevel 0
            /if (${Ini[${AutoLoadFile},${SectionName},${VarArray}${ka}].Length}) {
                /varset SpellListT ${Ini[${AutoLoadFile},${SectionName},${VarArray}${ka}]}
            }
            /if (${SpellListT.NotEqual[null]}) {
                /varset kb 1
                /varset SpellTag null
                /varset kx 1
                /varset ActionsTag null
                | lets parse the line for tags and spells.
                /while (1) {
                    /if (!${Bool[${SpellListT.Arg[${kx},,]}]}) /break
                    /varset SpellNameChk ${SpellListT.Arg[${kx},,]}
                    /if (${SpellNameChk.Left[4].Equal[tag:]}) {
                        /varset SpellTag ${SpellNameChk.Replace[tag:,]}
                    } else /if (${SpellNameChk.Left[8].Equal[actions:]}) {
                        /varset ActionsTag ${SpellNameChk.Replace[actions:,]}
                    } else {
                        /if (${SpellList.Equal[null]}) {
                            /varset SpellList ${SpellNameChk}
                        } else {
                            /varset SpellList ${SpellList},${SpellNameChk}
                        }
                    }
                    /varcalc kx ${kx}+1
                }
                /if (${ActionsTag.NotEqual[null]}) {
                    /if (${ActionsTag.Arg[1,|].Equal[ul]}) {
                        /varset UseLowerLevel 1
                        /if (${ActionsTag.Arg[2,|].Equal[mem]}) {
                            /varset MemTheSpell ${Int[${ActionsTag.Arg[3,|]}]}
                        } else {
                            /varset MemTheSpell 0
                        }
                    } else /if (${ActionsTag.Arg[1,|].Equal[mem]}) {
                        /varset UseLowerLevel 0
                        /varset MemTheSpell ${Int[${ActionsTag.Arg[2,|]}]}
                    }
                } else {
                    /varset MemTheSpell 0
                    /varset UseLowerLevel 0
                }
                | Set SpellList to previous list if no spells listed in the current entry.
                /if (${SpellList.Equal[null]}) {
                    /if (${SpellListL.Equal[null]}) /continue
                    /varset SpellList ${SpellListL}
                } else {
                    /varset SpellListL ${SpellList}
                }

                /varset SpellName null

                |/if (!${SpellListT.Find[,lowerlevel]}) {
                /if (!${UseLowerLevel}) {
                    /while (${Bool[${SpellList.Arg[${kb},,]}]}) {
                        /varset SpellNameChk ${SpellList.Arg[${kb},,].Lower}
                        |/if (${SpellNameChk.Left[4].NotEqual[tag:]}) {
                            /varset SpellLevelChk ${Int[${Spell[${SpellNameChk}].Level}]}
                            /if (${SpellLevelChk}<=${Me.Level} && ${SpellLevel}<${SpellLevelChk}) {
                                | No ${FindItem[=${SpellNameChk}].ID} yet, For like Mounts and stuff. Will have to figure out later.
                                /if (${Me.Book[${SpellNameChk}]} || ${Me.AltAbility[${SpellNameChk}]} || ${Me.CombatAbility[${SpellNameChk}]} || ${Me.Skill[${SpellNameChk}]}) {
                                    /varset SpellLevel ${SpellLevelChk}
                                    /varset SpellName ${SpellNameChk}
                                    /varset kl ${kb}
                                }
                            }
                        |} else {
                        |    /varset SpellTag ${SpellNameChk.Replace[tag:,]}
                        |    /varset SpellTagL null
                        |}
                        /varcalc kb ${kb}+1
                    }
                } else {
                    /if (${kl}>1) {
                        /varcalc km ${kl}-1
                        /varset SpellName ${SpellList.Arg[${km},,].Lower}
                        /varset SpellLevel ${Int[${Spell[${SpellName}].Level}]}
                        /if (${SpellTagL.NotEqual[null]} && ${SpellTag.Equal[null]}) /varset SpellTag ${SpellTagL}
                    }
                }
                /if (${SpellName.NotEqual[null]} && ${SpellLevel}>0) {
                    /varcalc kc ${kc}+1
                    /if (${SpellTag.NotEqual[null]}) {
                        /varset SpellTagL ${SpellTag}
                        /varset SpellName ${SpellName}|${SpellTag}
                    }
                    |} else {
                    |    /varset SpellTagL null
                    |}
                    /ini "${IniFileName}" "${SectionName}" "${VarArray}${kc}" "${SpellName}"
                }
            } else {
                /break
            }
            /varcalc ka ${ka}+1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Startup commands
| ----------------------------------------------------------------------------
    Sub StartupCommands
        DEBUGN StartupCommands Enter
        /declare CommandText string   local null
        /declare i           int      local 0
        /declare StartCount  int      local 0
        /declare CondNo      int      local 0
        /if (!${Ini[${IniFileName},"StartupCommands","CommandSize"].Length}) /return
        /varset StartCount ${Ini[${IniFileName},"StartupCommands","CommandSize"]}
        /if (!${StartCount}) /return
        /for i 1 to ${StartCount}
            /varset CommandText ${Ini[${IniFileName},"StartupCommands","Command${i}"]}
            /if (${ConOn} && ${CommandText.Find[|cond]}) {
                /varset CondNo ${CommandText.Mid[${Math.Calc[${CommandText.Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            /if (${CommandText.Length} && ${CommandText.NotEqual[null]}) {
                /if (${CondNo} && ${If[${Cond[${CondNo}]},0,1]}) /continue
                /docommand ${CommandText}
                DOPARSE
                /delay 5
            }
        /next i
        DEBUGN StartupCommands Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Pause While Hovering
| ----------------------------------------------------------------------------
    Sub PauseWhileHovering(string SentFrom)
        DEBUGN PauseWhileHovering SentFrom: ${SentFrom} Enter
        /declare idx int local 0
        /doevents flush
        /while (${Me.Hovering}) {
            /if (${Role.Find[Puller]} && ${ClickBacktoCamp} && ${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}:${Me.Y},${Me.X}]}>150) {
                /if (${Me.ItemReady[=Fellowship Registration Insignia]}) {
                    /if (${Window[respawnWnd].Open}) {
                        /varset idx ${Window[respawnWnd].Child[RW_OptionsList].List[=Bind Location,2]}
                        /if (${idx}) {
                            /nomodkey /notify respawnWnd RW_OptionsList listselect ${idx}
                            /delay 10
                            /nomodkey /notify respawnwnd RW_SelectButton leftmouseup
                        }
                    }
                } else {
                    /delay 10
                }
            } else {
                /delay 10
            }
        }
        DEBUGN PauseWhileHovering Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Pause While Hovering
| ----------------------------------------------------------------------------
    Sub PauseWhileZoning(string SentFrom)
        DEBUGN \atPauseWhileZoning SentFrom: ${SentFrom} \awEnter
        /while (!${Me.ID} || !${Zone.ID}) {
            /delay 10
        }
        DEBUGN \atPauseWhileZoning \awEnter
    /return
| ----------------------------------------------------------------------------
| SUB: Kiss Conditions
| ----------------------------------------------------------------------------
    Sub KissConditons
        /call LoadIni KConditions Cond              string      TRUE      Cond
    /return
| ----------------------------------------------------------------------------
| SUB: Clear Array
| ----------------------------------------------------------------------------
    Sub ClearArray(CArrayName, CArraySize, CArrayMemberSize)
        /if (!${Defined[CArraySize]}) /return
        /if (!${Defined[CArrayMemberSize]}) /declare CArrayMemberSize string local 0
        /declare i int local
        /declare j int local
        /for i 1 to ${CArraySize}
            /if (${CArrayMemberSize}>=1) {
                /for j 1 to ${CArrayMemberSize}
                    /varset ${CArrayName}[${i},${j}] 0
                /next j
            } else {
                /varset ${CArrayName}[${i}] 0
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: Buff List
| ----------------------------------------------------------------------------
    Sub Bind_TooBuffList(string Action, int ActionID)
        DEBUGBUFF TooBuffList: Enter
        /declare WorkOnID int local ${Int[${ActionID}]}
        /declare WorkOnName string local
        /declare j1 int local 0
        /declare PeersZone string local
        /if (!${WorkOnID}) /varset WorkOnID ${Target.ID}
        DEBUGBUFF TooBuffList: Action: ${Action} ActionID: ${ActionID} WorkOnID: ${WorkOnID}
        /if (!${WorkOnID} && ${Select[${Action},add,remove]}>0) {
            /echo Invalid ID. Please target a Character or use a proper ID.
            /return
        }
        /varset WorkOnName ${Spawn[id ${WorkOnID}].CleanName}
        /if (!${Action.Length} || ${Action.Equal[null]} || ${Select[${Action},add,remove,reset,clear]}==0) {
            /echo Invalid Action for Too Buff List, please use add, remove, reset or clear.
            /return
        }
        /if (${Action.Equal[reset]}) {
            /if (${ExtendedBuffList.Count[|]}>0) {
                /varset j1 1
                /while (${ExtendedBuffList.Arg[${j1},|].Length} && ${ExtendedBuffList.Arg[${j1},|].NotEqual[null]}) {
                    /if (!${Spawn[=${ExtendedBuffList.Arg[${j1},|]}].ID}) {
                        /echo Removed ${ExtendedBuffList.Arg[${j1},|]} from the Too Buff List.
                        /varset ExtendedBuffList ${ExtendedBuffList.Replace[${ExtendedBuffList.Arg[${j1},|]}|,]}
                    } else {
                        /varcalc j1 ${j1}+1
                    }
                }
            }
        } else /if (${Action.Equal[remove]}) {
            /if (${ExtendedBuffList.Find[${WorkOnName}|]}) {
                /varset ExtendedBuffList ${ExtendedBuffList.Replace[${WorkOnName}|,]}
                /echo Removed ${WorkOnName} from Too Buff List.
            } else {
                /echo ${WorkOnName} Not Found on the Too Buff List.
            }
        } else /if (${Action.Equal[clear]}) {
            /echo Too Buff List Cleared.
            /varset ExtendedBuffList
        } else {
            /if (${ExtendedBuffList.Count[|]}>49) {
                /echo There is a limit of 50 ID's. Please remove some before trying to add more.
                /return
            }
            /if (${ExtendedBuffList.Find[${WorkOnName}|]}) {
                /echo ${WorkOnName} Found on Too Buff List. No Need to add again.
                /return
            }
            /if (${Macro.IsTLO[DanNet]} && ${DanNetOn}) {
                /if (${Zone.ShortName.Find[_]}) {
                    /varset PeersZone zone_${Zone.ShortName}
                } else {
                    /varset PeersZone zone_${EverQuest.Server.Lower}_${Zone.ShortName}
                }
                /if (${DanNet.Peers[${PeersZone}].Find[${WorkOnName}|]}) {
                    /echo ${WorkOnName} Found on DanNet Peers[${PeersZone}] List. No Need to add.
                    /return
                }
            }
            /varset ExtendedBuffList ${ExtendedBuffList}${WorkOnName}|
            /Echo Added ${WorkOnName} to the Too Buff List.
        }
        /varset g_ExtendedBuffList ${ExtendedBuffList}
        DEBUGBUFF TooBuffList: Exit
    /return
| ----------------------------------------------------------------------------
| SUB: Ini Cleanup
| ----------------------------------------------------------------------------
    Sub IniCleanup
        /declare ICidx int local 0
        /declare ICtemp string local null
        | General Section
        /ini "${IniFileName}" "General" "ConditionsOn" NULL
        /ini "${IniFileName}" "General" "MiscGem" NULL
        /ini "${IniFileName}" "General" "MiscGemLW" NULL
        /ini "${IniFileName}" "General" "MiscGemRemem" NULL
        /ini "${IniFileName}" "General" "CastingInterruptOn" NULL
        | Buffs Section
        | Melee Section
        /ini "${IniFileName}" "Melee" "BeforeCombat" NULL
        | AE Section
        /ini "${IniFileName}" "AE" "AECOn" NULL
        | DPS Section
        /ini "${IniFileName}" "DPS" "DPSCOn" NULL
        | Aggro Section
        /ini "${IniFileName}" "Aggro" "AggroCOn" NULL
        /ini "${IniFileName}" "Aggro" "Aggro2nd" NULL
        | Heals section
        /ini "${IniFileName}" "Heals" "HealsCOn" NULL
        /ini "${IniFileName}" "Heals" "XTarHeal2" NULL
        /ini "${IniFileName}" "Heals" "AutoRez" NULL
        /ini "${IniFileName}" "Heals" "AutoRez1" NULL
        /ini "${IniFileName}" "Heals" "AutoRez2" NULL
        /ini "${IniFileName}" "Heals" "AutoRez3" NULL
        | Burn Section
        /ini "${IniFileName}" "Burn" "BurnCOn" NULL
        | GOM Section
        /ini "${IniFileName}" "GOM" "GOMCOn" NULL
        | Pull Section
        /ini "${IniFileName}" "Pull" "ChainPullPause" NULL
        | Old SpellSet section. Was moved to Spells section.
        /ini "${IniFileName}" "SpellSet" NULL
        | My Spells Section
        /varset ICtemp ${Ini[${IniFileName},MySpells,Gem1,BLANK]}
        /if (${ICtemp.Length}>0 && ${Select[${ICtemp},blank,null]}==0) {
            /for ICidx 1 to 13
                /varset ICtemp ${Ini[${IniFileName},MySpells,Gem${ICidx},NULL]}
                /ini "${IniFileName}" "Spells" "Gem${ICidx}" "${ICtemp}"
            /next ICidx
            /ini "${IniFileName}" "MySpells" NULL
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Init Data
| ----------------------------------------------------------------------------
    Sub InitData
        /declare n              int       local
        /declare WorkString     string    local
        /declare CondNo         int       local

        /if (${Bool[${Me.AltAbility[Companion's Discipline].Rank}]}) {
            /if (${Me.AltAbility[Companion's Discipline]}>5) /varset PetFocusOn 1
        }
        | Compensate for Eyes Wide open AA and Extended Target Window
        /if (${Ini[${IniFileName},General,XTSlot].Length}) {
            /varset XTSlot ${Ini[${IniFileName},General,XTSlot]}
            /if (${XTSlot}) /xtarget set ${XTSlot} autohater
            /ini "${IniFileName}" "General" "XTSlot" "0"
            /while (${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]}) {
               /delay 5
            }
            /varset XTSlot 0
        }
        /for n 1 to ${XSlotTotal}
            /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]}) {
                /if (${XTSlot} && !${XTSlot2}) /varset XTSlot2 ${n}
                /if (${XTSlot}==0) {
                    /varset XTSlot ${n}
                    /ini "${IniFileName}" "General" "XTSlot" "${XTSlot}"
                }
            }
        /next n
        |  Added extra slot check and Error Message
        /if (${XTSlot}==0 || ${ChainPull} && !${XTSlot2}) {
            /echo You need more slots in your Extended Target Window set to Auto.
            /if (${ChainPull}) {
                /echo Please set at least 2 slots to Auto for Chain Pulling and restart KissAssist.
            } else {
                /echo Please set at least 1 slot to Auto and restart KissAssist.
            }
            /endmacro
        }
        | Changed Logic for populating AggroTargetID. This change will include mobs in camp not on XTarget.
        /noparse /varset AggroTargetID ${If[${Me.XTarget[${XTSlot}].ID},${Me.XTarget[${XTSlot}].ID},${If[${AggroTargetID2},${AggroTargetID2},0]}]}
        | Look at removing the AggroTargetID2 code if the change below works.
        | It did NOT work. Will have to update the pull code NOT to use MyTargetID and start using PullMob.
        /noparse /varset PullAggroTargetID ${If[${ChainPull}==0,${Me.XTarget[${XTSlot}].ID},${If[${Me.XTarget[${XTSlot}].ID} && (${Me.XTarget[${XTSlot}].ID}==${MyTargetID} || ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID} || ${Me.XTarget[${XTSlot2}].ID}),${MyTargetID},0]}]}

        /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance

        /if (${PullLevel.Find[auto]}) {
           /varcalc PullMin ${Me.Level}-5
           /varcalc PullMax ${Me.Level}+2
           /varset PullLevel auto
        } else /if (${PullLevel.Equal[0|0]} || ${PullLevel.Equal[0]} || ${PullLevel.Equal[null]} || !${PullLevel.Find[|]}) {
           /varset PullMin 1
           /varset PullMax 200
           /varset PullLevel off
        } else /if (${PullLevel.Find[linked]}) {
           /varset PullMin ${Int[${PullLevel.Arg[1,|]}]}
           /varset PullMax ${Int[${PullLevel.Arg[2,|]}]}
           /varset PullLevel linked
        } else {
           /varset PullMin ${Int[${PullLevel.Arg[1,|]}]}
           /varset PullMax ${Int[${PullLevel.Arg[2,|]}]}
           /varset PullLevel fixed
        }
        /if (${PullMin}>${PullMax} || ${PullMin}==0 || ${PullMax}==0) {
           /echo Invalid Pull Level Settings resetting to default.
           /varset PullMin 1
           /varset PullMax 200
           /varset PullLevel off
        }
        /if (${PullArcWidth}>359) /varset PullArcWidth 0
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
            /if (${PullWith.Find[|]} && ${PullWith.Arg[2,|].Length}) {
                /if (!${FindItemCount[=${PullWith.Arg[2,|]}]}) {
                    /varset WorkString ${PullWith.Arg[2,|]}
                    /for n 1 to ${Buffs.Size}
                        /if (${Buffs[${n}].Arg[2,|].Equal[summon]} && ${Buffs[${n}].Arg[3,|].Equal[${WorkString}]}) {
                            /if (${ConOn} && ${Buffs[${n}].Find[|cond]}) {
                                /varset CondNo ${Buffs[${n}].Mid[${Math.Calc[${Buffs[${n}].Find[|cond]}+5]},3]}
                            } else {
                                /varset CondNo 0
                            }
                            /call SummonStuff "${Buffs[${n}].Arg[1,|]}" "${WorkString}" 1 ${CondNo}
                            /if (${FindItemCount[=${PullWith.Arg[2,|]}]}) /break
                        }
                    /next n
                    /if (!${FindItemCount[${PullWith.Arg[2,|]}]}) {
                        /echo You have NO Ammo to pull with and I wasn't able to summon any.
                    }
                }
            }
            /if (${PullWith.Length} && ${PullWith.NotEqual[null]}) /call PullRangeSet
        }
        /if (${g_ExtendedBuffList.Length} && ${g_ExtendedBuffList.NotEqual[null]}) {
            /echo Recovering Extended Buff List.
            /varset ExtendedBuffList ${g_ExtendedBuffList}
        }
        /if (${Me.Skill[swimming]}) {
            /if (${Me.Skill[swimming]}<200) {
                /varset LocDelayCheckUW 40
            } else {
                /varset LocDelayCheckUW 20
            }
        } else {
            /varset LocDelayCheckUW 40
        }
        /if (!${Me.HaveExpansion[seeds of destruction]}) /varset MercOn 0
 |      /if (${IAmABard}) {
 |          /if (!${TwistOn}) {
 |              /varset TwistWhat 0
 |          } else {
 |              /if (${TwistWhat.NotEqual[0]} && ${Int[${TwistWhat}]}==0) /varset TwistWhat 0
 |              /if (!${TwistWhat} ) /varset TwistOn 0
 |          }
 |          /if (${TwistMed.NotEqual[0]} && ${Int[${TwistMed}]}==0) /varset TwistMed 0
 |          /if (!${MeleeTwistOn}) {
 |              /varset MeleeTwistWhat 0
 |          } else {
 |              /if (${MeleeTwistWhat.NotEqual[0]} && ${Int[${MeleeTwistWhat}]}==0) /varset MeleeTwistWhat 0
 |              /if (!${MeleeTwistWhat}) /varset MeleeTwistOn 0
 |          }
 |      }
    /return
| ----------------------------------------------------------------------------
| SUB: InitPlugins
| ----------------------------------------------------------------------------
    Sub InitPlugins
        /declare PeersZone string local
        /call CheckPlugin MQ2Exchange 1
        /call CheckPlugin MQ2Moveutils 1
        /call CheckPlugin MQ2Posse 1
        /call CheckPlugin MQ2Rez 1
        /if (${Bool[${Plugin[mq2twist]}]}) /plugin mq2twist unload noauto
		
        /moveto set alwaysUW off
		/if (${IAmABard}) {
			/call CheckPlugin MQ2Medley 1
			/call CheckPlugin MQ2React 1			
		} else {
            /if (${Bool[${Plugin[mq2medley]}]}) /plugin mq2medley unload noauto
            /if (${Bool[${Plugin[mq2twist]}]}) /plugin mq2twist unload noauto
            /declare Medley int outer 0
        }
        /if (${UseMQ2Melee}) {
            /call CheckPlugin MQ2Melee
            /if (${Bool[${Plugin[mq2melee]}]}) {
            |  Turn aggro mode off and turn on melee mode in MQ2Melee
                /squelch /melee aggro=0
                /squelch /melee melee=1
                /squelch /melee petassist=0
                /squelch /melee on
                |stickmode: 0=MQ2Melee Auto mode, 1=Use custom StickCmd from MQ2Melee ini settings,2=Turn stick off. No /Sticking.
                /if (${UseMQ2Melee}==1) {
                    /squelch /melee stickmode=0
                } else {
                    /squelch /melee stickmode=1
                }
                /varset StickHow 0
            } else {
                /echo MQ2Melee plugin did NOT load. Setting UseMQ2Melee off.
                /varset UseMQ2Melee 0
                /if (${StickHow.Equal[0]}) /varset StickHow auto
            }
        } else {
            /if (${Bool[${Plugin[mq2melee]}]}) {
                /plugin mq2melee unload noauto
                /varset MQ2MeleeReload 1
            }
            /if (${StickHow.Equal[0]}) /varset StickHow auto
        }
        /if (${Bool[${Plugin[mq2cast]}]} && !${UseMQ2Melee}) {
            /plugin mq2cast unload noauto
            /varset MQ2CastReload 1
        }
        /varset DStickHow ${StickHow}
        /if (${EQBCOn} && !${Macro.IsTLO[EQBC]}) /plugin mq2eqbc noauto
        /if (${DanNetOn}) {
            /if (!${Macro.IsTLO[DanNet]}) {
                /call CheckPlugin mq2dannet 1
            }
            /if (${Zone.ShortName.Find[_]}) {
                /varset PeersZone zone_${Zone.ShortName}
            } else {
                /varset PeersZone zone_${EverQuest.Server.Lower}_${Zone.ShortName}
            }
            /dnet fullnames off
            /echo I see ${DanNet.PeerCount} clients connected to DanNet and ${DanNet.PeerCount[${PeersZone}]} clients in same Zone.
        }
        | Set MQ2moveutils variables
        /stick set autosave off
        /stick set verbflags 0
        /stick set breakonkb on
        /stick set breakonmouse off
        /stick set breakdist ${CampRadiusExceed}
        /stick set breakonwarp on
        /stick set usefleeing on
        /stick set delaystrafe on
        /stick set feign on
        | Set up MQ2rez if RezAcceptOn=1
        | Use new Rez TLO to capture current settings and restore when exiting macro.
        /if (${RezAcceptOn.Arg[1,|].Equal[1]}) {
            /if (!${Bool[${Plugin[mq2rez]}]}) {
                /plugin mq2rez noauto
                /delay 5
            }
            /squelch /rez accept on
            /squelch /rez loot off
            /if (${Int[${RezAcceptOn.Arg[2,|]}]}>0) /rez pct ${Int[${RezAcceptOn.Arg[2,|]}]}
        } else {
            /squelch /rez accept off
        }
		/squelch /rez loot on
        /if (${Macro.IsTLO[Posse]}) {
            /if (${Select[${AFKToolsOn},1,2]}) {
                /posse radius ${AFKPCRadius}
                /posse friendnotify off
                /posse strangernotify on
                /if (!${Posse.Status})  {
                    /posse on
                    /posse load
                }
            }
        } else {
            /varset AFKToolsOn 0
        }
        /if (${DPSMeter}) {
            /call CheckPlugin MQ2DPSAdv 1
            /if (!${Macro.IsTLO[DPSAdv]}) {
                /echo DPSAdv TLO not found. Turning off DPS meter.
                /varset DPSMeter 0
            }
        }
        /if (${Bool[${Plugin[mq2log]}]}) {
            /varset DebugLogging ${Int[${Ini["..\${EverQuest.Server}_${Me.CleanName}.ini",MQ2Log,Enabled]}]}
        }
        /if (${UseSpawnMaster}) {
            /call LoadSpawnMaster
            /if (!${Alert[5].Size}) {
                /echo No Named Mobs Listed for this zone In SpawnMaster INI. Turning off UseSpawnMaster!
                /varset UseSpawnMaster 0
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: StartupCredits
| ----------------------------------------------------------------------------
    Sub StartupCredits
        /echo ================================
        /echo Redguides presents
        /echo ${MacroName} Created by Maskoi
        /echo ${MacroName} v.${MacroVer}.${KissRevision}
        /echo Maintained for RedGuides by Ctaylor22
        /echo ================================
        /if (${EQBCOn} && ${DanNetOn}) {
            /echo Using EQBC for Messaging and DanNet for Everything Else.
        } else /if (${EQBCOn}) {
            /echo Using EQBC for Messaging.
        } else /if (${DanNetOn}) {
            /echo Using DanNet for Everything.
        } else {
            /echo NOT using EQBC or DanNet.
        }
        /echo ================================
        /if (${Select[${Role},tank]}) {
            /if (${IAmMA}) {
                /echo I am Tanking & Main Assist
            }
        } else /if (${Select[${Role},puller]}) {
            /echo I am Puller. KissAssisting >> ${MainAssist} << at ${AssistAt}%
            /if (${ChainPull}) /echo  What? I have to chain pull now.
        } else /if (${Select[${Role},pullertank]}) {
            /echo I am Puller & Tank.
        | PetTank set role
        } else /if (${Select[${Role},pettank]}) {
            /echo My Pet >> ${Me.Pet.CleanName} << is Tanking & KissAssisting >> ${MainAssist} <<
        | PullerPetTank set role
        } else /if (${Select[${Role},pullerpettank]}) {
            /echo I am Pulling & my Pet >> ${Me.Pet.CleanName} << is Tanking.
            /echo We are all doomed.
            /delay 10
            /echo DOOMED!
        | HunterPetTank set role
        } else /if (${Select[${Role},hunterpettank]}) {
            /echo I am Hunting & my Pet >> ${Me.Pet.CleanName} << is Tanking.
        } else /if (${Select[${Role},hunter]}) {
            /echo I am Hunting.
        } else /if (${Select[${Role},offtank]}) {
            /echo I am Off Tanking. KissAssisting >> ${MainAssist} << at ${AssistAt}%
        } else {
            /echo KissAssisting >> ${MainAssist} << at ${AssistAt}%
            /echo ${MainAssist} is a ${MainAssistType} ${Spawn[=${MainAssist}].Class}
        }
        /if (${Role.Find[Puller]} && ${Float[${PullArcWidth}]}>0) {
            /call SetPullAngles ${Me.Heading.Degrees} ${Float[${PullArcWidth}]} 1
            /echo Pulling an Area starting from the Left at ${PullLSide} degrees ending at ${PullRSide} degrees.
        }
        /squelch /target clear
        /squelch /assist off
        /if (${Role.Find[pull]} || ${Role.Find[hunt]}) {
            /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                /call BroadCast r "PULL: Path >> ${PullPath} <<  found with ${PullPathWpCount} waypoints."
                /call BroadCast r "PULL: Using MQ2AdvPath to Pull with."
            } else /if (${Bool[${Plugin[MQ2Nav]}]}) {
                /if (${Navigation.MeshLoaded}) {
                    | Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
                    /varset PullMoveUse nav
                    /call BroadCast r "PULL: The MQ2Nav mesh for ${Zone} is loaded"
                    /call BroadCast r "PULL: Using MQ2Nav to Pull with ${PullWith}"
                } else {
                    /varset PullMoveUse los
                    /call BroadCast r "PULL: Using Line of Sight to Pull with ${PullWith}"
                }
            } else {
                /varset PullMoveUse los
                /call BroadCast r "PULL: Using Line of Sight to Pull with ${PullWith}"
            }
        } else {
            /if (${Bool[${Plugin[MQ2Nav]}]}) {
                /if (${Navigation.MeshLoaded}) {
                    | Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
                    /varset PullMoveUse nav
                    /echo The MQ2Nav mesh for ${Zone} is loaded
                    /echo Using MQ2Nav to Move.
                } else {
                    /varset PullMoveUse los
                }
            } else {
                /varset PullMoveUse los
                /echo Using MoveUtil to move with.
            }
        }
        /if (${Select[${PullMoveUse},los,nav]}>=1) /varset UseWayPointZ 0
    /return
| ----------------------------------------------------------------------------
| SUB: Startup Miscelanious Stuff
| ----------------------------------------------------------------------------
    Sub StartupMisc
        /declare s_Temp1 string local ${Ini[${IniFileName},Spells,Gem1,BLANK]}
        /declare i_x int local 0
        | If I am group leader set Main Assist Tag for Group Check for pet and make master MainAssist
        /if (${Select[${Me},${Group.Leader}]}) {
            /if (${Spawn[group ${MainAssist}].ID} || (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[group ${Spawn[${MainAssist}].Master.CleanName}].ID})) {
                | If Main Assist is someone else than who its suppose to be unset Group tag
                /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
                    /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
                }
                /if (!${Group.MainAssist.Name.Length}) {
                    /if (${Spawn[${MainAssist}].Type.Equal[pet]}) {
                        /call BroadCast r "Assigning ${Spawn[${MainAssist}].Master.CleanName} as Main Assist in Group Window"
                        /call AssignGroupRole set "${Spawn[${MainAssist}].Master.CleanName}" 2
                    } else {
                        /call BroadCast r "Assigning ${MainAssist} as Main Assist in Group Window"
                        /call AssignGroupRole set "${MainAssist}" 2
                    }
                }
            } else /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
                /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
            }
        }
        /if (${LoadSpellSet}) /call LoadSpellSet
        /if (${s_Temp1.Equal[blank]}) /call Bind_WriteMySpells 1
    /return
| ----------------------------------------------------------------------------
| SUB: LoadAliases
| ----------------------------------------------------------------------------
    Sub LoadAliases
    | ************************* Aliases **************************************|
        DEBUGN Ini/Alias info ${KissAssistVer.NotEqual[${MacroVer}]} "${KissAssistVer}" "${MacroVer}"
        /if (${KissAssistVer.NotEqual[${MacroVer}]} || ${ForceAlias}) {
            /if (${ForceAlias}) {
                /echo Resetting Aliases this can take up to 1 min
            } else {
                /echo Version Mismatch Detected, Resetting Aliases this can take up to 1 min
            }
            /squelch /alias /afktoolson     /changevarint AFKTools AFKToolsOn
            /squelch /alias /assistat       /changevarint Melee AssistAt
            /squelch /alias /autofireon     /togglevariable AutoFireOn
            /squelch /alias /autorezon      /togglevariable AutoRezOn
            /squelch /alias /buffson        /togglevariable BuffsOn
            /squelch /alias /camphere       /togglevariable ReturnToCamp
            /squelch /alias /campradius     /changevarint General CampRadius
            /squelch /alias /chase          /togglevariable ChaseAssist
            /squelch /alias /chasedistance  /changevarint General ChaseDistance
            /squelch /alias /chaseoff       /changevarint General ChaseAssist 0
            /squelch /alias /chaseon        /changevarint General ChaseAssist 1
            /squelch /alias /debugall       /debug all on log
            /squelch /alias /dpsinterval    /changevarint DPS DPSInterval
            /squelch /alias /dpsmeter       /togglevariable DPSMeter
            /squelch /alias /dpson          /changevarint DPS DPSOn
            /squelch /alias /dpsskip        /changevarint DPS DPSSkip
            /squelch /alias /dpsspam        /togglevariable DPSSpam
            /squelch /alias /dpswrite       /togglevariable DPSWriteOn
            /squelch /alias /healson        /changevarint Heals HealsOn
            /squelch /alias /interrupton    /togglevariable CastingInterruptOn
            /squelch /alias /ktdismount     /echo KTDismount
            /squelch /alias /ktdoor         /echo KTDoorClick
            /squelch /alias /kthail         /echo KTHail
            /squelch /alias /ktinvite       /echo KTInvite
            /squelch /alias /ktsay          /echo KTSay
            /squelch /alias /kttarget       /echo KTTarget
            /squelch /alias /looton         /changevarint General LootOn
            /squelch /alias /maxradius      /changevarint Pull MaxRadius
            /squelch /alias /maxzrange      /changevarint Pull MaxZRange
            /squelch /alias /medcombat      /togglevariable MedCombat
            /squelch /alias /medstart       /changevarint General MedStart
            /squelch /alias /meleedistance  /changevarint Melee MeleeDistance
            /squelch /alias /meleeon        /togglevariable MeleeOn
            /squelch /alias /mercassistat   /changevarint Merc MercAssistAt
            /squelch /alias /mezon          /changevarint Mez MezOn
			/squelch /alias /docharm        /changevarint Pet CharmOn
			/squelch /alias /charmkeep      /togglevariable CharmKeep
			/squelch /alias /charmon   		/togglevariable CharmOn
            /squelch /alias /medleyon   		/togglevariable MedleyOn
            /squelch /alias /movewhenhit    /togglevariable MoveWhenHit
            /squelch /alias /pethold        /togglevariable PetHold
            /squelch /alias /peton          /togglevariable PetOn
            /squelch /alias /pettoyson      /togglevariable PetToysOn
            /squelch /alias /pettoysplz     /echo PetToysPlease
            /squelch /alias /rebuffon       /togglevariable RebuffOn
            /squelch /alias /returntocamp   /togglevariable ReturnToCamp
            /squelch /alias /rezallon       /togglevariable AutoRezAll 1
            /squelch /alias /rezalloff      /togglevariable AutoRezAll 0
            /squelch /alias /scatteron      /togglevariable ScatterOn
            /squelch /alias /setae          /iniwrite AE
            /squelch /alias /setaggro       /iniwrite Aggro
            /squelch /alias /setcharmed       /varset CharmPet ${Me.Pet.ID}			
            /squelch /alias /setbackoff     /backoff
            /squelch /alias /setbuffs       /iniwrite Buffs
            /squelch /alias /setburn        /iniwrite Burn
            /squelch /alias /setcure        /iniwrite Cure
            /squelch /alias /setdps         /iniwrite DPS
            /squelch /alias /setheals       /iniwrite Heals
            /squelch /alias /katwistpause   /togglevariable TwistHold 1
            /squelch /alias /katwistresume  /togglevariable TwistHold 0
            /squelch /alias /switchma       /switchma
            /squelch /alias /waithere       /togglevariable waithere
            /squelch /alias /trackme        /trackmedown
            /squelch /alias /debug delete
            /squelch /alias /debugbuffs delete
            /squelch /alias /debugcombat delete
            /squelch /alias /debugcast delete
            /squelch /alias /debugchainpull delete
            /squelch /alias /debugheal delete
            /squelch /alias /debugmez delete
            /squelch /alias /debugmove delete
            /squelch /alias /debugpull delete
            /squelch /alias /debugrk delete
            /squelch /alias /dpsspam delete
            /ini "${IniFileName}" "General" "KissAssistVer" "${MacroVer}"
        }
        DEBUGN Aliases processed
    /return
| ----------------------------------------------------------------------------
| SUB: DeclareOuters
| ----------------------------------------------------------------------------
    Sub DeclareOuters(string declareFlag)
        | Do Not Edit These *****************************************************|
        /if (${declareFlag.Equal[pre]}) {
            /declare BroadCastSay           string      outer       bc
            /declare CampXLoc               int         outer       ${Me.X}
            /declare CampYLoc               int         outer       ${Me.Y}
            /declare CampZLoc               int         outer       ${Me.Z}
            /declare CampZone               int         outer       ${Zone.ID}
            /declare Debug                  int         outer       0
            /declare DebugAllOn             int         outer       0
            /declare DebugBuffs             int         outer       0
            /declare DebugCast              int         outer       0
            /declare DebugChainP            int         outer       0
			/declare DebugCharm               int         outer       0
            /declare DebugCombat            int         outer       0
            /declare DebugHeals             int         outer       0
            /declare DebugMez               int         outer       0
            /declare DebugMove              int         outer       0
            /declare DebugPet               int         outer       0
            /declare DebugPull              int         outer       0
            /declare DebugRK                int         outer       0
            /declare DebugTime              int         outer       0
            /declare DebugLogging           int         outer       0
            /declare ForceAlias             int         outer       1
            /declare GoMTimer               timer       outer       0
            /declare GroupWatchPct          int         outer       20
            /declare IAmABard               bool        outer       ${Me.Class.Name.Equal[Bard]}
            /declare IniFileName            string      outer
            /declare KissAssistVer          string      outer
            /declare KissRevision           string      outer       031
            /declare LookForward            int         outer       ${Me.Heading.DegreesCCW}
            /declare LoadFromINI            int         outer       0
            /declare MacroName              string      outer       KissAssist
            /declare BuffFileName           string      outer       ${MacroName}_Buffs.ini
            /declare InfoFileName           string      outer       ${MacroName}_Info.ini
            /declare MacroVer               string      outer       12.002
            /declare Parse0                 bool        outer       TRUE
            /declare PIniSet                int         outer       0
            /declare ZoneName               string      outer       ${Zone}
        } else /if (${declareFlag.Equal[main]}) {
            /declare AddSpam                timer       outer       0
            |/declare AddsArray[50,3]        string      outer       NULL
            /declare AdvpathPointNum        int         outer       0
            /declare AdvpathPointX          float       outer       0
            /declare AdvpathPointY          float       outer       0
            /declare AdvpathPointZ          float       outer       0
            /declare AEDisplayMobInfo       int         outer       0
            /declare AggroOffTimer          timer       outer       0
            /declare AggroTargetID          string      outer
            /declare AggroTargetID2         string      outer       0
            /declare AmmoSwitch             int         outer       0
            /declare Attacking              int         outer       0
            /declare AutoRezAll             int         outer       0
            /declare BagNum                 int         outer       0
            /declare BagNumLast             int         outer       0
            /declare BeforeArray[5]         string      outer       null
            /declare BeginMobID             string      outer
            /declare Banestrike             string      outer
            /declare BardStartTwist         int         outer       0
            /declare BardWasTwisting        string      outer       null
            /declare BindActive             int         outer       0
            /declare BurnActive             int         outer       0
            /declare BurnCalled             int         outer       0
            /declare BurnOn                 int         outer       1
            /declare BurnID                 int         outer       0
            /declare BlockedBuffsCount      int         outer       0
            /declare CalledTargetID         int         outer       0
            |/declare CalmCount              int         outer       0
            /declare CampOnDeathTimer       timer       outer       0
            /declare CampfireClickTimer     timer       outer       0
            /declare CampfireTimer          timer       outer       0
            /declare CantHit                int         outer       0
            /declare CantSee                int         outer       0
            /declare CastResult             string      outer
            /declare castReturn             string      outer       CAST_CANCELLED
            /declare CheckResisted          int         outer       0
            /declare ChainPullTemp          string      outer
            /declare CharmAETimer             timer       outer       0
            /declare CharmArray[50,3]         string      outer       NULL
            /declare CharmBroke               int         outer       0
            /declare CharmImmuneIDs           string      outer
            /declare CharmMobAECount          int         outer       0
			/declare CharmAEClosest				int			outer 		0
            /declare CharmMobCount            int         outer       0
            /declare CharmMobDone             int         outer       0
            /declare CharmMobFlag             int         outer       0
			/declare CharmPet				int			outer		0
			/declare CharmKeep				int			outer		0
            /declare CheckOnReturn          int         outer       0
            /declare CleanBuffsTimer        timer       outer       0
            /declare ClearSpawnValue        spawn       outer
            /declare ColorIdx               int         outer       0
            /declare ColorList              string      outer       tWgtuwyr
            /declare CombatStart            int         outer       0
            /declare ConColor               string      outer       t
            /declare CorpseRezCheck         string      outer       null
            /declare CursorID               int         outer       0
            /declare CursorIDCount          int         outer       0
            /declare CursorIDTimer          timer       outer       0
            /declare DebuffCount            int         outer       0
            /declare DebugTicker            timer       outer       0
            /declare DMZ                    int         outer       ${Select[${Zone.ID},345,344,202,203,279,151,33506]}
            /declare DNout                  string      outer       null
            /declare DontMoveMe             int         outer       0
            /declare DPSPaused              int         outer       0
            /declare DPSSpam                int         outer       0
            /declare DPSTarget              int         outer       0
            /declare DPSTwisting            int         outer       0
            /declare DPSWriteOn             int         outer       0
            /declare DragCorpse             int         outer       0
            /declare DStickHow              string      outer       0
            /declare DurationMod            float       outer       1
            /declare EventByPass            int         outer       0
            /declare EventFlag              int         outer       0
            /declare EventTimer             timer       outer       0
            /declare EngageWaitTimer        timer       outer       0
            /declare ExtendedBuffList       string      outer
            /declare FailCounter            int         outer       0
            /declare FailMax                int         outer       3
            /declare ForceBuffs             int         outer       0
            /declare GemSlots               int         outer       8
            /declare GMailEvents            string      outer
            /declare GSent                  int         outer       0
            /declare GoMActive              int         outer       0
            /declare GoMByPass              int         outer       0
            /declare GotHitToggle           int         outer       0
            /declare GlobalIndex            int         outer       0
            /declare HasBuffDuration        int         outer       0
            /declare HealAgain              int         outer       0
            /declare HealRemChk1            string      outer       Divine Barrier
            /declare HealRemChk2            string      outer       Touch of the Divine
            /declare HealRemChk3            string      outer       null
            /declare IAMCastingID           int         outer       0
            /declare IAmDead                int         outer       0
            /declare IAmMA                  int         outer       0
            /declare IniNextTimer           timer       outer       0
            /declare ItemsGiven             int         outer       0
            /declare JoinedParty            timer       outer       0
            /declare JustZoned              timer       outer       0
            /declare KABegActive            int         outer       0
            /declare KAPetBegActive         int         outer       0
            /declare KABegForList           string      outer
            /declare KABegForPetList        string      outer
            /declare LastDPSCast            string      outer
            /declare LastHealCheck          timer       outer       0
            /declare LastMobPullID          int         outer       0
            /declare LastResisted           int         outer
            /declare LastTargetID           int         outer
            /declare LastZone               int         outer       ${Zone.ID}
            /declare LocDelayCheckUW        int         outer       0
            /declare LooterAssigned         int         outer       0
            /declare MacroReturn            string      outer
            /declare MASitTime              timer       outer       0
            /declare MainAssist             string      outer
            /declare MainAssistClass        string      outer
            /declare MainAssistType         string      outer
            /declare MapSet                 int         outer       0
            /declare MashArray[10]          string      outer       null
            /declare MedStat                string      outer
            /declare MedStat2               string      outer       Endurance
            /declare Medding                int         outer       0
            /declare MeddingInterrupted     int         outer       0
            /declare MercAssisting          int         outer       0
            /declare MercInGroup            int         outer       0
            /declare MezAETimer             timer       outer       0
            /declare MezArray[50,3]         string      outer       NULL
            /declare MezBroke               int         outer       0
            /declare MezImmuneIDs           string      outer
            /declare MezMobAECount          int         outer       0
            /declare MezMobCount            int         outer       0
            /declare MezMobDone             int         outer       0
            /declare MezMobFlag             int         outer       0
            /declare MissingComponent       int         outer       0
            /declare MobCount               int         outer       0
            /declare MobFlag                int         outer       1
            /declare MobsToIgnoreByID       string      outer       null
            /declare MountOn                int         outer       1
            /declare MQ2MeleeReload         int         outer       0
            /declare MQ2CastReload          int         outer       0
            /declare MQ2SpawnMasterReload   int         outer       0
            /declare MyAAExp                float       outer       ${Me.PctAAExp}
            /declare MyExp                  float       outer       ${Me.PctExp}
            /declare MyMerc                 string      outer       0
            /declare MyOriginalRole         string      outer
            /declare MyTargetID             int         outer       0
            /declare MyTargetName           string      outer       0
			/declare MyPetID	            int         outer       ${Me.Pet.ID}
            /declare NamedCheck             int         outer       0
            /declare NeedCuring             int         outer       0
            /declare OrigRanged             string      outer       ${Me.Inventory[ranged].Name}
            /declare ParseDPSTimer          int         outer       0
            /declare PetActiveState         int         outer       0
            /declare PetAttack              timer       outer       0
            /declare PetAttackRange         int         outer       0
            /declare PetBuffCheck           timer       outer       0
            /declare PetFocusOn             int         outer       0
            /declare PetFollowTimer         timer       outer       60s
            /declare PetSuspendState        int         outer       0
            /declare PetTanking             int         outer       0
            |/declare PetTauntOn             int         outer       0
            /declare PetTotCount            int         outer       0
            /declare PetToyList             string      outer
            /declare PullAggroTargetID      string      outer
            /declare PullAlertTimer         timer       outer       0
            /declare PullAmmo               string      outer       NULL
            /declare Pulled                 int         outer       0
            /declare PullHeading            float       outer       0
            /declare PullLSide              float       outer       0
            /declare PullRSide              float       outer       0
            /declare PullHold               int         outer       0
            /declare PullHoldCond           string      outer       0
            /declare PullIgnore1            string      outer       NULL
            /declare PullIgnore2            string      outer       NULL
            /declare PullIgnore3            string      outer       NULL
            /declare Pulling                int         outer       0
            /declare PullItem               string      outer       NULL
            /declare PullMax                int         outer       0
            /declare PullMaxCount           int         outer       500
            /declare PullMin                int         outer       0
            /declare PullMob                int         outer       0
            /declare PullMoveUse            string      outer
            /declare PullNavDistance        int         outer       0
            /declare PullPathArrayX[999]    float       outer
            /declare PullPathArrayY[999]    float       outer
            /declare PullPathArrayZ[999]    float       outer
            /declare PullPathWpCount        int         outer       0
            /declare PullSearchIter         int         outer       1
            /declare PullRange              int         outer       0
            /declare PullTimer              timer       outer       0
            /declare PullTooFar             int         outer       0
            /declare PullWithAlt            string      outer       Melee
            /declare PullWaitTimer1         timer       outer       0
            /declare PullWaitTimer2         timer       outer       0
            /declare PullWaitRemaining      int         outer       0
            /declare PullXPCheck            int         outer       1
            /declare p_AssistAt             int         outer       0
            /declare p_PullPath             string      outer       null
            /declare p_Role                 string      outer       null
            /declare RangedSwitch           int         outer       0
            /declare ReMemCast              int         outer       0
            /declare ReMemCastLW            int         outer       0
            /declare ReMemWaitLong          string      outer       null
            /declare ReMemWaitShort         string      outer       null
            /declare ReadBuffsTimer         timer       outer       0
            /declare Redguides              int         outer       1
            /declare RememberCamp           int         outer       0
            /declare SearchType             string      outer
            /declare SHealPct               int         outer
            /declare SingleHealPoint        int         outer       0
            /declare SingleHealPointMA      int         outer       0
            /declare SingleHealPointRange   int         outer       0
            /declare SitToMedTimer          timer       outer       6s
            /declare SpamTimer              timer       outer       0
            /declare SpamTimer1             timer       outer       0
            /declare SpamTimer2             timer       outer       0
            /declare SpamTimer3             timer       outer       0
            /declare SpellReadyL            int         outer       0
            /declare StayPut                int         outer       0
            /declare StickDist              int         outer       13
            /declare StickDistUW            int         outer       10
            /declare TankTimer              timer       outer       0
            /declare TempAmmo               string      outer       ${Me.Inventory[ammo].Name}
            /declare TempMaxRadius          int         outer       0
            /declare ToClose                int         outer       0
            /declare TributeTimer           timer       outer       0
            /declare Twisting               int         outer       0
            /declare TwistHold              int         outer       0
            /declare ValidTarget            int         outer       0
            /declare WasTwisting            bool        outer       FALSE
            /declare WaitTimer              timer       outer       0
            /declare WeaveArray[50]         string      outer       null
            /declare WhoToChase             string      outer
            /declare WorkSpawn              spawn       outer
            /declare WriteBuffsMercTimer    timer       outer       0
            /declare WriteBuffsPetTimer     timer       outer       0
            /declare WriteBuffsTimer        timer       outer       0
            /declare XSlotTotal             int         outer       20
            /declare XTSlot                 int         outer       0
            /declare XTSlot2                int         outer       0
            /declare XTarAutoSet            int         outer       1
            /declare XTarToHeal[20]         int         outer       0
            /declare ZDist                  float       outer       0
        } else /if (${declareFlag.Equal[post]}) {
            /declare ReMemMiscSpell         string      outer       ${Me.Gem[${MiscGem}].Name}
            /declare ReMemMiscSpellLW       string      outer       ${Me.Gem[${MiscGemLW}].Name}
            /declare WayPointZRange         int         outer       ${MaxZRange}
        } else /if (${declareFlag.Equal[global]}) {
            /if (!${Defined[k_globals]}) {
                /declare k_globals          int         global      2
                /declare g_PetToysGave      string      global
                /declare g_ExtendedBuffList string      global
            } else /if (${k_globals}==1) {
                /declare g_ExtendedBuffList string      global
                /varset k_globals 2
            }
        }
    DEBUGN Misc Declares Processed
    /return
| -------------------------------------------------------------------------------------
| SUB: PParse Parse passed command line parameters
| -------------------------------------------------------------------------------------
    Sub PParse(int iniLoaded, int nump)
        DEBUGN PParse: iniLoaded: ${iniLoaded} NumP: ${nump}
        /declare i int local 0
        /declare j int local 0
        /declare k int local 0
        /declare pMaxRadius int local 0
        /declare TempPathX float local 0
        /declare TempPathY float local 0
        /declare TempPathZ float local 0
        /declare ipa int local 0
        /declare ipb int local 0
        /declare numc int local ${Math.Calc[${nump}-1]}
        /if (!${nump}) /return
        | Command Line Passed Parameterss start with the number 0. 0 is the first param and is counted as 1 param even though the loop is 0 to 0.
        /for i 0 to ${numc}
            DEBUGN PParse: ${i}. ${Defined[PParam${i}]} P${i}: ${PParam${i}}
            /if (${Defined[PParam${i}]}) {
                | ipa increases the param counter by 1 so we can assign the variable after the current parma.
                | /mac kissassist assist ma bob - if Param1 is ma for mainassist the next param is bob
                /varcalc ipa ${i}+1
                /if (${i}>0) /varcalc ipb ${i}-1
                /if (${Select[${PParam${i}},debug,debugall]}) /continue
                /if (!${iniLoaded}) {
                    /if (${PParam${i}.Equal[ini]}) {
                        /varset IniFileName ${PParam${ipa}}
                        /echo Ini file has been set to >> ${PParam${ipa}} <<
                        /varset PIniSet 1
                    } else /if (${PParam${i}.Equal[forcealias]}) {
                        /varset ForceAlias 1
                    }
                } else {
                    /if (${PParam${i}.Equal[ini]}) {
                        /varcalc i ${i}+1
                        /continue
                    } else /if (${Select[${PParam${i}},debug,debugall,forcealias]}) {
                        /continue
                    } else /if (${Select[${PParam${i}},assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]}) {
                        /varset p_Role ${PParam${i}}
                    } else /if (${PParam${i}.Equal[ma]}) {
                        /if (${Defined[PParam${ipa}]}) {
                            /varset MainAssist ${PParam${ipa}}
                            /varcalc i ${i}+1
                        } else {
                            /varset MainAssist
                            /break
                        }
                    } else /if (${PParam${i}.Equal[assistat]}) {
                        /if (${Defined[PParam${ipa}]}) {
                            /varset p_AssistAt ${PParam${ipa}}
                            /varcalc i ${i}+1
                        } else {
                            /varset p_AssistAt 95
                        }
                        /continue
                    } else /if (${PParam${i}.Equal[parse]}) {
                        /if (${Defined[PParam${ipa}]}) {
                            /varset ParseDPSTimer ${PParam${ipa}}
                            /varcalc i ${i}+1
                        } else {
                            /varset ParseDPSTimer 60
                        }
                        /continue
                    } else /if (${PParam${i}.Equal[scanini]}) {
                        /ini "KissAssist_Buffs.ini" ${Me.ID} Zone NULL
                    } else /if (${PParam${i}.Equal[autoload]}) {
                        /varset LoadFromINI 1
                    } else /if (${PParam${i}.Equal[path]}) {
                        /if (!${Defined[PParam${ipa}]}) {
                            /echo Please provide a Path name when using the Path paramater.
                            /varset PullMoveUse
                            /varset PullPathWpCount 0
                        } else {
                            /call CheckPlugin MQ2AdvPath
                            /if (${Bool[${Plugin[MQ2AdvPath]}]}) {
                                /delay 20 ${AdvPath.Active}
                                | Play path on pause to load info . Only way we can grab info from advpath
                                /if (${AdvPath.PathList[${PParam${ipa}}]}) {
                                    /play ${PParam${ipa}} pause
                                    /varset p_PullPath ${PParam${ipa}}
                                    /delay 10
                                    | Set PullPathWpCount with total amount of waypoints in path
                                    /varset PullPathWpCount ${AdvPath.Waypoints}
                                    | Load path points into array
                                    /for k 1 to ${PullPathWpCount}
                                        DEBUGN PParse WP#: ${Int[${Math.Calc[${k}-1]}]}-${k} Distance Between: ${Math.Distance[${TempPathY},${TempPathX}:${AdvPath.Y[${k}]},${AdvPath.X[${k}]}]}
                                        /varset PullPathArrayX[${k}] ${AdvPath.X[${k}]}
                                        /varset PullPathArrayY[${k}] ${AdvPath.Y[${k}]}
                                        /varset PullPathArrayZ[${k}] ${AdvPath.Z[${k}]}
                                        /varset TempPathX ${PullPathArrayX[${k}]}
                                        /varset TempPathY ${PullPathArrayY[${k}]}
                                        /varset TempMaxRadius ${Math.Distance[${CampYLoc},${CampXLoc}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                                        /if (${TempMaxRadius}>${pMaxRadius}) /varset pMaxRadius ${TempMaxRadius}
                                        DEBUGN PParse: WP: ${k} WPX: ${PullPathArrayX[${k}]} WPY: ${PullPathArrayY[${k}]}
                                    /next k
                                    /varset TempMaxRadius ${pMaxRadius}
                                    /play off
                                    | Tell Kiss we are using MQ2advpath for pulling
                                    /varset PullMoveUse advpath
                                }
                            } else {
                                /echo Path ${PParam${ipa}} not found.
                                /varset PullMoveUse
                                /varset PullPathWpCount 0
                            }
                        }
                    } else {
                        /if (${Int[${PParam${i}}]}==0) {
                            /varset MainAssist ${PParam${i}}
                        } else /if (${Int[${PParam${i}}]} >= 1 && ${Int[${PParam${i}}]} <= 100) {
                            /varset p_AssistAt ${PParam${i}}
                        }
                    }
                }
            }
        /next i
        /if (${iniLoaded}) {
            /if (${Debug}) /echo \atDEBUG PParse Leave Role: ${p_Role} MA: ${MainAssist} AssistAt: ${p_AssistAt} PullPath: ${p_PullPath} Parse: ${ParseDPSTimer}
        } else {
            /if (${Debug}) /echo \atDEBUG PParse Leave IniFile: ${IniFileName} InitAlias: ${ForceAlias}
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs
| ----------------------------------------------------------------------------
    Sub WriteBuffs
        /if (${WriteBuffsTimer} || !${Redguides} || ${AggroTargetID} || ${EverQuest.GameState.NotEqual[INGAME]}) /return
        /if (${DanNetOn}) /return
        DEBUGBUFF WriteBuffs Enter
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        | Set block buffs count to 30 on emu servers and 40 on live
        /if (${MacroQuest.Build}==4) {
            /varset BlockedBuffsCount 30
        } else {
            /varset BlockedBuffsCount 40
        }
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Blockedbuffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs
        /ini "KissAssist_Buffs.ini" "${Me.ID}" AmILooting ${LootOn}
        /ini "KissAssist_Buffs.ini" "${Me.ID}" MyRole ${Role}
        | Write all current buffs to Kissassist_Buffs.ini file
        /for i 1 to 41
            /varset BuffList ${Me.Buff[${i}].Name}
            /if (${BuffList.Length} && ${BuffList.NotEqual[null]}) {
                DEBUGN WriteBuffs: ${i}-${BuffList}
                /if (${BuffList.Find[:Permanent]}>1) /varset BuffList ${BuffList.Left[${Math.Calc[${BuffList.Find[:Permanent]}-1]}]}
                /varset Writebufflist ${Writebufflist}${BuffList}|
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs "${Writebufflist}"
        |/delay 15
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 1 to ${BlockedBuffsCount}
            /varset Blockedbuff ${Me.BlockedBuff[${k}].Name}
            /if (${Blockedbuff.Length} && ${Blockedbuff.NotEqual[null]}) {
                /varset Blockedbufflist ${Blockedbufflist}${Blockedbuff}|
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedBuffWnd].Open}) /windowstate BlockedBuffWnd close
        /varset WriteBuffsTimer 30s
        DEBUGBUFF WriteBuffs Leave
    /return
| ----------------------------------------------------------------------------
| Bind SUB: For my commands to be included in the kissmycmds.inc
| ----------------------------------------------------------------------------
    Sub Bind_MyCmds(myCMD, p_1, p_2, p_3)
        /if (!${SubDefined[mycmds]}) /return false
        /if (!${Bool[${myCMD}]}) /return false
        /if (!${SubDefined[${myCMD}]}) /return false
        /call mycmds "${myCMD}" "${p_1}" "${p_2}" "${p_3}"
    /return ${Macro.Return}
#include_optional kissmycmds.inc
